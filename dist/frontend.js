/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 878:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseTransition: function() { return /* binding */ BaseTransition; },
/* harmony export */   BaseTransitionPropsValidators: function() { return /* binding */ BaseTransitionPropsValidators; },
/* harmony export */   Comment: function() { return /* binding */ Comment; },
/* harmony export */   DeprecationTypes: function() { return /* binding */ DeprecationTypes; },
/* harmony export */   EffectScope: function() { return /* binding */ EffectScope; },
/* harmony export */   ErrorCodes: function() { return /* binding */ ErrorCodes; },
/* harmony export */   ErrorTypeStrings: function() { return /* binding */ ErrorTypeStrings; },
/* harmony export */   Fragment: function() { return /* binding */ Fragment; },
/* harmony export */   KeepAlive: function() { return /* binding */ KeepAlive; },
/* harmony export */   ReactiveEffect: function() { return /* binding */ ReactiveEffect; },
/* harmony export */   Static: function() { return /* binding */ Static; },
/* harmony export */   Suspense: function() { return /* binding */ Suspense; },
/* harmony export */   Teleport: function() { return /* binding */ Teleport; },
/* harmony export */   Text: function() { return /* binding */ Text; },
/* harmony export */   TrackOpTypes: function() { return /* binding */ TrackOpTypes; },
/* harmony export */   Transition: function() { return /* binding */ Transition; },
/* harmony export */   TransitionGroup: function() { return /* binding */ TransitionGroup; },
/* harmony export */   TriggerOpTypes: function() { return /* binding */ TriggerOpTypes; },
/* harmony export */   VueElement: function() { return /* binding */ VueElement; },
/* harmony export */   assertNumber: function() { return /* binding */ assertNumber; },
/* harmony export */   callWithAsyncErrorHandling: function() { return /* binding */ callWithAsyncErrorHandling; },
/* harmony export */   callWithErrorHandling: function() { return /* binding */ callWithErrorHandling; },
/* harmony export */   camelize: function() { return /* binding */ camelize; },
/* harmony export */   capitalize: function() { return /* binding */ capitalize; },
/* harmony export */   cloneVNode: function() { return /* binding */ cloneVNode; },
/* harmony export */   compatUtils: function() { return /* binding */ compatUtils; },
/* harmony export */   computed: function() { return /* binding */ computed; },
/* harmony export */   configureCompat: function() { return /* binding */ configureCompat; },
/* harmony export */   createApp: function() { return /* binding */ createApp; },
/* harmony export */   createBlock: function() { return /* binding */ createBlock; },
/* harmony export */   createCommentVNode: function() { return /* binding */ createCommentVNode; },
/* harmony export */   createElementBlock: function() { return /* binding */ createElementBlock; },
/* harmony export */   createElementVNode: function() { return /* binding */ createBaseVNode; },
/* harmony export */   createHydrationRenderer: function() { return /* binding */ createHydrationRenderer; },
/* harmony export */   createPropsRestProxy: function() { return /* binding */ createPropsRestProxy; },
/* harmony export */   createRenderer: function() { return /* binding */ createRenderer; },
/* harmony export */   createSSRApp: function() { return /* binding */ createSSRApp; },
/* harmony export */   createSlots: function() { return /* binding */ createSlots; },
/* harmony export */   createStaticVNode: function() { return /* binding */ createStaticVNode; },
/* harmony export */   createTextVNode: function() { return /* binding */ createTextVNode; },
/* harmony export */   createVNode: function() { return /* binding */ createVNode; },
/* harmony export */   customRef: function() { return /* binding */ customRef; },
/* harmony export */   "default": function() { return /* binding */ Vue$1; },
/* harmony export */   defineAsyncComponent: function() { return /* binding */ defineAsyncComponent; },
/* harmony export */   defineComponent: function() { return /* binding */ defineComponent; },
/* harmony export */   defineCustomElement: function() { return /* binding */ defineCustomElement; },
/* harmony export */   defineEmits: function() { return /* binding */ defineEmits; },
/* harmony export */   defineExpose: function() { return /* binding */ defineExpose; },
/* harmony export */   defineModel: function() { return /* binding */ defineModel; },
/* harmony export */   defineOptions: function() { return /* binding */ defineOptions; },
/* harmony export */   defineProps: function() { return /* binding */ defineProps; },
/* harmony export */   defineSSRCustomElement: function() { return /* binding */ defineSSRCustomElement; },
/* harmony export */   defineSlots: function() { return /* binding */ defineSlots; },
/* harmony export */   devtools: function() { return /* binding */ devtools; },
/* harmony export */   effect: function() { return /* binding */ effect; },
/* harmony export */   effectScope: function() { return /* binding */ effectScope; },
/* harmony export */   getCurrentInstance: function() { return /* binding */ getCurrentInstance; },
/* harmony export */   getCurrentScope: function() { return /* binding */ getCurrentScope; },
/* harmony export */   getTransitionRawChildren: function() { return /* binding */ getTransitionRawChildren; },
/* harmony export */   guardReactiveProps: function() { return /* binding */ guardReactiveProps; },
/* harmony export */   h: function() { return /* binding */ h; },
/* harmony export */   handleError: function() { return /* binding */ handleError; },
/* harmony export */   hasInjectionContext: function() { return /* binding */ hasInjectionContext; },
/* harmony export */   hydrate: function() { return /* binding */ hydrate; },
/* harmony export */   initCustomFormatter: function() { return /* binding */ initCustomFormatter; },
/* harmony export */   initDirectivesForSSR: function() { return /* binding */ initDirectivesForSSR; },
/* harmony export */   inject: function() { return /* binding */ inject; },
/* harmony export */   isMemoSame: function() { return /* binding */ isMemoSame; },
/* harmony export */   isProxy: function() { return /* binding */ isProxy; },
/* harmony export */   isReactive: function() { return /* binding */ isReactive; },
/* harmony export */   isReadonly: function() { return /* binding */ isReadonly; },
/* harmony export */   isRef: function() { return /* binding */ isRef; },
/* harmony export */   isRuntimeOnly: function() { return /* binding */ isRuntimeOnly; },
/* harmony export */   isShallow: function() { return /* binding */ isShallow; },
/* harmony export */   isVNode: function() { return /* binding */ isVNode; },
/* harmony export */   markRaw: function() { return /* binding */ markRaw; },
/* harmony export */   mergeDefaults: function() { return /* binding */ mergeDefaults; },
/* harmony export */   mergeModels: function() { return /* binding */ mergeModels; },
/* harmony export */   mergeProps: function() { return /* binding */ mergeProps; },
/* harmony export */   nextTick: function() { return /* binding */ nextTick; },
/* harmony export */   normalizeClass: function() { return /* binding */ normalizeClass; },
/* harmony export */   normalizeProps: function() { return /* binding */ normalizeProps; },
/* harmony export */   normalizeStyle: function() { return /* binding */ normalizeStyle; },
/* harmony export */   onActivated: function() { return /* binding */ onActivated; },
/* harmony export */   onBeforeMount: function() { return /* binding */ onBeforeMount; },
/* harmony export */   onBeforeUnmount: function() { return /* binding */ onBeforeUnmount; },
/* harmony export */   onBeforeUpdate: function() { return /* binding */ onBeforeUpdate; },
/* harmony export */   onDeactivated: function() { return /* binding */ onDeactivated; },
/* harmony export */   onErrorCaptured: function() { return /* binding */ onErrorCaptured; },
/* harmony export */   onMounted: function() { return /* binding */ onMounted; },
/* harmony export */   onRenderTracked: function() { return /* binding */ onRenderTracked; },
/* harmony export */   onRenderTriggered: function() { return /* binding */ onRenderTriggered; },
/* harmony export */   onScopeDispose: function() { return /* binding */ onScopeDispose; },
/* harmony export */   onServerPrefetch: function() { return /* binding */ onServerPrefetch; },
/* harmony export */   onUnmounted: function() { return /* binding */ onUnmounted; },
/* harmony export */   onUpdated: function() { return /* binding */ onUpdated; },
/* harmony export */   openBlock: function() { return /* binding */ openBlock; },
/* harmony export */   popScopeId: function() { return /* binding */ popScopeId; },
/* harmony export */   provide: function() { return /* binding */ provide; },
/* harmony export */   proxyRefs: function() { return /* binding */ proxyRefs; },
/* harmony export */   pushScopeId: function() { return /* binding */ pushScopeId; },
/* harmony export */   queuePostFlushCb: function() { return /* binding */ queuePostFlushCb; },
/* harmony export */   reactive: function() { return /* binding */ reactive; },
/* harmony export */   readonly: function() { return /* binding */ readonly; },
/* harmony export */   ref: function() { return /* binding */ ref; },
/* harmony export */   registerRuntimeCompiler: function() { return /* binding */ registerRuntimeCompiler; },
/* harmony export */   render: function() { return /* binding */ render; },
/* harmony export */   renderList: function() { return /* binding */ renderList; },
/* harmony export */   renderSlot: function() { return /* binding */ renderSlot; },
/* harmony export */   resolveComponent: function() { return /* binding */ resolveComponent; },
/* harmony export */   resolveDirective: function() { return /* binding */ resolveDirective; },
/* harmony export */   resolveDynamicComponent: function() { return /* binding */ resolveDynamicComponent; },
/* harmony export */   resolveFilter: function() { return /* binding */ resolveFilter; },
/* harmony export */   resolveTransitionHooks: function() { return /* binding */ resolveTransitionHooks; },
/* harmony export */   setBlockTracking: function() { return /* binding */ setBlockTracking; },
/* harmony export */   setDevtoolsHook: function() { return /* binding */ setDevtoolsHook; },
/* harmony export */   setTransitionHooks: function() { return /* binding */ setTransitionHooks; },
/* harmony export */   shallowReactive: function() { return /* binding */ shallowReactive; },
/* harmony export */   shallowReadonly: function() { return /* binding */ shallowReadonly; },
/* harmony export */   shallowRef: function() { return /* binding */ shallowRef; },
/* harmony export */   ssrContextKey: function() { return /* binding */ ssrContextKey; },
/* harmony export */   ssrUtils: function() { return /* binding */ ssrUtils; },
/* harmony export */   stop: function() { return /* binding */ stop; },
/* harmony export */   toDisplayString: function() { return /* binding */ toDisplayString; },
/* harmony export */   toHandlerKey: function() { return /* binding */ toHandlerKey; },
/* harmony export */   toHandlers: function() { return /* binding */ toHandlers; },
/* harmony export */   toRaw: function() { return /* binding */ toRaw; },
/* harmony export */   toRef: function() { return /* binding */ toRef; },
/* harmony export */   toRefs: function() { return /* binding */ toRefs; },
/* harmony export */   toValue: function() { return /* binding */ toValue; },
/* harmony export */   transformVNodeArgs: function() { return /* binding */ transformVNodeArgs; },
/* harmony export */   triggerRef: function() { return /* binding */ triggerRef; },
/* harmony export */   unref: function() { return /* binding */ unref; },
/* harmony export */   useAttrs: function() { return /* binding */ useAttrs; },
/* harmony export */   useCssModule: function() { return /* binding */ useCssModule; },
/* harmony export */   useCssVars: function() { return /* binding */ useCssVars; },
/* harmony export */   useModel: function() { return /* binding */ useModel; },
/* harmony export */   useSSRContext: function() { return /* binding */ useSSRContext; },
/* harmony export */   useSlots: function() { return /* binding */ useSlots; },
/* harmony export */   useTransitionState: function() { return /* binding */ useTransitionState; },
/* harmony export */   vModelCheckbox: function() { return /* binding */ vModelCheckbox; },
/* harmony export */   vModelDynamic: function() { return /* binding */ vModelDynamic; },
/* harmony export */   vModelRadio: function() { return /* binding */ vModelRadio; },
/* harmony export */   vModelSelect: function() { return /* binding */ vModelSelect; },
/* harmony export */   vModelText: function() { return /* binding */ vModelText; },
/* harmony export */   vShow: function() { return /* binding */ vShow; },
/* harmony export */   version: function() { return /* binding */ version; },
/* harmony export */   warn: function() { return /* binding */ warn; },
/* harmony export */   watch: function() { return /* binding */ watch; },
/* harmony export */   watchEffect: function() { return /* binding */ watchEffect; },
/* harmony export */   watchPostEffect: function() { return /* binding */ watchPostEffect; },
/* harmony export */   watchSyncEffect: function() { return /* binding */ watchSyncEffect; },
/* harmony export */   withAsyncContext: function() { return /* binding */ withAsyncContext; },
/* harmony export */   withCtx: function() { return /* binding */ withCtx; },
/* harmony export */   withDefaults: function() { return /* binding */ withDefaults; },
/* harmony export */   withDirectives: function() { return /* binding */ withDirectives; },
/* harmony export */   withKeys: function() { return /* binding */ withKeys; },
/* harmony export */   withMemo: function() { return /* binding */ withMemo; },
/* harmony export */   withModifiers: function() { return /* binding */ withModifiers; },
/* harmony export */   withScopeId: function() { return /* binding */ withScopeId; }
/* harmony export */ });
/**
* @vue/compat v3.4.21
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function makeMap(str, expectsLowerCase) {
  const set = new Set(str.split(","));
  return expectsLowerCase ? (val) => set.has(val.toLowerCase()) : (val) => set.has(val);
}

const EMPTY_OBJ =  false ? 0 : {};
const EMPTY_ARR =  false ? 0 : [];
const NOOP = () => {
};
const NO = () => false;
const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el) => {
  const i = arr.indexOf(el);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty$1 = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty$1.call(val, key);
const isArray = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isDate = (val) => toTypeString(val) === "[object Date]";
const isRegExp = (val) => toTypeString(val) === "[object RegExp]";
const isFunction = (val) => typeof val === "function";
const isString = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return (isObject(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const isBuiltInDirective = /* @__PURE__ */ makeMap(
  "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
);
const cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
const capitalize = cacheStringFunction((str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
const toHandlerKey = cacheStringFunction((str) => {
  const s = str ? `on${capitalize(str)}` : ``;
  return s;
});
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](arg);
  }
};
const def = (obj, key, value) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value
  });
};
const looseToNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
const toNumber = (val) => {
  const n = isString(val) ? Number(val) : NaN;
  return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : {});
};

const PatchFlagNames = {
  [1]: `TEXT`,
  [2]: `CLASS`,
  [4]: `STYLE`,
  [8]: `PROPS`,
  [16]: `FULL_PROPS`,
  [32]: `NEED_HYDRATION`,
  [64]: `STABLE_FRAGMENT`,
  [128]: `KEYED_FRAGMENT`,
  [256]: `UNKEYED_FRAGMENT`,
  [512]: `NEED_PATCH`,
  [1024]: `DYNAMIC_SLOTS`,
  [2048]: `DEV_ROOT_FRAGMENT`,
  [-1]: `HOISTED`,
  [-2]: `BAIL`
};

const slotFlagsText = {
  [1]: "STABLE",
  [2]: "DYNAMIC",
  [3]: "FORWARDED"
};

const GLOBALS_ALLOWED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error";
const isGloballyAllowed = /* @__PURE__ */ makeMap(GLOBALS_ALLOWED);

const range = 2;
function generateCodeFrame(source, start = 0, end = source.length) {
  let lines = source.split(/(\r?\n)/);
  const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);
  lines = lines.filter((_, idx) => idx % 2 === 0);
  let count = 0;
  const res = [];
  for (let i = 0; i < lines.length; i++) {
    count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);
    if (count >= start) {
      for (let j = i - range; j <= i + range || end > count; j++) {
        if (j < 0 || j >= lines.length)
          continue;
        const line = j + 1;
        res.push(
          `${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`
        );
        const lineLength = lines[j].length;
        const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;
        if (j === i) {
          const pad = start - (count - (lineLength + newLineSeqLength));
          const length = Math.max(
            1,
            end > count ? lineLength - pad : end - start
          );
          res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
        } else if (j > i) {
          if (end > count) {
            const length = Math.max(Math.min(end - count, lineLength), 1);
            res.push(`   |  ` + "^".repeat(length));
          }
          count += lineLength + newLineSeqLength;
        }
      }
      break;
    }
  }
  return res.join("\n");
}

function normalizeStyle(value) {
  if (isArray(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString(value) || isObject(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function stringifyStyle(styles) {
  let ret = "";
  if (!styles || isString(styles)) {
    return ret;
  }
  for (const key in styles) {
    const value = styles[key];
    const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
    if (isString(value) || typeof value === "number") {
      ret += `${normalizedKey}:${value};`;
    }
  }
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString(value)) {
    res = value;
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
function normalizeProps(props) {
  if (!props)
    return null;
  let { class: klass, style } = props;
  if (klass && !isString(klass)) {
    props.class = normalizeClass(klass);
  }
  if (style) {
    props.style = normalizeStyle(style);
  }
  return props;
}

const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
const MATH_TAGS = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics";
const VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
const isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
const isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
const isMathMLTag = /* @__PURE__ */ makeMap(MATH_TAGS);
const isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);

const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
const isBooleanAttr = /* @__PURE__ */ makeMap(
  specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`
);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
const isKnownHtmlAttr = /* @__PURE__ */ (/* unused pure expression or super */ null && (makeMap(
  `accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`
)));
const isKnownSvgAttr = /* @__PURE__ */ (/* unused pure expression or super */ null && (makeMap(
  `xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`
)));
function isRenderableAttrValue(value) {
  if (value == null) {
    return false;
  }
  const type = typeof value;
  return type === "string" || type === "number" || type === "boolean";
}

function looseCompareArrays(a, b) {
  if (a.length !== b.length)
    return false;
  let equal = true;
  for (let i = 0; equal && i < a.length; i++) {
    equal = looseEqual(a[i], b[i]);
  }
  return equal;
}
function looseEqual(a, b) {
  if (a === b)
    return true;
  let aValidType = isDate(a);
  let bValidType = isDate(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b.getTime() : false;
  }
  aValidType = isSymbol(a);
  bValidType = isSymbol(b);
  if (aValidType || bValidType) {
    return a === b;
  }
  aValidType = isArray(a);
  bValidType = isArray(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a, b) : false;
  }
  aValidType = isObject(a);
  bValidType = isObject(b);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a).length;
    const bKeysCount = Object.keys(b).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key in a) {
      const aHasKey = a.hasOwnProperty(key);
      const bHasKey = b.hasOwnProperty(key);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
        return false;
      }
    }
  }
  return String(a) === String(b);
}
function looseIndexOf(arr, val) {
  return arr.findIndex((item) => looseEqual(item, val));
}

const toDisplayString = (val) => {
  return isString(val) ? val : val == null ? "" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce(
        (entries, [key, val2], i) => {
          entries[stringifySymbol(key, i) + " =>"] = val2;
          return entries;
        },
        {}
      )
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
    };
  } else if (isSymbol(val)) {
    return stringifySymbol(val);
  } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
    return String(val);
  }
  return val;
};
const stringifySymbol = (v, i = "") => {
  var _a;
  return isSymbol(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v;
};

function warn$2(msg, ...args) {
  console.warn(`[Vue warn] ${msg}`, ...args);
}

let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    /**
     * @internal
     */
    this._active = true;
    /**
     * @internal
     */
    this.effects = [];
    /**
     * @internal
     */
    this.cleanups = [];
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  }
  get active() {
    return this._active;
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    } else if (false) {}
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    activeEffectScope = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this._active) {
      let i, l;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop();
      }
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
      this._active = false;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function recordEffectScope(effect, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect);
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  } else if (false) {}
}

let activeEffect;
class ReactiveEffect {
  constructor(fn, trigger, scheduler, scope) {
    this.fn = fn;
    this.trigger = trigger;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    /**
     * @internal
     */
    this._dirtyLevel = 4;
    /**
     * @internal
     */
    this._trackId = 0;
    /**
     * @internal
     */
    this._runnings = 0;
    /**
     * @internal
     */
    this._shouldSchedule = false;
    /**
     * @internal
     */
    this._depsLength = 0;
    recordEffectScope(this, scope);
  }
  get dirty() {
    if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
      this._dirtyLevel = 1;
      pauseTracking();
      for (let i = 0; i < this._depsLength; i++) {
        const dep = this.deps[i];
        if (dep.computed) {
          triggerComputed(dep.computed);
          if (this._dirtyLevel >= 4) {
            break;
          }
        }
      }
      if (this._dirtyLevel === 1) {
        this._dirtyLevel = 0;
      }
      resetTracking();
    }
    return this._dirtyLevel >= 4;
  }
  set dirty(v) {
    this._dirtyLevel = v ? 4 : 0;
  }
  run() {
    this._dirtyLevel = 0;
    if (!this.active) {
      return this.fn();
    }
    let lastShouldTrack = shouldTrack;
    let lastEffect = activeEffect;
    try {
      shouldTrack = true;
      activeEffect = this;
      this._runnings++;
      preCleanupEffect(this);
      return this.fn();
    } finally {
      postCleanupEffect(this);
      this._runnings--;
      activeEffect = lastEffect;
      shouldTrack = lastShouldTrack;
    }
  }
  stop() {
    var _a;
    if (this.active) {
      preCleanupEffect(this);
      postCleanupEffect(this);
      (_a = this.onStop) == null ? void 0 : _a.call(this);
      this.active = false;
    }
  }
}
function triggerComputed(computed) {
  return computed.value;
}
function preCleanupEffect(effect2) {
  effect2._trackId++;
  effect2._depsLength = 0;
}
function postCleanupEffect(effect2) {
  if (effect2.deps.length > effect2._depsLength) {
    for (let i = effect2._depsLength; i < effect2.deps.length; i++) {
      cleanupDepEffect(effect2.deps[i], effect2);
    }
    effect2.deps.length = effect2._depsLength;
  }
}
function cleanupDepEffect(dep, effect2) {
  const trackId = dep.get(effect2);
  if (trackId !== void 0 && effect2._trackId !== trackId) {
    dep.delete(effect2);
    if (dep.size === 0) {
      dep.cleanup();
    }
  }
}
function effect(fn, options) {
  if (fn.effect instanceof ReactiveEffect) {
    fn = fn.effect.fn;
  }
  const _effect = new ReactiveEffect(fn, NOOP, () => {
    if (_effect.dirty) {
      _effect.run();
    }
  });
  if (options) {
    extend(_effect, options);
    if (options.scope)
      recordEffectScope(_effect, options.scope);
  }
  if (!options || !options.lazy) {
    _effect.run();
  }
  const runner = _effect.run.bind(_effect);
  runner.effect = _effect;
  return runner;
}
function stop(runner) {
  runner.effect.stop();
}
let shouldTrack = true;
let pauseScheduleStack = 0;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function pauseScheduling() {
  pauseScheduleStack++;
}
function resetScheduling() {
  pauseScheduleStack--;
  while (!pauseScheduleStack && queueEffectSchedulers.length) {
    queueEffectSchedulers.shift()();
  }
}
function trackEffect(effect2, dep, debuggerEventExtraInfo) {
  var _a;
  if (dep.get(effect2) !== effect2._trackId) {
    dep.set(effect2, effect2._trackId);
    const oldDep = effect2.deps[effect2._depsLength];
    if (oldDep !== dep) {
      if (oldDep) {
        cleanupDepEffect(oldDep, effect2);
      }
      effect2.deps[effect2._depsLength++] = dep;
    } else {
      effect2._depsLength++;
    }
    if (false) {}
  }
}
const queueEffectSchedulers = [];
function triggerEffects(dep, dirtyLevel, debuggerEventExtraInfo) {
  var _a;
  pauseScheduling();
  for (const effect2 of dep.keys()) {
    let tracking;
    if (effect2._dirtyLevel < dirtyLevel && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
      effect2._shouldSchedule || (effect2._shouldSchedule = effect2._dirtyLevel === 0);
      effect2._dirtyLevel = dirtyLevel;
    }
    if (effect2._shouldSchedule && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
      if (false) {}
      effect2.trigger();
      if ((!effect2._runnings || effect2.allowRecurse) && effect2._dirtyLevel !== 2) {
        effect2._shouldSchedule = false;
        if (effect2.scheduler) {
          queueEffectSchedulers.push(effect2.scheduler);
        }
      }
    }
  }
  resetScheduling();
}

const createDep = (cleanup, computed) => {
  const dep = /* @__PURE__ */ new Map();
  dep.cleanup = cleanup;
  dep.computed = computed;
  return dep;
};

const targetMap = /* @__PURE__ */ new WeakMap();
const ITERATE_KEY = Symbol( false ? 0 : "");
const MAP_KEY_ITERATE_KEY = Symbol( false ? 0 : "");
function track(target, type, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep(() => depsMap.delete(key)));
    }
    trackEffect(
      activeEffect,
      dep,
       false ? 0 : void 0
    );
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray(target)) {
    const newLength = Number(newValue);
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || !isSymbol(key2) && key2 >= newLength) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  pauseScheduling();
  for (const dep of deps) {
    if (dep) {
      triggerEffects(
        dep,
        4,
         false ? 0 : void 0
      );
    }
  }
  resetScheduling();
}
function getDepFromReactive(object, key) {
  var _a;
  return (_a = targetMap.get(object)) == null ? void 0 : _a.get(key);
}

const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i = 0, l = this.length; i < l; i++) {
        track(arr, "get", i + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      pauseScheduling();
      const res = toRaw(this)[key].apply(this, args);
      resetScheduling();
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function hasOwnProperty(key) {
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
class BaseReactiveHandler {
  constructor(_isReadonly = false, _isShallow = false) {
    this._isReadonly = _isReadonly;
    this._isShallow = _isShallow;
  }
  get(target, key, receiver) {
    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return isShallow2;
    } else if (key === "__v_raw") {
      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
      // this means the reciever is a user proxy of the reactive proxy
      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
        return target;
      }
      return;
    }
    const targetIsArray = isArray(target);
    if (!isReadonly2) {
      if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty;
      }
    }
    const res = Reflect.get(target, key, receiver);
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (isShallow2) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  }
}
class MutableReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(false, isShallow2);
  }
  set(target, key, value, receiver) {
    let oldValue = target[key];
    if (!this._isShallow) {
      const isOldValueReadonly = isReadonly(oldValue);
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
        if (isOldValueReadonly) {
          return false;
        } else {
          oldValue.value = value;
          return true;
        }
      }
    }
    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(target, key, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value, oldValue);
      }
    }
    return result;
  }
  deleteProperty(target, key) {
    const hadKey = hasOwn(target, key);
    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
    }
    return result;
  }
  has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  ownKeys(target) {
    track(
      target,
      "iterate",
      isArray(target) ? "length" : ITERATE_KEY
    );
    return Reflect.ownKeys(target);
  }
}
class ReadonlyReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(true, isShallow2);
  }
  set(target, key) {
    if (false) {}
    return true;
  }
  deleteProperty(target, key) {
    if (false) {}
    return true;
  }
}
const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(
  true
);
const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);

const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);
function get(target, key, isReadonly = false, isShallow = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly) {
    if (hasChanged(key, rawKey)) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has2 } = getProto(rawTarget);
  const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has(key, isReadonly = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly) {
    if (hasChanged(key, rawKey)) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly = false) {
  target = target["__v_raw"];
  !isReadonly && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set(key, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  } else if (false) {}
  const oldValue = get2.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger(target, "add", key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target, "set", key, value, oldValue);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  } else if (false) {}
  const oldValue = get2 ? get2.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0, oldValue);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const oldTarget =  false ? 0 : void 0;
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0, oldTarget);
  }
  return result;
}
function createForEach(isReadonly, isShallow) {
  return function forEach(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    !isReadonly && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly, isShallow) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    !isReadonly && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      // iterator protocol
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    if (false) {}
    return type === "delete" ? false : type === "clear" ? void 0 : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get(this, key);
    },
    get size() {
      return size(this);
    },
    has,
    add,
    set,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has,
    add,
    set,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(
      method,
      false,
      false
    );
    readonlyInstrumentations2[method] = createIterableMethod(
      method,
      true,
      false
    );
    shallowInstrumentations2[method] = createIterableMethod(
      method,
      false,
      true
    );
    shallowReadonlyInstrumentations2[method] = createIterableMethod(
      method,
      true,
      true
    );
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [
  mutableInstrumentations,
  readonlyInstrumentations,
  shallowInstrumentations,
  shallowReadonlyInstrumentations
] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly, shallow) {
  const instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly;
    } else if (key === "__v_isReadonly") {
      return isReadonly;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
      hasOwn(instrumentations, key) && key in target ? instrumentations : target,
      key,
      receiver
    );
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
function checkIdentityKeys(target, has2, key) {
  const rawKey = toRaw(key);
  if (rawKey !== key && has2.call(target, rawKey)) {
    const type = toRawType(target);
    warn$2(
      `Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
    );
  }
}

const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1 /* COMMON */;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2 /* COLLECTION */;
    default:
      return 0 /* INVALID */;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 /* INVALID */ : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
function shallowReactive(target) {
  return createReactiveObject(
    target,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  );
}
function readonly(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
function shallowReadonly(target) {
  return createReactiveObject(
    target,
    true,
    shallowReadonlyHandlers,
    shallowReadonlyCollectionHandlers,
    shallowReadonlyMap
  );
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject(target)) {
    if (false) {}
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0 /* INVALID */) {
    return target;
  }
  const proxy = new Proxy(
    target,
    targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  if (Object.isExtensible(value)) {
    def(value, "__v_skip", true);
  }
  return value;
}
const toReactive = (value) => isObject(value) ? reactive(value) : value;
const toReadonly = (value) => isObject(value) ? readonly(value) : value;

const COMPUTED_SIDE_EFFECT_WARN = (/* unused pure expression or super */ null && (`Computed is still dirty after getter evaluation, likely because a computed is mutating its own dependency in its getter. State mutations in computed getters should be avoided.  Check the docs for more details: https://vuejs.org/guide/essentials/computed.html#getters-should-be-side-effect-free`));
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly, isSSR) {
    this.getter = getter;
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this["__v_isReadonly"] = false;
    this.effect = new ReactiveEffect(
      () => getter(this._value),
      () => triggerRefValue(
        this,
        this.effect._dirtyLevel === 2 ? 2 : 3
      )
    );
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this["__v_isReadonly"] = isReadonly;
  }
  get value() {
    const self = toRaw(this);
    if ((!self._cacheable || self.effect.dirty) && hasChanged(self._value, self._value = self.effect.run())) {
      triggerRefValue(self, 4);
    }
    trackRefValue(self);
    if (self.effect._dirtyLevel >= 2) {
      if (false) {}
      triggerRefValue(self, 2);
    }
    return self._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
  // #region polyfill _dirty for backward compatibility third party code for Vue <= 3.3.x
  get _dirty() {
    return this.effect.dirty;
  }
  set _dirty(v) {
    this.effect.dirty = v;
  }
  // #endregion
}
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter =  false ? 0 : NOOP;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  if (false) {}
  return cRef;
}

function trackRefValue(ref2) {
  var _a;
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    trackEffect(
      activeEffect,
      (_a = ref2.dep) != null ? _a : ref2.dep = createDep(
        () => ref2.dep = void 0,
        ref2 instanceof ComputedRefImpl ? ref2 : void 0
      ),
       false ? 0 : void 0
    );
  }
}
function triggerRefValue(ref2, dirtyLevel = 4, newVal) {
  ref2 = toRaw(ref2);
  const dep = ref2.dep;
  if (dep) {
    triggerEffects(
      dep,
      dirtyLevel,
       false ? 0 : void 0
    );
  }
}
function isRef(r) {
  return !!(r && r.__v_isRef === true);
}
function ref(value) {
  return createRef(value, false);
}
function shallowRef(value) {
  return createRef(value, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, __v_isShallow) {
    this.__v_isShallow = __v_isShallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = __v_isShallow ? value : toRaw(value);
    this._value = __v_isShallow ? value : toReactive(value);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
    newVal = useDirectValue ? newVal : toRaw(newVal);
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal;
      this._value = useDirectValue ? newVal : toReactive(newVal);
      triggerRefValue(this, 4, newVal);
    }
  }
}
function triggerRef(ref2) {
  triggerRefValue(ref2, 4,  false ? 0 : void 0);
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
function toValue(source) {
  return isFunction(source) ? source() : unref(source);
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class CustomRefImpl {
  constructor(factory) {
    this.dep = void 0;
    this.__v_isRef = true;
    const { get, set } = factory(
      () => trackRefValue(this),
      () => triggerRefValue(this)
    );
    this._get = get;
    this._set = set;
  }
  get value() {
    return this._get();
  }
  set value(newVal) {
    this._set(newVal);
  }
}
function customRef(factory) {
  return new CustomRefImpl(factory);
}
function toRefs(object) {
  if (false) {}
  const ret = isArray(object) ? new Array(object.length) : {};
  for (const key in object) {
    ret[key] = propertyToRef(object, key);
  }
  return ret;
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this.__v_isRef = true;
  }
  get value() {
    const val = this._object[this._key];
    return val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
  get dep() {
    return getDepFromReactive(toRaw(this._object), this._key);
  }
}
class GetterRefImpl {
  constructor(_getter) {
    this._getter = _getter;
    this.__v_isRef = true;
    this.__v_isReadonly = true;
  }
  get value() {
    return this._getter();
  }
}
function toRef(source, key, defaultValue) {
  if (isRef(source)) {
    return source;
  } else if (isFunction(source)) {
    return new GetterRefImpl(source);
  } else if (isObject(source) && arguments.length > 1) {
    return propertyToRef(source, key, defaultValue);
  } else {
    return ref(source);
  }
}
function propertyToRef(source, key, defaultValue) {
  const val = source[key];
  return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
}

const TrackOpTypes = {
  "GET": "get",
  "HAS": "has",
  "ITERATE": "iterate"
};
const TriggerOpTypes = {
  "SET": "set",
  "ADD": "add",
  "DELETE": "delete",
  "CLEAR": "clear"
};

const stack$1 = [];
function pushWarningContext(vnode) {
  stack$1.push(vnode);
}
function popWarningContext() {
  stack$1.pop();
}
function warn$1(msg, ...args) {
  pauseTracking();
  const instance = stack$1.length ? stack$1[stack$1.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(
      appWarnHandler,
      instance,
      11,
      [
        msg + args.map((a) => {
          var _a, _b;
          return (_b = (_a = a.toString) == null ? void 0 : _a.call(a)) != null ? _b : JSON.stringify(a);
        }).join(""),
        instance && instance.proxy,
        trace.map(
          ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
        ).join("\n"),
        trace
      ]
    );
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length && // avoid spamming console during tests
    true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  resetTracking();
}
function getComponentTrace() {
  let currentVNode = stack$1[stack$1.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last = normalizedStack[0];
    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i) => {
    logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open = ` at <${formatComponentName(
    vnode.component,
    vnode.type,
    isRoot
  )}`;
  const close = `>` + postfix;
  return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
}
function formatProps(props) {
  const res = [];
  const keys = Object.keys(props);
  keys.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props[key]));
  });
  if (keys.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value, raw) {
  if (isString(value)) {
    value = JSON.stringify(value);
    return raw ? value : [`${key}=${value}`];
  } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
    return raw ? value : [`${key}=${value}`];
  } else if (isRef(value)) {
    value = formatProp(key, toRaw(value.value), true);
    return raw ? value : [`${key}=Ref<`, value, `>`];
  } else if (isFunction(value)) {
    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
  } else {
    value = toRaw(value);
    return raw ? value : [`${key}=`, value];
  }
}
function assertNumber(val, type) {
  if (true)
    return;
  if (val === void 0) {
    return;
  } else if (typeof val !== "number") {
    warn$1(`${type} is not a valid number - got ${JSON.stringify(val)}.`);
  } else if (isNaN(val)) {
    warn$1(`${type} is NaN - the duration expression might be incorrect.`);
  }
}

const ErrorCodes = {
  "SETUP_FUNCTION": 0,
  "0": "SETUP_FUNCTION",
  "RENDER_FUNCTION": 1,
  "1": "RENDER_FUNCTION",
  "WATCH_GETTER": 2,
  "2": "WATCH_GETTER",
  "WATCH_CALLBACK": 3,
  "3": "WATCH_CALLBACK",
  "WATCH_CLEANUP": 4,
  "4": "WATCH_CLEANUP",
  "NATIVE_EVENT_HANDLER": 5,
  "5": "NATIVE_EVENT_HANDLER",
  "COMPONENT_EVENT_HANDLER": 6,
  "6": "COMPONENT_EVENT_HANDLER",
  "VNODE_HOOK": 7,
  "7": "VNODE_HOOK",
  "DIRECTIVE_HOOK": 8,
  "8": "DIRECTIVE_HOOK",
  "TRANSITION_HOOK": 9,
  "9": "TRANSITION_HOOK",
  "APP_ERROR_HANDLER": 10,
  "10": "APP_ERROR_HANDLER",
  "APP_WARN_HANDLER": 11,
  "11": "APP_WARN_HANDLER",
  "FUNCTION_REF": 12,
  "12": "FUNCTION_REF",
  "ASYNC_COMPONENT_LOADER": 13,
  "13": "ASYNC_COMPONENT_LOADER",
  "SCHEDULER": 14,
  "14": "SCHEDULER"
};
const ErrorTypeStrings$1 = {
  ["sp"]: "serverPrefetch hook",
  ["bc"]: "beforeCreate hook",
  ["c"]: "created hook",
  ["bm"]: "beforeMount hook",
  ["m"]: "mounted hook",
  ["bu"]: "beforeUpdate hook",
  ["u"]: "updated",
  ["bum"]: "beforeUnmount hook",
  ["um"]: "unmounted hook",
  ["a"]: "activated hook",
  ["da"]: "deactivated hook",
  ["ec"]: "errorCaptured hook",
  ["rtc"]: "renderTracked hook",
  ["rtg"]: "renderTriggered hook",
  [0]: "setup function",
  [1]: "render function",
  [2]: "watcher getter",
  [3]: "watcher callback",
  [4]: "watcher cleanup function",
  [5]: "native event handler",
  [6]: "component event handler",
  [7]: "vnode hook",
  [8]: "directive hook",
  [9]: "transition hook",
  [10]: "app errorHandler",
  [11]: "app warnHandler",
  [12]: "ref function",
  [13]: "async component loader",
  [14]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://github.com/vuejs/core ."
};
function callWithErrorHandling(fn, instance, type, args) {
  try {
    return args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  const values = [];
  for (let i = 0; i < fn.length; i++) {
    values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
  }
  return values;
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo =  false ? 0 : `https://vuejs.org/error-reference/#runtime-${type}`;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling(
        appErrorHandler,
        null,
        10,
        [err, exposedInstance, errorInfo]
      );
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
  if (false) {} else {
    console.error(err);
  }
}

let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
const RECURSION_LIMIT = 100;
function nextTick(fn) {
  const p = currentFlushPromise || resolvedPromise;
  return fn ? p.then(this ? fn.bind(this) : fn) : p;
}
function findInsertionIndex(id) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJob = queue[middle];
    const middleJobId = getId(middleJob);
    if (middleJobId < id || middleJobId === id && middleJob.pre) {
      start = middle + 1;
    } else {
      end = middle;
    }
  }
  return start;
}
function queueJob(job) {
  if (!queue.length || !queue.includes(
    job,
    isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
  )) {
    if (job.id == null) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function invalidateJob(job) {
  const i = queue.indexOf(job);
  if (i > flushIndex) {
    queue.splice(i, 1);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray(cb)) {
    if (!activePostFlushCbs || !activePostFlushCbs.includes(
      cb,
      cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
    )) {
      pendingPostFlushCbs.push(cb);
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(instance, seen, i = isFlushing ? flushIndex + 1 : 0) {
  if (false) {}
  for (; i < queue.length; i++) {
    const cb = queue[i];
    if (cb && cb.pre) {
      if (instance && cb.id !== instance.uid) {
        continue;
      }
      if (false) {}
      queue.splice(i, 1);
      i--;
      cb();
    }
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)].sort(
      (a, b) => getId(a) - getId(b)
    );
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    if (false) {}
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      if (false) {}
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? Infinity : job.id;
const comparator = (a, b) => {
  const diff = getId(a) - getId(b);
  if (diff === 0) {
    if (a.pre && !b.pre)
      return -1;
    if (b.pre && !a.pre)
      return 1;
  }
  return diff;
};
function flushJobs(seen) {
  isFlushPending = false;
  isFlushing = true;
  if (false) {}
  queue.sort(comparator);
  const check =  false ? 0 : NOOP;
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && job.active !== false) {
        if (false) {}
        callWithErrorHandling(job, null, 14);
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs(seen);
    isFlushing = false;
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs(seen);
    }
  }
}
function checkRecursiveUpdates(seen, fn) {
  if (!seen.has(fn)) {
    seen.set(fn, 1);
  } else {
    const count = seen.get(fn);
    if (count > RECURSION_LIMIT) {
      const instance = fn.ownerInstance;
      const componentName = instance && getComponentName(instance.type);
      handleError(
        `Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,
        null,
        10
      );
      return true;
    } else {
      seen.set(fn, count + 1);
    }
  }
}

let isHmrUpdating = false;
const hmrDirtyComponents = /* @__PURE__ */ new Set();
if (false) {}
const map = /* @__PURE__ */ new Map();
function registerHMR(instance) {
  const id = instance.type.__hmrId;
  let record = map.get(id);
  if (!record) {
    createRecord(id, instance.type);
    record = map.get(id);
  }
  record.instances.add(instance);
}
function unregisterHMR(instance) {
  map.get(instance.type.__hmrId).instances.delete(instance);
}
function createRecord(id, initialDef) {
  if (map.has(id)) {
    return false;
  }
  map.set(id, {
    initialDef: normalizeClassComponent(initialDef),
    instances: /* @__PURE__ */ new Set()
  });
  return true;
}
function normalizeClassComponent(component) {
  return isClassComponent(component) ? component.__vccOpts : component;
}
function rerender(id, newRender) {
  const record = map.get(id);
  if (!record) {
    return;
  }
  record.initialDef.render = newRender;
  [...record.instances].forEach((instance) => {
    if (newRender) {
      instance.render = newRender;
      normalizeClassComponent(instance.type).render = newRender;
    }
    instance.renderCache = [];
    isHmrUpdating = true;
    instance.effect.dirty = true;
    instance.update();
    isHmrUpdating = false;
  });
}
function reload(id, newComp) {
  const record = map.get(id);
  if (!record)
    return;
  newComp = normalizeClassComponent(newComp);
  updateComponentDef(record.initialDef, newComp);
  const instances = [...record.instances];
  for (const instance of instances) {
    const oldComp = normalizeClassComponent(instance.type);
    if (!hmrDirtyComponents.has(oldComp)) {
      if (oldComp !== record.initialDef) {
        updateComponentDef(oldComp, newComp);
      }
      hmrDirtyComponents.add(oldComp);
    }
    instance.appContext.propsCache.delete(instance.type);
    instance.appContext.emitsCache.delete(instance.type);
    instance.appContext.optionsCache.delete(instance.type);
    if (instance.ceReload) {
      hmrDirtyComponents.add(oldComp);
      instance.ceReload(newComp.styles);
      hmrDirtyComponents.delete(oldComp);
    } else if (instance.parent) {
      instance.parent.effect.dirty = true;
      queueJob(instance.parent.update);
    } else if (instance.appContext.reload) {
      instance.appContext.reload();
    } else if (typeof window !== "undefined") {
      window.location.reload();
    } else {
      console.warn(
        "[HMR] Root or manually mounted instance modified. Full reload required."
      );
    }
  }
  queuePostFlushCb(() => {
    for (const instance of instances) {
      hmrDirtyComponents.delete(
        normalizeClassComponent(instance.type)
      );
    }
  });
}
function updateComponentDef(oldComp, newComp) {
  extend(oldComp, newComp);
  for (const key in oldComp) {
    if (key !== "__file" && !(key in newComp)) {
      delete oldComp[key];
    }
  }
}
function tryWrap(fn) {
  return (id, arg) => {
    try {
      return fn(id, arg);
    } catch (e) {
      console.error(e);
      console.warn(
        `[HMR] Something went wrong during Vue component hot-reload. Full reload required.`
      );
    }
  };
}

let devtools$1;
let buffer = [];
let devtoolsNotInstalled = false;
function emit$2(event, ...args) {
  if (devtools$1) {
    devtools$1.emit(event, ...args);
  } else if (!devtoolsNotInstalled) {
    buffer.push({ event, args });
  }
}
function setDevtoolsHook$1(hook, target) {
  var _a, _b;
  devtools$1 = hook;
  if (devtools$1) {
    devtools$1.enabled = true;
    buffer.forEach(({ event, args }) => devtools$1.emit(event, ...args));
    buffer = [];
  } else if (
    // handle late devtools injection - only do this if we are in an actual
    // browser environment to avoid the timer handle stalling test runner exit
    // (#4815)
    typeof window !== "undefined" && // some envs mock window but not fully
    window.HTMLElement && // also exclude jsdom
    !((_b = (_a = window.navigator) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.includes("jsdom"))
  ) {
    const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
    replay.push((newHook) => {
      setDevtoolsHook$1(newHook, target);
    });
    setTimeout(() => {
      if (!devtools$1) {
        target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
        devtoolsNotInstalled = true;
        buffer = [];
      }
    }, 3e3);
  } else {
    devtoolsNotInstalled = true;
    buffer = [];
  }
}
function devtoolsInitApp(app, version) {
  emit$2("app:init" /* APP_INIT */, app, version, {
    Fragment,
    Text,
    Comment,
    Static
  });
}
function devtoolsUnmountApp(app) {
  emit$2("app:unmount" /* APP_UNMOUNT */, app);
}
const devtoolsComponentAdded = /* @__PURE__ */ createDevtoolsComponentHook(
  "component:added" /* COMPONENT_ADDED */
);
const devtoolsComponentUpdated = /* @__PURE__ */ createDevtoolsComponentHook("component:updated" /* COMPONENT_UPDATED */);
const _devtoolsComponentRemoved = /* @__PURE__ */ createDevtoolsComponentHook(
  "component:removed" /* COMPONENT_REMOVED */
);
const devtoolsComponentRemoved = (component) => {
  if (devtools$1 && typeof devtools$1.cleanupBuffer === "function" && // remove the component if it wasn't buffered
  !devtools$1.cleanupBuffer(component)) {
    _devtoolsComponentRemoved(component);
  }
};
function createDevtoolsComponentHook(hook) {
  return (component) => {
    emit$2(
      hook,
      component.appContext.app,
      component.uid,
      component.parent ? component.parent.uid : void 0,
      component
    );
  };
}
const devtoolsPerfStart = /* @__PURE__ */ (/* unused pure expression or super */ null && (createDevtoolsPerformanceHook(
  "perf:start" /* PERFORMANCE_START */
)));
const devtoolsPerfEnd = /* @__PURE__ */ (/* unused pure expression or super */ null && (createDevtoolsPerformanceHook(
  "perf:end" /* PERFORMANCE_END */
)));
function createDevtoolsPerformanceHook(hook) {
  return (component, type, time) => {
    emit$2(hook, component.appContext.app, component.uid, component, type, time);
  };
}
function devtoolsComponentEmit(component, event, params) {
  emit$2(
    "component:emit" /* COMPONENT_EMIT */,
    component.appContext.app,
    component,
    event,
    params
  );
}

const DeprecationTypes$1 = {
  "GLOBAL_MOUNT": "GLOBAL_MOUNT",
  "GLOBAL_MOUNT_CONTAINER": "GLOBAL_MOUNT_CONTAINER",
  "GLOBAL_EXTEND": "GLOBAL_EXTEND",
  "GLOBAL_PROTOTYPE": "GLOBAL_PROTOTYPE",
  "GLOBAL_SET": "GLOBAL_SET",
  "GLOBAL_DELETE": "GLOBAL_DELETE",
  "GLOBAL_OBSERVABLE": "GLOBAL_OBSERVABLE",
  "GLOBAL_PRIVATE_UTIL": "GLOBAL_PRIVATE_UTIL",
  "CONFIG_SILENT": "CONFIG_SILENT",
  "CONFIG_DEVTOOLS": "CONFIG_DEVTOOLS",
  "CONFIG_KEY_CODES": "CONFIG_KEY_CODES",
  "CONFIG_PRODUCTION_TIP": "CONFIG_PRODUCTION_TIP",
  "CONFIG_IGNORED_ELEMENTS": "CONFIG_IGNORED_ELEMENTS",
  "CONFIG_WHITESPACE": "CONFIG_WHITESPACE",
  "CONFIG_OPTION_MERGE_STRATS": "CONFIG_OPTION_MERGE_STRATS",
  "INSTANCE_SET": "INSTANCE_SET",
  "INSTANCE_DELETE": "INSTANCE_DELETE",
  "INSTANCE_DESTROY": "INSTANCE_DESTROY",
  "INSTANCE_EVENT_EMITTER": "INSTANCE_EVENT_EMITTER",
  "INSTANCE_EVENT_HOOKS": "INSTANCE_EVENT_HOOKS",
  "INSTANCE_CHILDREN": "INSTANCE_CHILDREN",
  "INSTANCE_LISTENERS": "INSTANCE_LISTENERS",
  "INSTANCE_SCOPED_SLOTS": "INSTANCE_SCOPED_SLOTS",
  "INSTANCE_ATTRS_CLASS_STYLE": "INSTANCE_ATTRS_CLASS_STYLE",
  "OPTIONS_DATA_FN": "OPTIONS_DATA_FN",
  "OPTIONS_DATA_MERGE": "OPTIONS_DATA_MERGE",
  "OPTIONS_BEFORE_DESTROY": "OPTIONS_BEFORE_DESTROY",
  "OPTIONS_DESTROYED": "OPTIONS_DESTROYED",
  "WATCH_ARRAY": "WATCH_ARRAY",
  "PROPS_DEFAULT_THIS": "PROPS_DEFAULT_THIS",
  "V_ON_KEYCODE_MODIFIER": "V_ON_KEYCODE_MODIFIER",
  "CUSTOM_DIR": "CUSTOM_DIR",
  "ATTR_FALSE_VALUE": "ATTR_FALSE_VALUE",
  "ATTR_ENUMERATED_COERCION": "ATTR_ENUMERATED_COERCION",
  "TRANSITION_CLASSES": "TRANSITION_CLASSES",
  "TRANSITION_GROUP_ROOT": "TRANSITION_GROUP_ROOT",
  "COMPONENT_ASYNC": "COMPONENT_ASYNC",
  "COMPONENT_FUNCTIONAL": "COMPONENT_FUNCTIONAL",
  "COMPONENT_V_MODEL": "COMPONENT_V_MODEL",
  "RENDER_FUNCTION": "RENDER_FUNCTION",
  "FILTERS": "FILTERS",
  "PRIVATE_APIS": "PRIVATE_APIS"
};
const deprecationData$1 = {
  ["GLOBAL_MOUNT"]: {
    message: `The global app bootstrapping API has changed: vm.$mount() and the "el" option have been removed. Use createApp(RootComponent).mount() instead.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/global-api.html#mounting-app-instance`
  },
  ["GLOBAL_MOUNT_CONTAINER"]: {
    message: `Vue detected directives on the mount container. In Vue 3, the container is no longer considered part of the template and will not be processed/replaced.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/mount-changes.html`
  },
  ["GLOBAL_EXTEND"]: {
    message: `Vue.extend() has been removed in Vue 3. Use defineComponent() instead.`,
    link: `https://vuejs.org/api/general.html#definecomponent`
  },
  ["GLOBAL_PROTOTYPE"]: {
    message: `Vue.prototype is no longer available in Vue 3. Use app.config.globalProperties instead.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/global-api.html#vue-prototype-replaced-by-config-globalproperties`
  },
  ["GLOBAL_SET"]: {
    message: `Vue.set() has been removed as it is no longer needed in Vue 3. Simply use native JavaScript mutations.`
  },
  ["GLOBAL_DELETE"]: {
    message: `Vue.delete() has been removed as it is no longer needed in Vue 3. Simply use native JavaScript mutations.`
  },
  ["GLOBAL_OBSERVABLE"]: {
    message: `Vue.observable() has been removed. Use \`import { reactive } from "vue"\` from Composition API instead.`,
    link: `https://vuejs.org/api/reactivity-core.html#reactive`
  },
  ["GLOBAL_PRIVATE_UTIL"]: {
    message: `Vue.util has been removed. Please refactor to avoid its usage since it was an internal API even in Vue 2.`
  },
  ["CONFIG_SILENT"]: {
    message: `config.silent has been removed because it is not good practice to intentionally suppress warnings. You can use your browser console's filter features to focus on relevant messages.`
  },
  ["CONFIG_DEVTOOLS"]: {
    message: `config.devtools has been removed. To enable devtools for production, configure the __VUE_PROD_DEVTOOLS__ compile-time flag.`,
    link: `https://github.com/vuejs/core/tree/main/packages/vue#bundler-build-feature-flags`
  },
  ["CONFIG_KEY_CODES"]: {
    message: `config.keyCodes has been removed. In Vue 3, you can directly use the kebab-case key names as v-on modifiers.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/keycode-modifiers.html`
  },
  ["CONFIG_PRODUCTION_TIP"]: {
    message: `config.productionTip has been removed.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/global-api.html#config-productiontip-removed`
  },
  ["CONFIG_IGNORED_ELEMENTS"]: {
    message: () => {
      let msg = `config.ignoredElements has been removed.`;
      if (isRuntimeOnly()) {
        msg += ` Pass the "isCustomElement" option to @vue/compiler-dom instead.`;
      } else {
        msg += ` Use config.isCustomElement instead.`;
      }
      return msg;
    },
    link: `https://v3-migration.vuejs.org/breaking-changes/global-api.html#config-ignoredelements-is-now-config-iscustomelement`
  },
  ["CONFIG_WHITESPACE"]: {
    // this warning is only relevant in the full build when using runtime
    // compilation, so it's put in the runtime compatConfig list.
    message: `Vue 3 compiler's whitespace option will default to "condense" instead of "preserve". To suppress this warning, provide an explicit value for \`config.compilerOptions.whitespace\`.`
  },
  ["CONFIG_OPTION_MERGE_STRATS"]: {
    message: `config.optionMergeStrategies no longer exposes internal strategies. Use custom merge functions instead.`
  },
  ["INSTANCE_SET"]: {
    message: `vm.$set() has been removed as it is no longer needed in Vue 3. Simply use native JavaScript mutations.`
  },
  ["INSTANCE_DELETE"]: {
    message: `vm.$delete() has been removed as it is no longer needed in Vue 3. Simply use native JavaScript mutations.`
  },
  ["INSTANCE_DESTROY"]: {
    message: `vm.$destroy() has been removed. Use app.unmount() instead.`,
    link: `https://vuejs.org/api/application.html#app-unmount`
  },
  ["INSTANCE_EVENT_EMITTER"]: {
    message: `vm.$on/$once/$off() have been removed. Use an external event emitter library instead.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/events-api.html`
  },
  ["INSTANCE_EVENT_HOOKS"]: {
    message: (event) => `"${event}" lifecycle events are no longer supported. From templates, use the "vue:" prefix instead of "hook:". For example, @${event} should be changed to @vue:${event.slice(5)}. From JavaScript, use Composition API to dynamically register lifecycle hooks.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/vnode-lifecycle-events.html`
  },
  ["INSTANCE_CHILDREN"]: {
    message: `vm.$children has been removed. Consider refactoring your logic to avoid relying on direct access to child components.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/children.html`
  },
  ["INSTANCE_LISTENERS"]: {
    message: `vm.$listeners has been removed. In Vue 3, parent v-on listeners are included in vm.$attrs and it is no longer necessary to separately use v-on="$listeners" if you are already using v-bind="$attrs". (Note: the Vue 3 behavior only applies if this compat config is disabled)`,
    link: `https://v3-migration.vuejs.org/breaking-changes/listeners-removed.html`
  },
  ["INSTANCE_SCOPED_SLOTS"]: {
    message: `vm.$scopedSlots has been removed. Use vm.$slots instead.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/slots-unification.html`
  },
  ["INSTANCE_ATTRS_CLASS_STYLE"]: {
    message: (componentName) => `Component <${componentName || "Anonymous"}> has \`inheritAttrs: false\` but is relying on class/style fallthrough from parent. In Vue 3, class/style are now included in $attrs and will no longer fallthrough when inheritAttrs is false. If you are already using v-bind="$attrs" on component root it should render the same end result. If you are binding $attrs to a non-root element and expecting class/style to fallthrough on root, you will need to now manually bind them on root via :class="$attrs.class".`,
    link: `https://v3-migration.vuejs.org/breaking-changes/attrs-includes-class-style.html`
  },
  ["OPTIONS_DATA_FN"]: {
    message: `The "data" option can no longer be a plain object. Always use a function.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/data-option.html`
  },
  ["OPTIONS_DATA_MERGE"]: {
    message: (key) => `Detected conflicting key "${key}" when merging data option values. In Vue 3, data keys are merged shallowly and will override one another.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/data-option.html#mixin-merge-behavior-change`
  },
  ["OPTIONS_BEFORE_DESTROY"]: {
    message: `\`beforeDestroy\` has been renamed to \`beforeUnmount\`.`
  },
  ["OPTIONS_DESTROYED"]: {
    message: `\`destroyed\` has been renamed to \`unmounted\`.`
  },
  ["WATCH_ARRAY"]: {
    message: `"watch" option or vm.$watch on an array value will no longer trigger on array mutation unless the "deep" option is specified. If current usage is intended, you can disable the compat behavior and suppress this warning with:

  configureCompat({ ${"WATCH_ARRAY"}: false })
`,
    link: `https://v3-migration.vuejs.org/breaking-changes/watch.html`
  },
  ["PROPS_DEFAULT_THIS"]: {
    message: (key) => `props default value function no longer has access to "this". The compat build only offers access to this.$options.(found in prop "${key}")`,
    link: `https://v3-migration.vuejs.org/breaking-changes/props-default-this.html`
  },
  ["CUSTOM_DIR"]: {
    message: (legacyHook, newHook) => `Custom directive hook "${legacyHook}" has been removed. Use "${newHook}" instead.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/custom-directives.html`
  },
  ["V_ON_KEYCODE_MODIFIER"]: {
    message: `Using keyCode as v-on modifier is no longer supported. Use kebab-case key name modifiers instead.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/keycode-modifiers.html`
  },
  ["ATTR_FALSE_VALUE"]: {
    message: (name) => `Attribute "${name}" with v-bind value \`false\` will render ${name}="false" instead of removing it in Vue 3. To remove the attribute, use \`null\` or \`undefined\` instead. If the usage is intended, you can disable the compat behavior and suppress this warning with:

  configureCompat({ ${"ATTR_FALSE_VALUE"}: false })
`,
    link: `https://v3-migration.vuejs.org/breaking-changes/attribute-coercion.html`
  },
  ["ATTR_ENUMERATED_COERCION"]: {
    message: (name, value, coerced) => `Enumerated attribute "${name}" with v-bind value \`${value}\` will ${value === null ? `be removed` : `render the value as-is`} instead of coercing the value to "${coerced}" in Vue 3. Always use explicit "true" or "false" values for enumerated attributes. If the usage is intended, you can disable the compat behavior and suppress this warning with:

  configureCompat({ ${"ATTR_ENUMERATED_COERCION"}: false })
`,
    link: `https://v3-migration.vuejs.org/breaking-changes/attribute-coercion.html`
  },
  ["TRANSITION_CLASSES"]: {
    message: ``
    // this feature cannot be runtime-detected
  },
  ["TRANSITION_GROUP_ROOT"]: {
    message: `<TransitionGroup> no longer renders a root <span> element by default if no "tag" prop is specified. If you do not rely on the span for styling, you can disable the compat behavior and suppress this warning with:

  configureCompat({ ${"TRANSITION_GROUP_ROOT"}: false })
`,
    link: `https://v3-migration.vuejs.org/breaking-changes/transition-group.html`
  },
  ["COMPONENT_ASYNC"]: {
    message: (comp) => {
      const name = getComponentName(comp);
      return `Async component${name ? ` <${name}>` : `s`} should be explicitly created via \`defineAsyncComponent()\` in Vue 3. Plain functions will be treated as functional components in non-compat build. If you have already migrated all async component usage and intend to use plain functions for functional components, you can disable the compat behavior and suppress this warning with:

  configureCompat({ ${"COMPONENT_ASYNC"}: false })
`;
    },
    link: `https://v3-migration.vuejs.org/breaking-changes/async-components.html`
  },
  ["COMPONENT_FUNCTIONAL"]: {
    message: (comp) => {
      const name = getComponentName(comp);
      return `Functional component${name ? ` <${name}>` : `s`} should be defined as a plain function in Vue 3. The "functional" option has been removed. NOTE: Before migrating to use plain functions for functional components, first make sure that all async components usage have been migrated and its compat behavior has been disabled.`;
    },
    link: `https://v3-migration.vuejs.org/breaking-changes/functional-components.html`
  },
  ["COMPONENT_V_MODEL"]: {
    message: (comp) => {
      const configMsg = `opt-in to Vue 3 behavior on a per-component basis with \`compatConfig: { ${"COMPONENT_V_MODEL"}: false }\`.`;
      if (comp.props && (isArray(comp.props) ? comp.props.includes("modelValue") : hasOwn(comp.props, "modelValue"))) {
        return `Component declares "modelValue" prop, which is Vue 3 usage, but is running under Vue 2 compat v-model behavior. You can ${configMsg}`;
      }
      return `v-model usage on component has changed in Vue 3. Component that expects to work with v-model should now use the "modelValue" prop and emit the "update:modelValue" event. You can update the usage and then ${configMsg}`;
    },
    link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`
  },
  ["RENDER_FUNCTION"]: {
    message: `Vue 3's render function API has changed. You can opt-in to the new API with:

  configureCompat({ ${"RENDER_FUNCTION"}: false })

  (This can also be done per-component via the "compatConfig" option.)`,
    link: `https://v3-migration.vuejs.org/breaking-changes/render-function-api.html`
  },
  ["FILTERS"]: {
    message: `filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`
  },
  ["PRIVATE_APIS"]: {
    message: (name) => `"${name}" is a Vue 2 private API that no longer exists in Vue 3. If you are seeing this warning only due to a dependency, you can suppress this warning via { PRIVATE_APIS: 'suppress-warning' }.`
  }
};
const instanceWarned = /* @__PURE__ */ Object.create(null);
const warnCount = /* @__PURE__ */ Object.create(null);
function warnDeprecation$1(key, instance, ...args) {
  if (true) {
    return;
  }
  instance = instance || getCurrentInstance();
  const config = getCompatConfigForKey(key, instance);
  if (config === "suppress-warning") {
    return;
  }
  const dupKey = key + args.join("");
  let compId = instance && formatComponentName(instance, instance.type);
  if (compId === "Anonymous" && instance) {
    compId = instance.uid;
  }
  const componentDupKey = dupKey + compId;
  if (componentDupKey in instanceWarned) {
    return;
  }
  instanceWarned[componentDupKey] = true;
  if (dupKey in warnCount) {
    warn$1(`(deprecation ${key}) (${++warnCount[dupKey] + 1})`);
    return;
  }
  warnCount[dupKey] = 0;
  const { message, link } = deprecationData$1[key];
  warn$1(
    `(deprecation ${key}) ${typeof message === "function" ? message(...args) : message}${link ? `
  Details: ${link}` : ``}`
  );
  if (!isCompatEnabled$1(key, instance, true)) {
    console.error(
      `^ The above deprecation's compat behavior is disabled and will likely lead to runtime errors.`
    );
  }
}
const globalCompatConfig = {
  MODE: 2
};
function configureCompat$1(config) {
  if (false) {}
  extend(globalCompatConfig, config);
}
const seenConfigObjects = /* @__PURE__ */ new WeakSet();
const warnedInvalidKeys = {};
function validateCompatConfig(config, instance) {
  if (seenConfigObjects.has(config)) {
    return;
  }
  seenConfigObjects.add(config);
  for (const key of Object.keys(config)) {
    if (key !== "MODE" && !(key in deprecationData$1) && !(key in warnedInvalidKeys)) {
      if (key.startsWith("COMPILER_")) {
        if (isRuntimeOnly()) {
          warn$1(
            `Deprecation config "${key}" is compiler-specific and you are running a runtime-only build of Vue. This deprecation should be configured via compiler options in your build setup instead.
Details: https://v3-migration.vuejs.org/breaking-changes/migration-build.html`
          );
        }
      } else {
        warn$1(`Invalid deprecation config "${key}".`);
      }
      warnedInvalidKeys[key] = true;
    }
  }
  if (instance && config["OPTIONS_DATA_MERGE"] != null) {
    warn$1(
      `Deprecation config "${"OPTIONS_DATA_MERGE"}" can only be configured globally.`
    );
  }
}
function getCompatConfigForKey(key, instance) {
  const instanceConfig = instance && instance.type.compatConfig;
  if (instanceConfig && key in instanceConfig) {
    return instanceConfig[key];
  }
  return globalCompatConfig[key];
}
function isCompatEnabled$1(key, instance, enableForBuiltIn = false) {
  if (!enableForBuiltIn && instance && instance.type.__isBuiltIn) {
    return false;
  }
  const rawMode = getCompatConfigForKey("MODE", instance) || 2;
  const val = getCompatConfigForKey(key, instance);
  const mode = isFunction(rawMode) ? rawMode(instance && instance.type) : rawMode;
  if (mode === 2) {
    return val !== false;
  } else {
    return val === true || val === "suppress-warning";
  }
}
function assertCompatEnabled(key, instance, ...args) {
  if (!isCompatEnabled$1(key, instance)) {
    throw new Error(`${key} compat has been disabled.`);
  } else if (false) {}
}
function softAssertCompatEnabled(key, instance, ...args) {
  if (false) {}
  return isCompatEnabled$1(key, instance);
}
function checkCompatEnabled$1(key, instance, ...args) {
  const enabled = isCompatEnabled$1(key, instance);
  if (false) {}
  return enabled;
}

const eventRegistryMap = /* @__PURE__ */ new WeakMap();
function getRegistry(instance) {
  let events = eventRegistryMap.get(instance);
  if (!events) {
    eventRegistryMap.set(instance, events = /* @__PURE__ */ Object.create(null));
  }
  return events;
}
function on(instance, event, fn) {
  if (isArray(event)) {
    event.forEach((e) => on(instance, e, fn));
  } else {
    if (event.startsWith("hook:")) {
      assertCompatEnabled(
        "INSTANCE_EVENT_HOOKS",
        instance,
        event
      );
    } else {
      assertCompatEnabled("INSTANCE_EVENT_EMITTER", instance);
    }
    const events = getRegistry(instance);
    (events[event] || (events[event] = [])).push(fn);
  }
  return instance.proxy;
}
function once(instance, event, fn) {
  const wrapped = (...args) => {
    off(instance, event, wrapped);
    fn.call(instance.proxy, ...args);
  };
  wrapped.fn = fn;
  on(instance, event, wrapped);
  return instance.proxy;
}
function off(instance, event, fn) {
  assertCompatEnabled("INSTANCE_EVENT_EMITTER", instance);
  const vm = instance.proxy;
  if (!event) {
    eventRegistryMap.set(instance, /* @__PURE__ */ Object.create(null));
    return vm;
  }
  if (isArray(event)) {
    event.forEach((e) => off(instance, e, fn));
    return vm;
  }
  const events = getRegistry(instance);
  const cbs = events[event];
  if (!cbs) {
    return vm;
  }
  if (!fn) {
    events[event] = void 0;
    return vm;
  }
  events[event] = cbs.filter((cb) => !(cb === fn || cb.fn === fn));
  return vm;
}
function emit$1(instance, event, args) {
  const cbs = getRegistry(instance)[event];
  if (cbs) {
    callWithAsyncErrorHandling(
      cbs.map((cb) => cb.bind(instance.proxy)),
      instance,
      6,
      args
    );
  }
  return instance.proxy;
}

const compatModelEventPrefix = `onModelCompat:`;
const warnedTypes = /* @__PURE__ */ new WeakSet();
function convertLegacyVModelProps(vnode) {
  const { type, shapeFlag, props, dynamicProps } = vnode;
  const comp = type;
  if (shapeFlag & 6 && props && "modelValue" in props) {
    if (!isCompatEnabled$1(
      "COMPONENT_V_MODEL",
      // this is a special case where we want to use the vnode component's
      // compat config instead of the current rendering instance (which is the
      // parent of the component that exposes v-model)
      { type }
    )) {
      return;
    }
    if (false) {}
    const model = comp.model || {};
    applyModelFromMixins(model, comp.mixins);
    const { prop = "value", event = "input" } = model;
    if (prop !== "modelValue") {
      props[prop] = props.modelValue;
      delete props.modelValue;
    }
    if (dynamicProps) {
      dynamicProps[dynamicProps.indexOf("modelValue")] = prop;
    }
    props[compatModelEventPrefix + event] = props["onUpdate:modelValue"];
    delete props["onUpdate:modelValue"];
  }
}
function applyModelFromMixins(model, mixins) {
  if (mixins) {
    mixins.forEach((m) => {
      if (m.model)
        extend(model, m.model);
      if (m.mixins)
        applyModelFromMixins(model, m.mixins);
    });
  }
}
function compatModelEmit(instance, event, args) {
  if (!isCompatEnabled$1("COMPONENT_V_MODEL", instance)) {
    return;
  }
  const props = instance.vnode.props;
  const modelHandler = props && props[compatModelEventPrefix + event];
  if (modelHandler) {
    callWithErrorHandling(
      modelHandler,
      instance,
      6,
      args
    );
  }
}

function emit(instance, event, ...rawArgs) {
  if (instance.isUnmounted)
    return;
  const props = instance.vnode.props || EMPTY_OBJ;
  if (false) {}
  let args = rawArgs;
  const isModelListener = event.startsWith("update:");
  const modelArg = isModelListener && event.slice(7);
  if (modelArg && modelArg in props) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number, trim } = props[modifiersKey] || EMPTY_OBJ;
    if (trim) {
      args = rawArgs.map((a) => isString(a) ? a.trim() : a);
    }
    if (number) {
      args = rawArgs.map(looseToNumber);
    }
  }
  if ( false || __VUE_PROD_DEVTOOLS__) {
    devtoolsComponentEmit(instance, event, args);
  }
  if (false) {}
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
  props[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(
      handler,
      instance,
      6,
      args
    );
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(
      onceHandler,
      instance,
      6,
      args
    );
  }
  {
    compatModelEmit(instance, event, args);
    return emit$1(instance, event, args);
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (__VUE_OPTIONS_API__ && !isFunction(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject(comp)) {
      cache.set(comp, null);
    }
    return null;
  }
  if (isArray(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend(normalized, raw);
  }
  if (isObject(comp)) {
    cache.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  if (key.startsWith(compatModelEventPrefix)) {
    return true;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
}

let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  if (!currentScopeId) {
    currentScopeId = instance && instance.type._scopeId || null;
  }
  return prev;
}
function pushScopeId(id) {
  currentScopeId = id;
}
function popScopeId() {
  currentScopeId = null;
}
const withScopeId = (_id) => withCtx;
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx)
    return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    if ( false || __VUE_PROD_DEVTOOLS__) {
      devtoolsComponentUpdated(ctx);
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  if (isNonScopedSlot) {
    renderFnWithContext._ns = true;
  }
  return renderFnWithContext;
}

let accessedAttrs = false;
function markAttrsAccessed() {
  accessedAttrs = true;
}
function renderComponentRoot(instance) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    props,
    propsOptions: [propsOptions],
    slots,
    attrs,
    emit,
    render,
    renderCache,
    data,
    setupState,
    ctx,
    inheritAttrs
  } = instance;
  let result;
  let fallthroughAttrs;
  const prev = setCurrentRenderingInstance(instance);
  if (false) {}
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      const thisProxy =  false ? 0 : proxyToUse;
      result = normalizeVNode(
        render.call(
          thisProxy,
          proxyToUse,
          renderCache,
          props,
          setupState,
          data,
          ctx
        )
      );
      fallthroughAttrs = attrs;
    } else {
      const render2 = Component;
      if (false) {}
      result = normalizeVNode(
        render2.length > 1 ? render2(
          props,
           false ? 0 : { attrs, slots, emit }
        ) : render2(
          props,
          null
          /* we know it doesn't need it */
        )
      );
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root = result;
  let setRoot = void 0;
  if (false) {}
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(
            fallthroughAttrs,
            propsOptions
          );
        }
        root = cloneVNode(root, fallthroughAttrs);
      } else if (false) {}
    }
  }
  if (isCompatEnabled$1("INSTANCE_ATTRS_CLASS_STYLE", instance) && vnode.shapeFlag & 4 && root.shapeFlag & (1 | 6)) {
    const { class: cls, style } = vnode.props || {};
    if (cls || style) {
      if (false) {}
      root = cloneVNode(root, {
        class: cls,
        style
      });
    }
  }
  if (vnode.dirs) {
    if (false) {}
    root = cloneVNode(root);
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    if (false) {}
    root.transition = vnode.transition;
  }
  if (false) {} else {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
const getChildRoot = (vnode) => {
  const rawChildren = vnode.children;
  const dynamicChildren = vnode.dynamicChildren;
  const childRoot = filterSingleRoot(rawChildren, false);
  if (!childRoot) {
    return [vnode, void 0];
  } else if (false) {}
  const index = rawChildren.indexOf(childRoot);
  const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
  const setRoot = (updatedRoot) => {
    rawChildren[index] = updatedRoot;
    if (dynamicChildren) {
      if (dynamicIndex > -1) {
        dynamicChildren[dynamicIndex] = updatedRoot;
      } else if (updatedRoot.patchFlag > 0) {
        vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
      }
    }
  };
  return [normalizeVNode(childRoot), setRoot];
};
function filterSingleRoot(children, recurse = true) {
  let singleRoot;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (isVNode(child)) {
      if (child.type !== Comment || child.children === "v-if") {
        if (singleRoot) {
          return;
        } else {
          singleRoot = child;
          if (false) {}
        }
      }
    } else {
      return;
    }
  }
  return singleRoot;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
const isElementRoot = (vnode) => {
  return vnode.shapeFlag & (6 | 1) || vnode.type === Comment;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (false) {}
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i = 0; i < dynamicProps.length; i++) {
        const key = dynamicProps[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent) {
    const root = parent.subTree;
    if (root.suspense && root.suspense.activeBranch === vnode) {
      root.el = vnode.el;
    }
    if (root === vnode) {
      (vnode = parent.vnode).el = el;
      parent = parent.parent;
    } else {
      break;
    }
  }
}

const COMPONENTS = "components";
const DIRECTIVES = "directives";
const FILTERS = "filters";
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveDynamicComponent(component) {
  if (isString(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveDirective(name) {
  return resolveAsset(DIRECTIVES, name);
}
function resolveFilter$1(name) {
  return resolveAsset(FILTERS, name);
}
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    if (type === COMPONENTS) {
      const selfName = getComponentName(
        Component,
        false
      );
      if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
        return Component;
      }
    }
    const res = (
      // local registration
      // check instance[type] first which is resolved for options API
      resolve(instance[type] || Component[type], name) || // global registration
      resolve(instance.appContext[type], name)
    );
    if (!res && maybeSelfReference) {
      return Component;
    }
    if (false) {}
    return res;
  } else if (false) {}
}
function resolve(registry, name) {
  return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
}

const isSuspense = (type) => type.__isSuspense;
let suspenseId = 0;
const SuspenseImpl = {
  name: "Suspense",
  // In order to make Suspense tree-shakable, we need to avoid importing it
  // directly in the renderer. The renderer checks for the __isSuspense flag
  // on a vnode's type and calls the `process` method, passing in renderer
  // internals.
  __isSuspense: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
    if (n1 == null) {
      mountSuspense(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized,
        rendererInternals
      );
    } else {
      if (parentSuspense && parentSuspense.deps > 0 && !n1.suspense.isInFallback) {
        n2.suspense = n1.suspense;
        n2.suspense.vnode = n2;
        n2.el = n1.el;
        return;
      }
      patchSuspense(
        n1,
        n2,
        container,
        anchor,
        parentComponent,
        namespace,
        slotScopeIds,
        optimized,
        rendererInternals
      );
    }
  },
  hydrate: hydrateSuspense,
  create: createSuspenseBoundary,
  normalize: normalizeSuspenseChildren
};
const Suspense = SuspenseImpl ;
function triggerEvent(vnode, name) {
  const eventListener = vnode.props && vnode.props[name];
  if (isFunction(eventListener)) {
    eventListener();
  }
}
function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
  const {
    p: patch,
    o: { createElement }
  } = rendererInternals;
  const hiddenContainer = createElement("div");
  const suspense = vnode.suspense = createSuspenseBoundary(
    vnode,
    parentSuspense,
    parentComponent,
    container,
    hiddenContainer,
    anchor,
    namespace,
    slotScopeIds,
    optimized,
    rendererInternals
  );
  patch(
    null,
    suspense.pendingBranch = vnode.ssContent,
    hiddenContainer,
    null,
    parentComponent,
    suspense,
    namespace,
    slotScopeIds
  );
  if (suspense.deps > 0) {
    triggerEvent(vnode, "onPending");
    triggerEvent(vnode, "onFallback");
    patch(
      null,
      vnode.ssFallback,
      container,
      anchor,
      parentComponent,
      null,
      // fallback tree will not have suspense context
      namespace,
      slotScopeIds
    );
    setActiveBranch(suspense, vnode.ssFallback);
  } else {
    suspense.resolve(false, true);
  }
}
function patchSuspense(n1, n2, container, anchor, parentComponent, namespace, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {
  const suspense = n2.suspense = n1.suspense;
  suspense.vnode = n2;
  n2.el = n1.el;
  const newBranch = n2.ssContent;
  const newFallback = n2.ssFallback;
  const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
  if (pendingBranch) {
    suspense.pendingBranch = newBranch;
    if (isSameVNodeType(newBranch, pendingBranch)) {
      patch(
        pendingBranch,
        newBranch,
        suspense.hiddenContainer,
        null,
        parentComponent,
        suspense,
        namespace,
        slotScopeIds,
        optimized
      );
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else if (isInFallback) {
        if (!isHydrating) {
          patch(
            activeBranch,
            newFallback,
            container,
            anchor,
            parentComponent,
            null,
            // fallback tree will not have suspense context
            namespace,
            slotScopeIds,
            optimized
          );
          setActiveBranch(suspense, newFallback);
        }
      }
    } else {
      suspense.pendingId = suspenseId++;
      if (isHydrating) {
        suspense.isHydrating = false;
        suspense.activeBranch = pendingBranch;
      } else {
        unmount(pendingBranch, parentComponent, suspense);
      }
      suspense.deps = 0;
      suspense.effects.length = 0;
      suspense.hiddenContainer = createElement("div");
      if (isInFallback) {
        patch(
          null,
          newBranch,
          suspense.hiddenContainer,
          null,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        if (suspense.deps <= 0) {
          suspense.resolve();
        } else {
          patch(
            activeBranch,
            newFallback,
            container,
            anchor,
            parentComponent,
            null,
            // fallback tree will not have suspense context
            namespace,
            slotScopeIds,
            optimized
          );
          setActiveBranch(suspense, newFallback);
        }
      } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
        patch(
          activeBranch,
          newBranch,
          container,
          anchor,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        suspense.resolve(true);
      } else {
        patch(
          null,
          newBranch,
          suspense.hiddenContainer,
          null,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        if (suspense.deps <= 0) {
          suspense.resolve();
        }
      }
    }
  } else {
    if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
      patch(
        activeBranch,
        newBranch,
        container,
        anchor,
        parentComponent,
        suspense,
        namespace,
        slotScopeIds,
        optimized
      );
      setActiveBranch(suspense, newBranch);
    } else {
      triggerEvent(n2, "onPending");
      suspense.pendingBranch = newBranch;
      if (newBranch.shapeFlag & 512) {
        suspense.pendingId = newBranch.component.suspenseId;
      } else {
        suspense.pendingId = suspenseId++;
      }
      patch(
        null,
        newBranch,
        suspense.hiddenContainer,
        null,
        parentComponent,
        suspense,
        namespace,
        slotScopeIds,
        optimized
      );
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else {
        const { timeout, pendingId } = suspense;
        if (timeout > 0) {
          setTimeout(() => {
            if (suspense.pendingId === pendingId) {
              suspense.fallback(newFallback);
            }
          }, timeout);
        } else if (timeout === 0) {
          suspense.fallback(newFallback);
        }
      }
    }
  }
}
let hasWarned = false;
function createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, namespace, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
  if (false) {}
  const {
    p: patch,
    m: move,
    um: unmount,
    n: next,
    o: { parentNode, remove }
  } = rendererInternals;
  let parentSuspenseId;
  const isSuspensible = isVNodeSuspensible(vnode);
  if (isSuspensible) {
    if (parentSuspense == null ? void 0 : parentSuspense.pendingBranch) {
      parentSuspenseId = parentSuspense.pendingId;
      parentSuspense.deps++;
    }
  }
  const timeout = vnode.props ? toNumber(vnode.props.timeout) : void 0;
  if (false) {}
  const initialAnchor = anchor;
  const suspense = {
    vnode,
    parent: parentSuspense,
    parentComponent,
    namespace,
    container,
    hiddenContainer,
    deps: 0,
    pendingId: suspenseId++,
    timeout: typeof timeout === "number" ? timeout : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: !isHydrating,
    isHydrating,
    isUnmounted: false,
    effects: [],
    resolve(resume = false, sync = false) {
      if (false) {}
      const {
        vnode: vnode2,
        activeBranch,
        pendingBranch,
        pendingId,
        effects,
        parentComponent: parentComponent2,
        container: container2
      } = suspense;
      let delayEnter = false;
      if (suspense.isHydrating) {
        suspense.isHydrating = false;
      } else if (!resume) {
        delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
        if (delayEnter) {
          activeBranch.transition.afterLeave = () => {
            if (pendingId === suspense.pendingId) {
              move(
                pendingBranch,
                container2,
                anchor === initialAnchor ? next(activeBranch) : anchor,
                0
              );
              queuePostFlushCb(effects);
            }
          };
        }
        if (activeBranch) {
          if (parentNode(activeBranch.el) !== suspense.hiddenContainer) {
            anchor = next(activeBranch);
          }
          unmount(activeBranch, parentComponent2, suspense, true);
        }
        if (!delayEnter) {
          move(pendingBranch, container2, anchor, 0);
        }
      }
      setActiveBranch(suspense, pendingBranch);
      suspense.pendingBranch = null;
      suspense.isInFallback = false;
      let parent = suspense.parent;
      let hasUnresolvedAncestor = false;
      while (parent) {
        if (parent.pendingBranch) {
          parent.effects.push(...effects);
          hasUnresolvedAncestor = true;
          break;
        }
        parent = parent.parent;
      }
      if (!hasUnresolvedAncestor && !delayEnter) {
        queuePostFlushCb(effects);
      }
      suspense.effects = [];
      if (isSuspensible) {
        if (parentSuspense && parentSuspense.pendingBranch && parentSuspenseId === parentSuspense.pendingId) {
          parentSuspense.deps--;
          if (parentSuspense.deps === 0 && !sync) {
            parentSuspense.resolve();
          }
        }
      }
      triggerEvent(vnode2, "onResolve");
    },
    fallback(fallbackVNode) {
      if (!suspense.pendingBranch) {
        return;
      }
      const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, namespace: namespace2 } = suspense;
      triggerEvent(vnode2, "onFallback");
      const anchor2 = next(activeBranch);
      const mountFallback = () => {
        if (!suspense.isInFallback) {
          return;
        }
        patch(
          null,
          fallbackVNode,
          container2,
          anchor2,
          parentComponent2,
          null,
          // fallback tree will not have suspense context
          namespace2,
          slotScopeIds,
          optimized
        );
        setActiveBranch(suspense, fallbackVNode);
      };
      const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
      if (delayEnter) {
        activeBranch.transition.afterLeave = mountFallback;
      }
      suspense.isInFallback = true;
      unmount(
        activeBranch,
        parentComponent2,
        null,
        // no suspense so unmount hooks fire now
        true
        // shouldRemove
      );
      if (!delayEnter) {
        mountFallback();
      }
    },
    move(container2, anchor2, type) {
      suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);
      suspense.container = container2;
    },
    next() {
      return suspense.activeBranch && next(suspense.activeBranch);
    },
    registerDep(instance, setupRenderEffect) {
      const isInPendingSuspense = !!suspense.pendingBranch;
      if (isInPendingSuspense) {
        suspense.deps++;
      }
      const hydratedEl = instance.vnode.el;
      instance.asyncDep.catch((err) => {
        handleError(err, instance, 0);
      }).then((asyncSetupResult) => {
        if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
          return;
        }
        instance.asyncResolved = true;
        const { vnode: vnode2 } = instance;
        if (false) {}
        handleSetupResult(instance, asyncSetupResult, false);
        if (hydratedEl) {
          vnode2.el = hydratedEl;
        }
        const placeholder = !hydratedEl && instance.subTree.el;
        setupRenderEffect(
          instance,
          vnode2,
          // component may have been moved before resolve.
          // if this is not a hydration, instance.subTree will be the comment
          // placeholder.
          parentNode(hydratedEl || instance.subTree.el),
          // anchor will not be used if this is hydration, so only need to
          // consider the comment placeholder case.
          hydratedEl ? null : next(instance.subTree),
          suspense,
          namespace,
          optimized
        );
        if (placeholder) {
          remove(placeholder);
        }
        updateHOCHostEl(instance, vnode2.el);
        if (false) {}
        if (isInPendingSuspense && --suspense.deps === 0) {
          suspense.resolve();
        }
      });
    },
    unmount(parentSuspense2, doRemove) {
      suspense.isUnmounted = true;
      if (suspense.activeBranch) {
        unmount(
          suspense.activeBranch,
          parentComponent,
          parentSuspense2,
          doRemove
        );
      }
      if (suspense.pendingBranch) {
        unmount(
          suspense.pendingBranch,
          parentComponent,
          parentSuspense2,
          doRemove
        );
      }
    }
  };
  return suspense;
}
function hydrateSuspense(node, vnode, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals, hydrateNode) {
  const suspense = vnode.suspense = createSuspenseBoundary(
    vnode,
    parentSuspense,
    parentComponent,
    node.parentNode,
    // eslint-disable-next-line no-restricted-globals
    document.createElement("div"),
    null,
    namespace,
    slotScopeIds,
    optimized,
    rendererInternals,
    true
  );
  const result = hydrateNode(
    node,
    suspense.pendingBranch = vnode.ssContent,
    parentComponent,
    suspense,
    slotScopeIds,
    optimized
  );
  if (suspense.deps === 0) {
    suspense.resolve(false, true);
  }
  return result;
}
function normalizeSuspenseChildren(vnode) {
  const { shapeFlag, children } = vnode;
  const isSlotChildren = shapeFlag & 32;
  vnode.ssContent = normalizeSuspenseSlot(
    isSlotChildren ? children.default : children
  );
  vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
}
function normalizeSuspenseSlot(s) {
  let block;
  if (isFunction(s)) {
    const trackBlock = isBlockTreeEnabled && s._c;
    if (trackBlock) {
      s._d = false;
      openBlock();
    }
    s = s();
    if (trackBlock) {
      s._d = true;
      block = currentBlock;
      closeBlock();
    }
  }
  if (isArray(s)) {
    const singleChild = filterSingleRoot(s);
    if (false) {}
    s = singleChild;
  }
  s = normalizeVNode(s);
  if (block && !s.dynamicChildren) {
    s.dynamicChildren = block.filter((c) => c !== s);
  }
  return s;
}
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
function setActiveBranch(suspense, branch) {
  suspense.activeBranch = branch;
  const { vnode, parentComponent } = suspense;
  let el = branch.el;
  while (!el && branch.component) {
    branch = branch.component.subTree;
    el = branch.el;
  }
  vnode.el = el;
  if (parentComponent && parentComponent.subTree === vnode) {
    parentComponent.vnode.el = el;
    updateHOCHostEl(parentComponent, el);
  }
}
function isVNodeSuspensible(vnode) {
  var _a;
  return ((_a = vnode.props) == null ? void 0 : _a.suspensible) != null && vnode.props.suspensible !== false;
}

const legacyDirectiveHookMap = {
  beforeMount: "bind",
  mounted: "inserted",
  updated: ["update", "componentUpdated"],
  unmounted: "unbind"
};
function mapCompatDirectiveHook(name, dir, instance) {
  const mappedName = legacyDirectiveHookMap[name];
  if (mappedName) {
    if (isArray(mappedName)) {
      const hook = [];
      mappedName.forEach((mapped) => {
        const mappedHook = dir[mapped];
        if (mappedHook) {
          softAssertCompatEnabled(
            "CUSTOM_DIR",
            instance,
            mapped,
            name
          );
          hook.push(mappedHook);
        }
      });
      return hook.length ? hook : void 0;
    } else {
      if (dir[mappedName]) {
        softAssertCompatEnabled(
          "CUSTOM_DIR",
          instance,
          mappedName,
          name
        );
      }
      return dir[mappedName];
    }
  }
}

const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    if (!ctx) {
       false && 0;
    }
    return ctx;
  }
};

function watchEffect(effect, options) {
  return doWatch(effect, null, options);
}
function watchPostEffect(effect, options) {
  return doWatch(
    effect,
    null,
     false ? 0 : { flush: "post" }
  );
}
function watchSyncEffect(effect, options) {
  return doWatch(
    effect,
    null,
     false ? 0 : { flush: "sync" }
  );
}
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options) {
  if (false) {}
  return doWatch(source, cb, options);
}
function doWatch(source, cb, {
  immediate,
  deep,
  flush,
  once,
  onTrack,
  onTrigger
} = EMPTY_OBJ) {
  if (cb && once) {
    const _cb = cb;
    cb = (...args) => {
      _cb(...args);
      unwatch();
    };
  }
  if (false) {}
  if (false) {}
  const warnInvalidSource = (s) => {
    warn$1(
      `Invalid watch source: `,
      s,
      `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`
    );
  };
  const instance = currentInstance;
  const reactiveGetter = (source2) => deep === true ? source2 : (
    // for deep: false, only traverse root-level properties
    traverse(source2, deep === false ? 1 : void 0)
  );
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => reactiveGetter(source);
    forceTrigger = true;
  } else if (isArray(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return reactiveGetter(s);
      } else if (isFunction(s)) {
        return callWithErrorHandling(s, instance, 2);
      } else {
         false && 0;
      }
    });
  } else if (isFunction(source)) {
    if (cb) {
      getter = () => callWithErrorHandling(source, instance, 2);
    } else {
      getter = () => {
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(
          source,
          instance,
          3,
          [onCleanup]
        );
      };
    }
  } else {
    getter = NOOP;
     false && 0;
  }
  if (cb && !deep) {
    const baseGetter = getter;
    getter = () => {
      const val = baseGetter();
      if (isArray(val) && checkCompatEnabled$1("WATCH_ARRAY", instance)) {
        traverse(val);
      }
      return val;
    };
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn) => {
    cleanup = effect.onStop = () => {
      callWithErrorHandling(fn, instance, 4);
      cleanup = effect.onStop = void 0;
    };
  };
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    onCleanup = NOOP;
    if (!cb) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb, instance, 3, [
        getter(),
        isMultiSource ? [] : void 0,
        onCleanup
      ]);
    }
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else {
      return NOOP;
    }
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect.active || !effect.dirty) {
      return;
    }
    if (cb) {
      const newValue = effect.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue)) || isArray(newValue) && isCompatEnabled$1("WATCH_ARRAY", instance)) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, instance, 3, [
          newValue,
          // pass undefined as the old value when it's changed for the first time
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
  } else {
    job.pre = true;
    if (instance)
      job.id = instance.uid;
    scheduler = () => queueJob(job);
  }
  const effect = new ReactiveEffect(getter, NOOP, scheduler);
  const scope = getCurrentScope();
  const unwatch = () => {
    effect.stop();
    if (scope) {
      remove(scope.effects, effect);
    }
  };
  if (false) {}
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect(
      effect.run.bind(effect),
      instance && instance.suspense
    );
  } else {
    effect.run();
  }
  if (ssrCleanup)
    ssrCleanup.push(unwatch);
  return unwatch;
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const reset = setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  reset();
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}
function traverse(value, depth, currentDepth = 0, seen) {
  if (!isObject(value) || value["__v_skip"]) {
    return value;
  }
  if (depth && depth > 0) {
    if (currentDepth >= depth) {
      return value;
    }
    currentDepth++;
  }
  seen = seen || /* @__PURE__ */ new Set();
  if (seen.has(value)) {
    return value;
  }
  seen.add(value);
  if (isRef(value)) {
    traverse(value.value, depth, currentDepth, seen);
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], depth, currentDepth, seen);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v) => {
      traverse(v, depth, currentDepth, seen);
    });
  } else if (isPlainObject(value)) {
    for (const key in value) {
      traverse(value[key], depth, currentDepth, seen);
    }
  }
  return value;
}

function validateDirectiveName(name) {
  if (isBuiltInDirective(name)) {
    warn$1("Do not use built-in directive ids as custom directive id: " + name);
  }
}
function withDirectives(vnode, directives) {
  if (currentRenderingInstance === null) {
     false && 0;
    return vnode;
  }
  const instance = getExposeProxy(currentRenderingInstance) || currentRenderingInstance.proxy;
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i = 0; i < directives.length; i++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
    if (dir) {
      if (isFunction(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse(value);
      }
      bindings.push({
        dir,
        instance,
        value,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];
    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }
    let hook = binding.dir[name];
    if (!hook) {
      hook = mapCompatDirectiveHook(name, binding.dir, instance);
    }
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}

const leaveCbKey = Symbol("_leaveCb");
const enterCbKey$1 = Symbol("_enterCb");
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionPropsValidators = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: TransitionHookValidator,
  onEnter: TransitionHookValidator,
  onAfterEnter: TransitionHookValidator,
  onEnterCancelled: TransitionHookValidator,
  // leave
  onBeforeLeave: TransitionHookValidator,
  onLeave: TransitionHookValidator,
  onAfterLeave: TransitionHookValidator,
  onLeaveCancelled: TransitionHookValidator,
  // appear
  onBeforeAppear: TransitionHookValidator,
  onAppear: TransitionHookValidator,
  onAfterAppear: TransitionHookValidator,
  onAppearCancelled: TransitionHookValidator
};
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: BaseTransitionPropsValidators,
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      let child = children[0];
      if (children.length > 1) {
        let hasFound = false;
        for (const c of children) {
          if (c.type !== Comment) {
            if (false) {}
            child = c;
            hasFound = true;
            if (true)
              break;
          }
        }
      }
      const rawProps = toRaw(props);
      const { mode } = rawProps;
      if (false) {}
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getKeepAliveChild(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      const enterHooks = resolveTransitionHooks(
        innerChild,
        rawProps,
        state,
        instance
      );
      setTransitionHooks(innerChild, enterHooks);
      const oldChild = instance.subTree;
      const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
      if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild)) {
        const leavingHooks = resolveTransitionHooks(
          oldInnerChild,
          rawProps,
          state,
          instance
        );
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in") {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            if (instance.update.active !== false) {
              instance.effect.dirty = true;
              instance.update();
            }
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(
              state,
              oldInnerChild
            );
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el[leaveCbKey] = () => {
              earlyRemove();
              el[leaveCbKey] = void 0;
              delete enterHooks.delayedLeave;
            };
            enterHooks.delayedLeave = delayedLeave;
          };
        }
      }
      return child;
    };
  }
};
{
  BaseTransitionImpl.__isBuiltIn = true;
}
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance) {
  const {
    appear,
    mode,
    persisted = false,
    onBeforeEnter,
    onEnter,
    onAfterEnter,
    onEnterCancelled,
    onBeforeLeave,
    onLeave,
    onAfterLeave,
    onLeaveCancelled,
    onBeforeAppear,
    onAppear,
    onAfterAppear,
    onAppearCancelled
  } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook = (hook, args) => {
    hook && callWithAsyncErrorHandling(
      hook,
      instance,
      9,
      args
    );
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook(hook, args);
    if (isArray(hook)) {
      if (hook.every((hook2) => hook2.length <= 1))
        done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el[leaveCbKey]) {
        el[leaveCbKey](
          true
          /* cancelled */
        );
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
        leavingVNode.el[leaveCbKey]();
      }
      callHook(hook, [el]);
    },
    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el[enterCbKey$1] = (cancelled) => {
        if (called)
          return;
        called = true;
        if (cancelled) {
          callHook(cancelHook, [el]);
        } else {
          callHook(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el[enterCbKey$1] = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el, done]);
      } else {
        done();
      }
    },
    leave(el, remove) {
      const key2 = String(vnode.key);
      if (el[enterCbKey$1]) {
        el[enterCbKey$1](
          true
          /* cancelled */
        );
      }
      if (state.isUnmounting) {
        return remove();
      }
      callHook(onBeforeLeave, [el]);
      let called = false;
      const done = el[leaveCbKey] = (cancelled) => {
        if (called)
          return;
        called = true;
        remove();
        if (cancelled) {
          callHook(onLeaveCancelled, [el]);
        } else {
          callHook(onAfterLeave, [el]);
        }
        el[leaveCbKey] = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      return resolveTransitionHooks(vnode2, props, state, instance);
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getKeepAliveChild(vnode) {
  return isKeepAlive(vnode) ? (
    // #7121 ensure get the child component subtree in case
    // it's been replaced during HMR
     false ? 0 : vnode.children ? vnode.children[0] : void 0
  ) : vnode;
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i = 0; i < children.length; i++) {
    let child = children[i];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
    if (child.type === Fragment) {
      if (child.patchFlag & 128)
        keyedFragmentCount++;
      ret = ret.concat(
        getTransitionRawChildren(child.children, keepComment, key)
      );
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i = 0; i < ret.length; i++) {
      ret[i].patchFlag = -2;
    }
  }
  return ret;
}

/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineComponent(options, extraOptions) {
  return isFunction(options) ? (
    // #8326: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))()
  ) : options;
}

const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineAsyncComponent(source) {
  if (isFunction(source)) {
    source = { loader: source };
  }
  const {
    loader,
    loadingComponent,
    errorComponent,
    delay = 200,
    timeout,
    // undefined = never times out
    suspensible = true,
    onError: userOnError
  } = source;
  let pendingRequest = null;
  let resolvedComp;
  let retries = 0;
  const retry = () => {
    retries++;
    pendingRequest = null;
    return load();
  };
  const load = () => {
    let thisRequest;
    return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {
      err = err instanceof Error ? err : new Error(String(err));
      if (userOnError) {
        return new Promise((resolve, reject) => {
          const userRetry = () => resolve(retry());
          const userFail = () => reject(err);
          userOnError(err, userRetry, userFail, retries + 1);
        });
      } else {
        throw err;
      }
    }).then((comp) => {
      if (thisRequest !== pendingRequest && pendingRequest) {
        return pendingRequest;
      }
      if (false) {}
      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
        comp = comp.default;
      }
      if (false) {}
      resolvedComp = comp;
      return comp;
    }));
  };
  return defineComponent({
    name: "AsyncComponentWrapper",
    __asyncLoader: load,
    get __asyncResolved() {
      return resolvedComp;
    },
    setup() {
      const instance = currentInstance;
      if (resolvedComp) {
        return () => createInnerComp(resolvedComp, instance);
      }
      const onError = (err) => {
        pendingRequest = null;
        handleError(
          err,
          instance,
          13,
          !errorComponent
        );
      };
      if (suspensible && instance.suspense || isInSSRComponentSetup) {
        return load().then((comp) => {
          return () => createInnerComp(comp, instance);
        }).catch((err) => {
          onError(err);
          return () => errorComponent ? createVNode(errorComponent, {
            error: err
          }) : null;
        });
      }
      const loaded = ref(false);
      const error = ref();
      const delayed = ref(!!delay);
      if (delay) {
        setTimeout(() => {
          delayed.value = false;
        }, delay);
      }
      if (timeout != null) {
        setTimeout(() => {
          if (!loaded.value && !error.value) {
            const err = new Error(
              `Async component timed out after ${timeout}ms.`
            );
            onError(err);
            error.value = err;
          }
        }, timeout);
      }
      load().then(() => {
        loaded.value = true;
        if (instance.parent && isKeepAlive(instance.parent.vnode)) {
          instance.parent.effect.dirty = true;
          queueJob(instance.parent.update);
        }
      }).catch((err) => {
        onError(err);
        error.value = err;
      });
      return () => {
        if (loaded.value && resolvedComp) {
          return createInnerComp(resolvedComp, instance);
        } else if (error.value && errorComponent) {
          return createVNode(errorComponent, {
            error: error.value
          });
        } else if (loadingComponent && !delayed.value) {
          return createVNode(loadingComponent);
        }
      };
    }
  });
}
function createInnerComp(comp, parent) {
  const { ref: ref2, props, children, ce } = parent.vnode;
  const vnode = createVNode(comp, props, children);
  vnode.ref = ref2;
  vnode.ce = ce;
  delete parent.vnode.ce;
  return vnode;
}

const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
const KeepAliveImpl = {
  name: `KeepAlive`,
  // Marker for special handling inside the renderer. We are not using a ===
  // check directly on KeepAlive in the renderer, because importing it directly
  // would prevent it from being tree-shaken.
  __isKeepAlive: true,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const sharedContext = instance.ctx;
    if (!sharedContext.renderer) {
      return () => {
        const children = slots.default && slots.default();
        return children && children.length === 1 ? children[0] : children;
      };
    }
    const cache = /* @__PURE__ */ new Map();
    const keys = /* @__PURE__ */ new Set();
    let current = null;
    if ( false || __VUE_PROD_DEVTOOLS__) {
      instance.__v_cache = cache;
    }
    const parentSuspense = instance.suspense;
    const {
      renderer: {
        p: patch,
        m: move,
        um: _unmount,
        o: { createElement }
      }
    } = sharedContext;
    const storageContainer = createElement("div");
    sharedContext.activate = (vnode, container, anchor, namespace, optimized) => {
      const instance2 = vnode.component;
      move(vnode, container, anchor, 0, parentSuspense);
      patch(
        instance2.vnode,
        vnode,
        container,
        anchor,
        instance2,
        parentSuspense,
        namespace,
        vnode.slotScopeIds,
        optimized
      );
      queuePostRenderEffect(() => {
        instance2.isDeactivated = false;
        if (instance2.a) {
          invokeArrayFns(instance2.a);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
      }, parentSuspense);
      if ( false || __VUE_PROD_DEVTOOLS__) {
        devtoolsComponentAdded(instance2);
      }
    };
    sharedContext.deactivate = (vnode) => {
      const instance2 = vnode.component;
      move(vnode, storageContainer, null, 1, parentSuspense);
      queuePostRenderEffect(() => {
        if (instance2.da) {
          invokeArrayFns(instance2.da);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
        instance2.isDeactivated = true;
      }, parentSuspense);
      if ( false || __VUE_PROD_DEVTOOLS__) {
        devtoolsComponentAdded(instance2);
      }
    };
    function unmount(vnode) {
      resetShapeFlag(vnode);
      _unmount(vnode, instance, parentSuspense, true);
    }
    function pruneCache(filter) {
      cache.forEach((vnode, key) => {
        const name = getComponentName(vnode.type);
        if (name && (!filter || !filter(name))) {
          pruneCacheEntry(key);
        }
      });
    }
    function pruneCacheEntry(key) {
      const cached = cache.get(key);
      if (!current || !isSameVNodeType(cached, current)) {
        unmount(cached);
      } else if (current) {
        resetShapeFlag(current);
      }
      cache.delete(key);
      keys.delete(key);
    }
    watch(
      () => [props.include, props.exclude],
      ([include, exclude]) => {
        include && pruneCache((name) => matches(include, name));
        exclude && pruneCache((name) => !matches(exclude, name));
      },
      // prune post-render after `current` has been updated
      { flush: "post", deep: true }
    );
    let pendingCacheKey = null;
    const cacheSubtree = () => {
      if (pendingCacheKey != null) {
        cache.set(pendingCacheKey, getInnerChild(instance.subTree));
      }
    };
    onMounted(cacheSubtree);
    onUpdated(cacheSubtree);
    onBeforeUnmount(() => {
      cache.forEach((cached) => {
        const { subTree, suspense } = instance;
        const vnode = getInnerChild(subTree);
        if (cached.type === vnode.type && cached.key === vnode.key) {
          resetShapeFlag(vnode);
          const da = vnode.component.da;
          da && queuePostRenderEffect(da, suspense);
          return;
        }
        unmount(cached);
      });
    });
    return () => {
      pendingCacheKey = null;
      if (!slots.default) {
        return null;
      }
      const children = slots.default();
      const rawVNode = children[0];
      if (children.length > 1) {
        if (false) {}
        current = null;
        return children;
      } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
        current = null;
        return rawVNode;
      }
      let vnode = getInnerChild(rawVNode);
      const comp = vnode.type;
      const name = getComponentName(
        isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp
      );
      const { include, exclude, max } = props;
      if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
        current = vnode;
        return rawVNode;
      }
      const key = vnode.key == null ? comp : vnode.key;
      const cachedVNode = cache.get(key);
      if (vnode.el) {
        vnode = cloneVNode(vnode);
        if (rawVNode.shapeFlag & 128) {
          rawVNode.ssContent = vnode;
        }
      }
      pendingCacheKey = key;
      if (cachedVNode) {
        vnode.el = cachedVNode.el;
        vnode.component = cachedVNode.component;
        if (vnode.transition) {
          setTransitionHooks(vnode, vnode.transition);
        }
        vnode.shapeFlag |= 512;
        keys.delete(key);
        keys.add(key);
      } else {
        keys.add(key);
        if (max && keys.size > parseInt(max, 10)) {
          pruneCacheEntry(keys.values().next().value);
        }
      }
      vnode.shapeFlag |= 256;
      current = vnode;
      return isSuspense(rawVNode.type) ? rawVNode : vnode;
    };
  }
};
{
  KeepAliveImpl.__isBuildIn = true;
}
const KeepAlive = KeepAliveImpl;
function matches(pattern, name) {
  if (isArray(pattern)) {
    return pattern.some((p) => matches(p, name));
  } else if (isString(pattern)) {
    return pattern.split(",").includes(name);
  } else if (isRegExp(pattern)) {
    return pattern.test(name);
  }
  return false;
}
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function resetShapeFlag(vnode) {
  vnode.shapeFlag &= ~256;
  vnode.shapeFlag &= ~512;
}
function getInnerChild(vnode) {
  return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
}

function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      if (target.isUnmounted) {
        return;
      }
      pauseTracking();
      const reset = setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      reset();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  } else if (false) {}
}
const createHook = (lifecycle) => (hook, target = currentInstance) => (
  // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
  (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target)
);
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook(
  "rtg"
);
const onRenderTracked = createHook(
  "rtc"
);
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}

function getCompatChildren(instance) {
  assertCompatEnabled("INSTANCE_CHILDREN", instance);
  const root = instance.subTree;
  const children = [];
  if (root) {
    walk$1(root, children);
  }
  return children;
}
function walk$1(vnode, children) {
  if (vnode.component) {
    children.push(vnode.component.proxy);
  } else if (vnode.shapeFlag & 16) {
    const vnodes = vnode.children;
    for (let i = 0; i < vnodes.length; i++) {
      walk$1(vnodes[i], children);
    }
  }
}

function getCompatListeners(instance) {
  assertCompatEnabled("INSTANCE_LISTENERS", instance);
  const listeners = {};
  const rawProps = instance.vnode.props;
  if (!rawProps) {
    return listeners;
  }
  for (const key in rawProps) {
    if (isOn(key)) {
      listeners[key[2].toLowerCase() + key.slice(3)] = rawProps[key];
    }
  }
  return listeners;
}

function convertLegacyRenderFn(instance) {
  const Component = instance.type;
  const render = Component.render;
  if (!render || render._rc || render._compatChecked || render._compatWrapped) {
    return;
  }
  if (render.length >= 2) {
    render._compatChecked = true;
    return;
  }
  if (checkCompatEnabled$1("RENDER_FUNCTION", instance)) {
    const wrapped = Component.render = function compatRender() {
      return render.call(this, compatH);
    };
    wrapped._compatWrapped = true;
  }
}
function compatH(type, propsOrChildren, children) {
  if (!type) {
    type = Comment;
  }
  if (typeof type === "string") {
    const t = hyphenate(type);
    if (t === "transition" || t === "transition-group" || t === "keep-alive") {
      type = `__compat__${t}`;
    }
    type = resolveDynamicComponent(type);
  }
  const l = arguments.length;
  const is2ndArgArrayChildren = isArray(propsOrChildren);
  if (l === 2 || is2ndArgArrayChildren) {
    if (isObject(propsOrChildren) && !is2ndArgArrayChildren) {
      if (isVNode(propsOrChildren)) {
        return convertLegacySlots(createVNode(type, null, [propsOrChildren]));
      }
      return convertLegacySlots(
        convertLegacyDirectives(
          createVNode(type, convertLegacyProps(propsOrChildren, type)),
          propsOrChildren
        )
      );
    } else {
      return convertLegacySlots(createVNode(type, null, propsOrChildren));
    }
  } else {
    if (isVNode(children)) {
      children = [children];
    }
    return convertLegacySlots(
      convertLegacyDirectives(
        createVNode(type, convertLegacyProps(propsOrChildren, type), children),
        propsOrChildren
      )
    );
  }
}
const skipLegacyRootLevelProps = /* @__PURE__ */ makeMap(
  "staticStyle,staticClass,directives,model,hook"
);
function convertLegacyProps(legacyProps, type) {
  if (!legacyProps) {
    return null;
  }
  const converted = {};
  for (const key in legacyProps) {
    if (key === "attrs" || key === "domProps" || key === "props") {
      extend(converted, legacyProps[key]);
    } else if (key === "on" || key === "nativeOn") {
      const listeners = legacyProps[key];
      for (const event in listeners) {
        let handlerKey = convertLegacyEventKey(event);
        if (key === "nativeOn")
          handlerKey += `Native`;
        const existing = converted[handlerKey];
        const incoming = listeners[event];
        if (existing !== incoming) {
          if (existing) {
            converted[handlerKey] = [].concat(existing, incoming);
          } else {
            converted[handlerKey] = incoming;
          }
        }
      }
    } else if (!skipLegacyRootLevelProps(key)) {
      converted[key] = legacyProps[key];
    }
  }
  if (legacyProps.staticClass) {
    converted.class = normalizeClass([legacyProps.staticClass, converted.class]);
  }
  if (legacyProps.staticStyle) {
    converted.style = normalizeStyle([legacyProps.staticStyle, converted.style]);
  }
  if (legacyProps.model && isObject(type)) {
    const { prop = "value", event = "input" } = type.model || {};
    converted[prop] = legacyProps.model.value;
    converted[compatModelEventPrefix + event] = legacyProps.model.callback;
  }
  return converted;
}
function convertLegacyEventKey(event) {
  if (event[0] === "&") {
    event = event.slice(1) + "Passive";
  }
  if (event[0] === "~") {
    event = event.slice(1) + "Once";
  }
  if (event[0] === "!") {
    event = event.slice(1) + "Capture";
  }
  return toHandlerKey(event);
}
function convertLegacyDirectives(vnode, props) {
  if (props && props.directives) {
    return withDirectives(
      vnode,
      props.directives.map(({ name, value, arg, modifiers }) => {
        return [
          resolveDirective(name),
          value,
          arg,
          modifiers
        ];
      })
    );
  }
  return vnode;
}
function convertLegacySlots(vnode) {
  const { props, children } = vnode;
  let slots;
  if (vnode.shapeFlag & 6 && isArray(children)) {
    slots = {};
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      const slotName = isVNode(child) && child.props && child.props.slot || "default";
      const slot = slots[slotName] || (slots[slotName] = []);
      if (isVNode(child) && child.type === "template") {
        slot.push(child.children);
      } else {
        slot.push(child);
      }
    }
    if (slots) {
      for (const key in slots) {
        const slotChildren = slots[key];
        slots[key] = () => slotChildren;
        slots[key]._ns = true;
      }
    }
  }
  const scopedSlots = props && props.scopedSlots;
  if (scopedSlots) {
    delete props.scopedSlots;
    if (slots) {
      extend(slots, scopedSlots);
    } else {
      slots = scopedSlots;
    }
  }
  if (slots) {
    normalizeChildren(vnode, slots);
  }
  return vnode;
}
function defineLegacyVNodeProperties(vnode) {
  if (isCompatEnabled$1(
    "RENDER_FUNCTION",
    currentRenderingInstance,
    true
  ) && isCompatEnabled$1(
    "PRIVATE_APIS",
    currentRenderingInstance,
    true
  )) {
    const context = currentRenderingInstance;
    const getInstance = () => vnode.component && vnode.component.proxy;
    let componentOptions;
    Object.defineProperties(vnode, {
      tag: { get: () => vnode.type },
      data: { get: () => vnode.props || {}, set: (p) => vnode.props = p },
      elm: { get: () => vnode.el },
      componentInstance: { get: getInstance },
      child: { get: getInstance },
      text: { get: () => isString(vnode.children) ? vnode.children : null },
      context: { get: () => context && context.proxy },
      componentOptions: {
        get: () => {
          if (vnode.shapeFlag & 4) {
            if (componentOptions) {
              return componentOptions;
            }
            return componentOptions = {
              Ctor: vnode.type,
              propsData: vnode.props,
              children: vnode.children
            };
          }
        }
      }
    });
  }
}

const normalizedFunctionalComponentMap = /* @__PURE__ */ new WeakMap();
const legacySlotProxyHandlers = {
  get(target, key) {
    const slot = target[key];
    return slot && slot();
  }
};
function convertLegacyFunctionalComponent(comp) {
  if (normalizedFunctionalComponentMap.has(comp)) {
    return normalizedFunctionalComponentMap.get(comp);
  }
  const legacyFn = comp.render;
  const Func = (props, ctx) => {
    const instance = getCurrentInstance();
    const legacyCtx = {
      props,
      children: instance.vnode.children || [],
      data: instance.vnode.props || {},
      scopedSlots: ctx.slots,
      parent: instance.parent && instance.parent.proxy,
      slots() {
        return new Proxy(ctx.slots, legacySlotProxyHandlers);
      },
      get listeners() {
        return getCompatListeners(instance);
      },
      get injections() {
        if (comp.inject) {
          const injections = {};
          resolveInjections(comp.inject, injections);
          return injections;
        }
        return {};
      }
    };
    return legacyFn(compatH, legacyCtx);
  };
  Func.props = comp.props;
  Func.displayName = comp.name;
  Func.compatConfig = comp.compatConfig;
  Func.inheritAttrs = false;
  normalizedFunctionalComponentMap.set(comp, Func);
  return Func;
}

function renderList(source, renderItem, cache, index) {
  let ret;
  const cached = cache && cache[index];
  if (isArray(source) || isString(source)) {
    ret = new Array(source.length);
    for (let i = 0, l = source.length; i < l; i++) {
      ret[i] = renderItem(source[i], i, void 0, cached && cached[i]);
    }
  } else if (typeof source === "number") {
    if (false) {}
    ret = new Array(source);
    for (let i = 0; i < source; i++) {
      ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
    }
  } else if (isObject(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(
        source,
        (item, i) => renderItem(item, i, void 0, cached && cached[i])
      );
    } else {
      const keys = Object.keys(source);
      ret = new Array(keys.length);
      for (let i = 0, l = keys.length; i < l; i++) {
        const key = keys[i];
        ret[i] = renderItem(source[key], key, i, cached && cached[i]);
      }
    }
  } else {
    ret = [];
  }
  if (cache) {
    cache[index] = ret;
  }
  return ret;
}

function createSlots(slots, dynamicSlots) {
  for (let i = 0; i < dynamicSlots.length; i++) {
    const slot = dynamicSlots[i];
    if (isArray(slot)) {
      for (let j = 0; j < slot.length; j++) {
        slots[slot[j].name] = slot[j].fn;
      }
    } else if (slot) {
      slots[slot.name] = slot.key ? (...args) => {
        const res = slot.fn(...args);
        if (res)
          res.key = slot.key;
        return res;
      } : slot.fn;
    }
  }
  return slots;
}

function renderSlot(slots, name, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
    if (name !== "default")
      props.name = name;
    return createVNode("slot", props, fallback && fallback());
  }
  let slot = slots[name];
  if (false) {}
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const rendered = createBlock(
    Fragment,
    {
      key: props.key || // slot content array of a dynamic conditional slot may have a branch
      // key attached in the `createSlots` helper, respect that
      validSlotContent && validSlotContent.key || `_${name}`
    },
    validSlotContent || (fallback ? fallback() : []),
    validSlotContent && slots._ === 1 ? 64 : -2
  );
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode(child))
      return true;
    if (child.type === Comment)
      return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}

function toHandlers(obj, preserveCaseIfNecessary) {
  const ret = {};
  if (false) {}
  for (const key in obj) {
    ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : toHandlerKey(key)] = obj[key];
  }
  return ret;
}

function toObject(arr) {
  const res = {};
  for (let i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res;
}
function legacyBindObjectProps(data, _tag, value, _asProp, isSync) {
  if (value && isObject(value)) {
    if (isArray(value)) {
      value = toObject(value);
    }
    for (const key in value) {
      if (isReservedProp(key)) {
        data[key] = value[key];
      } else if (key === "class") {
        data.class = normalizeClass([data.class, value.class]);
      } else if (key === "style") {
        data.style = normalizeClass([data.style, value.style]);
      } else {
        const attrs = data.attrs || (data.attrs = {});
        const camelizedKey = camelize(key);
        const hyphenatedKey = hyphenate(key);
        if (!(camelizedKey in attrs) && !(hyphenatedKey in attrs)) {
          attrs[key] = value[key];
          if (isSync) {
            const on = data.on || (data.on = {});
            on[`update:${key}`] = function($event) {
              value[key] = $event;
            };
          }
        }
      }
    }
  }
  return data;
}
function legacyBindObjectListeners(props, listeners) {
  return mergeProps(props, toHandlers(listeners));
}
function legacyRenderSlot(instance, name, fallback, props, bindObject) {
  if (bindObject) {
    props = mergeProps(props, bindObject);
  }
  return renderSlot(instance.slots, name, props, fallback && (() => fallback));
}
function legacyresolveScopedSlots(fns, raw, hasDynamicKeys) {
  return createSlots(
    raw || { $stable: !hasDynamicKeys },
    mapKeyToName(fns)
  );
}
function mapKeyToName(slots) {
  for (let i = 0; i < slots.length; i++) {
    const fn = slots[i];
    if (fn) {
      if (isArray(fn)) {
        mapKeyToName(fn);
      } else {
        fn.name = fn.key || "default";
      }
    }
  }
  return slots;
}
const staticCacheMap = /* @__PURE__ */ new WeakMap();
function legacyRenderStatic(instance, index) {
  let cache = staticCacheMap.get(instance);
  if (!cache) {
    staticCacheMap.set(instance, cache = []);
  }
  if (cache[index]) {
    return cache[index];
  }
  const fn = instance.type.staticRenderFns[index];
  const ctx = instance.proxy;
  return cache[index] = fn.call(ctx, null, ctx);
}
function legacyCheckKeyCodes(instance, eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
  const config = instance.appContext.config;
  const configKeyCodes = config.keyCodes || {};
  const mappedKeyCode = configKeyCodes[key] || builtInKeyCode;
  if (builtInKeyName && eventKeyName && !configKeyCodes[key]) {
    return isKeyNotMatch(builtInKeyName, eventKeyName);
  } else if (mappedKeyCode) {
    return isKeyNotMatch(mappedKeyCode, eventKeyCode);
  } else if (eventKeyName) {
    return hyphenate(eventKeyName) !== key;
  }
}
function isKeyNotMatch(expect, actual) {
  if (isArray(expect)) {
    return !expect.includes(actual);
  } else {
    return expect !== actual;
  }
}
function legacyMarkOnce(tree) {
  return tree;
}
function legacyBindDynamicKeys(props, values) {
  for (let i = 0; i < values.length; i += 2) {
    const key = values[i];
    if (typeof key === "string" && key) {
      props[values[i]] = values[i + 1];
    }
  }
  return props;
}
function legacyPrependModifier(value, symbol) {
  return typeof value === "string" ? symbol + value : value;
}

function installCompatInstanceProperties(map) {
  const set = (target, key, val) => {
    target[key] = val;
    return target[key];
  };
  const del = (target, key) => {
    delete target[key];
  };
  extend(map, {
    $set: (i) => {
      assertCompatEnabled("INSTANCE_SET", i);
      return set;
    },
    $delete: (i) => {
      assertCompatEnabled("INSTANCE_DELETE", i);
      return del;
    },
    $mount: (i) => {
      assertCompatEnabled(
        "GLOBAL_MOUNT",
        null
      );
      return i.ctx._compat_mount || NOOP;
    },
    $destroy: (i) => {
      assertCompatEnabled("INSTANCE_DESTROY", i);
      return i.ctx._compat_destroy || NOOP;
    },
    // overrides existing accessor
    $slots: (i) => {
      if (isCompatEnabled$1("RENDER_FUNCTION", i) && i.render && i.render._compatWrapped) {
        return new Proxy(i.slots, legacySlotProxyHandlers);
      }
      return  false ? 0 : i.slots;
    },
    $scopedSlots: (i) => {
      assertCompatEnabled("INSTANCE_SCOPED_SLOTS", i);
      const res = {};
      for (const key in i.slots) {
        const fn = i.slots[key];
        if (!fn._ns) {
          res[key] = fn;
        }
      }
      return res;
    },
    $on: (i) => on.bind(null, i),
    $once: (i) => once.bind(null, i),
    $off: (i) => off.bind(null, i),
    $children: getCompatChildren,
    $listeners: getCompatListeners
  });
  if (isCompatEnabled$1("PRIVATE_APIS", null)) {
    extend(map, {
      // needed by many libs / render fns
      $vnode: (i) => i.vnode,
      // inject additional properties into $options for compat
      // e.g. vuex needs this.$options.parent
      $options: (i) => {
        const res = extend({}, resolveMergedOptions(i));
        res.parent = i.proxy.$parent;
        res.propsData = i.vnode.props;
        return res;
      },
      // some private properties that are likely accessed...
      _self: (i) => i.proxy,
      _uid: (i) => i.uid,
      _data: (i) => i.data,
      _isMounted: (i) => i.isMounted,
      _isDestroyed: (i) => i.isUnmounted,
      // v2 render helpers
      $createElement: () => compatH,
      _c: () => compatH,
      _o: () => legacyMarkOnce,
      _n: () => looseToNumber,
      _s: () => toDisplayString,
      _l: () => renderList,
      _t: (i) => legacyRenderSlot.bind(null, i),
      _q: () => looseEqual,
      _i: () => looseIndexOf,
      _m: (i) => legacyRenderStatic.bind(null, i),
      _f: () => resolveFilter$1,
      _k: (i) => legacyCheckKeyCodes.bind(null, i),
      _b: () => legacyBindObjectProps,
      _v: () => createTextVNode,
      _e: () => createCommentVNode,
      _u: () => legacyresolveScopedSlots,
      _g: () => legacyBindObjectListeners,
      _d: () => legacyBindDynamicKeys,
      _p: () => legacyPrependModifier
    });
  }
}

const getPublicInstance = (i) => {
  if (!i)
    return null;
  if (isStatefulComponent(i))
    return getExposeProxy(i) || i.proxy;
  return getPublicInstance(i.parent);
};
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) =>  false ? 0 : i.props,
    $attrs: (i) =>  false ? 0 : i.attrs,
    $slots: (i) =>  false ? 0 : i.slots,
    $refs: (i) =>  false ? 0 : i.refs,
    $parent: (i) => getPublicInstance(i.parent),
    $root: (i) => getPublicInstance(i.root),
    $emit: (i) => i.emit,
    $options: (i) => __VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type,
    $forceUpdate: (i) => i.f || (i.f = () => {
      i.effect.dirty = true;
      queueJob(i.update);
    }),
    $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: (i) => __VUE_OPTIONS_API__ ? instanceWatch.bind(i) : NOOP
  })
);
{
  installCompatInstanceProperties(publicPropertiesMap);
}
const isReservedPrefix = (key) => key === "_" || key === "$";
const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
    if (false) {}
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1 /* SETUP */:
            return setupState[key];
          case 2 /* DATA */:
            return data[key];
          case 4 /* CONTEXT */:
            return ctx[key];
          case 3 /* PROPS */:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1 /* SETUP */;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        accessCache[key] = 2 /* DATA */;
        return data[key];
      } else if (
        // only cache other properties when instance has declared (thus stable)
        // props
        (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
      ) {
        accessCache[key] = 3 /* PROPS */;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4 /* CONTEXT */;
        return ctx[key];
      } else if (!__VUE_OPTIONS_API__ || shouldCacheAccess) {
        accessCache[key] = 0 /* OTHER */;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance, "get", key);
         false && 0;
      } else if (false) {}
      return publicGetter(instance);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
      accessCache[key] = 4 /* CONTEXT */;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
    ) {
      {
        const desc = Object.getOwnPropertyDescriptor(globalProperties, key);
        if (desc.get) {
          return desc.get.call(instance.proxy);
        } else {
          const val = globalProperties[key];
          return isFunction(val) ? Object.assign(val.bind(instance.proxy), val) : val;
        }
      }
    } else if (false) {}
  },
  set({ _: instance }, key, value) {
    const { data, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (false) {} else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
      data[key] = value;
      return true;
    } else if (hasOwn(instance.props, key)) {
       false && 0;
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
       false && 0;
      return false;
    } else {
      if (false) {} else {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({
    _: { data, setupState, accessCache, ctx, appContext, propsOptions }
  }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
if (false) {}
const RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ extend(
  {},
  PublicInstanceProxyHandlers,
  {
    get(target, key) {
      if (key === Symbol.unscopables) {
        return;
      }
      return PublicInstanceProxyHandlers.get(target, key, target);
    },
    has(_, key) {
      const has = key[0] !== "_" && !isGloballyAllowed(key);
      if (false) {}
      return has;
    }
  }
);
function createDevRenderContext(instance) {
  const target = {};
  Object.defineProperty(target, `_`, {
    configurable: true,
    enumerable: false,
    get: () => instance
  });
  Object.keys(publicPropertiesMap).forEach((key) => {
    Object.defineProperty(target, key, {
      configurable: true,
      enumerable: false,
      get: () => publicPropertiesMap[key](instance),
      // intercepted by the proxy so no need for implementation,
      // but needed to prevent set errors
      set: NOOP
    });
  });
  return target;
}
function exposePropsOnRenderContext(instance) {
  const {
    ctx,
    propsOptions: [propsOptions]
  } = instance;
  if (propsOptions) {
    Object.keys(propsOptions).forEach((key) => {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => instance.props[key],
        set: NOOP
      });
    });
  }
}
function exposeSetupStateOnRenderContext(instance) {
  const { ctx, setupState } = instance;
  Object.keys(toRaw(setupState)).forEach((key) => {
    if (!setupState.__isScriptSetup) {
      if (isReservedPrefix(key[0])) {
        warn$1(
          `setup() return property ${JSON.stringify(
            key
          )} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
        );
        return;
      }
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => setupState[key],
        set: NOOP
      });
    }
  });
}

function deepMergeData(to, from) {
  for (const key in from) {
    const toVal = to[key];
    const fromVal = from[key];
    if (key in to && isPlainObject(toVal) && isPlainObject(fromVal)) {
       false && 0;
      deepMergeData(toVal, fromVal);
    } else {
      to[key] = fromVal;
    }
  }
  return to;
}

const warnRuntimeUsage = (method) => warn$1(
  `${method}() is a compiler-hint helper that is only usable inside <script setup> of a single file component. Its arguments should be compiled away and passing it at runtime has no effect.`
);
function defineProps() {
  if (false) {}
  return null;
}
function defineEmits() {
  if (false) {}
  return null;
}
function defineExpose(exposed) {
  if (false) {}
}
function defineOptions(options) {
  if (false) {}
}
function defineSlots() {
  if (false) {}
  return null;
}
function defineModel() {
  if (false) {}
}
function withDefaults(props, defaults) {
  if (false) {}
  return null;
}
function useSlots() {
  return getContext().slots;
}
function useAttrs() {
  return getContext().attrs;
}
function getContext() {
  const i = getCurrentInstance();
  if (false) {}
  return i.setupContext || (i.setupContext = createSetupContext(i));
}
function normalizePropsOrEmits(props) {
  return isArray(props) ? props.reduce(
    (normalized, p) => (normalized[p] = null, normalized),
    {}
  ) : props;
}
function mergeDefaults(raw, defaults) {
  const props = normalizePropsOrEmits(raw);
  for (const key in defaults) {
    if (key.startsWith("__skip"))
      continue;
    let opt = props[key];
    if (opt) {
      if (isArray(opt) || isFunction(opt)) {
        opt = props[key] = { type: opt, default: defaults[key] };
      } else {
        opt.default = defaults[key];
      }
    } else if (opt === null) {
      opt = props[key] = { default: defaults[key] };
    } else if (false) {}
    if (opt && defaults[`__skip_${key}`]) {
      opt.skipFactory = true;
    }
  }
  return props;
}
function mergeModels(a, b) {
  if (!a || !b)
    return a || b;
  if (isArray(a) && isArray(b))
    return a.concat(b);
  return extend({}, normalizePropsOrEmits(a), normalizePropsOrEmits(b));
}
function createPropsRestProxy(props, excludedKeys) {
  const ret = {};
  for (const key in props) {
    if (!excludedKeys.includes(key)) {
      Object.defineProperty(ret, key, {
        enumerable: true,
        get: () => props[key]
      });
    }
  }
  return ret;
}
function withAsyncContext(getAwaitable) {
  const ctx = getCurrentInstance();
  if (false) {}
  let awaitable = getAwaitable();
  unsetCurrentInstance();
  if (isPromise(awaitable)) {
    awaitable = awaitable.catch((e) => {
      setCurrentInstance(ctx);
      throw e;
    });
  }
  return [awaitable, () => setCurrentInstance(ctx)];
}

function createDuplicateChecker() {
  const cache = /* @__PURE__ */ Object.create(null);
  return (type, key) => {
    if (cache[key]) {
      warn$1(`${type} property "${key}" is already defined in ${cache[key]}.`);
    } else {
      cache[key] = type;
    }
  };
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook$1(options.beforeCreate, instance, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties =  false ? 0 : null;
  if (false) {}
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction(methodHandler)) {
        if (false) {} else {
          ctx[key] = methodHandler.bind(publicThis);
        }
        if (false) {}
      } else if (false) {}
    }
  }
  if (dataOptions) {
    if (false) {}
    const data = dataOptions.call(publicThis, publicThis);
    if (false) {}
    if (!isObject(data)) {
       false && 0;
    } else {
      instance.data = reactive(data);
      if (false) {}
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get = isFunction(opt) ? opt.bind(publicThis, publicThis) : isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      if (false) {}
      const set = !isFunction(opt) && isFunction(opt.set) ? opt.set.bind(publicThis) :  false ? 0 : NOOP;
      const c = computed({
        get,
        set
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c.value,
        set: (v) => c.value = v
      });
      if (false) {}
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook$1(created, instance, "c");
  }
  function registerLifecycleHook(register, hook) {
    if (isArray(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  {
    if (beforeDestroy && softAssertCompatEnabled("OPTIONS_BEFORE_DESTROY", instance)) {
      registerLifecycleHook(onBeforeUnmount, beforeDestroy);
    }
    if (destroyed && softAssertCompatEnabled("OPTIONS_DESTROYED", instance)) {
      registerLifecycleHook(onUnmounted, destroyed);
    }
  }
  if (isArray(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render && instance.render === NOOP) {
    instance.render = render;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components)
    instance.components = components;
  if (directives)
    instance.directives = directives;
  if (filters && isCompatEnabled$1("FILTERS", instance)) {
    instance.filters = filters;
  }
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
  if (isArray(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject(opt)) {
      if ("default" in opt) {
        injected = inject(
          opt.from || key,
          opt.default,
          true
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => injected.value,
        set: (v) => injected.value = v
      });
    } else {
      ctx[key] = injected;
    }
    if (false) {}
  }
}
function callHook$1(hook, instance, type) {
  callWithAsyncErrorHandling(
    isArray(hook) ? hook.map((h) => h.bind(instance.proxy)) : hook.bind(instance.proxy),
    instance,
    type
  );
}
function createWatcher(raw, ctx, publicThis, key) {
  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString(raw)) {
    const handler = ctx[raw];
    if (isFunction(handler)) {
      watch(getter, handler);
    } else if (false) {}
  } else if (isFunction(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject(raw)) {
    if (isArray(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler = isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction(handler)) {
        watch(getter, handler, raw);
      } else if (false) {}
    }
  } else if (false) {}
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache,
    config: { optionMergeStrategies }
  } = instance.appContext;
  const cached = cache.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    if (isCompatEnabled$1("PRIVATE_APIS", instance)) {
      resolved = extend({}, base);
      resolved.parent = instance.parent && instance.parent.proxy;
      resolved.propsData = instance.vnode.props;
    } else {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(
        (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
      );
    }
    mergeOptions(resolved, base, optionMergeStrategies);
  }
  if (isObject(base)) {
    cache.set(base, resolved);
  }
  return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
  if (isFunction(from)) {
    from = from.options;
  }
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(
      (m) => mergeOptions(to, m, strats, true)
    );
  }
  for (const key in from) {
    if (asMixin && key === "expose") {
       false && 0;
    } else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray$1,
  created: mergeAsArray$1,
  beforeMount: mergeAsArray$1,
  mounted: mergeAsArray$1,
  beforeUpdate: mergeAsArray$1,
  updated: mergeAsArray$1,
  beforeDestroy: mergeAsArray$1,
  beforeUnmount: mergeAsArray$1,
  destroyed: mergeAsArray$1,
  unmounted: mergeAsArray$1,
  activated: mergeAsArray$1,
  deactivated: mergeAsArray$1,
  errorCaptured: mergeAsArray$1,
  serverPrefetch: mergeAsArray$1,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
{
  internalOptionMergeStrats.filters = mergeObjectOptions;
}
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return (isCompatEnabled$1("OPTIONS_DATA_MERGE", null) ? deepMergeData : extend)(
      isFunction(to) ? to.call(this, this) : to,
      isFunction(from) ? from.call(this, this) : from
    );
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray$1(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? extend(/* @__PURE__ */ Object.create(null), to, from) : from;
}
function mergeEmitsOrPropsOptions(to, from) {
  if (to) {
    if (isArray(to) && isArray(from)) {
      return [.../* @__PURE__ */ new Set([...to, ...from])];
    }
    return extend(
      /* @__PURE__ */ Object.create(null),
      normalizePropsOrEmits(to),
      normalizePropsOrEmits(from != null ? from : {})
    );
  } else {
    return from;
  }
}
function mergeWatchOptions(to, from) {
  if (!to)
    return from;
  if (!from)
    return to;
  const merged = extend(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray$1(to[key], from[key]);
  }
  return merged;
}

function installLegacyConfigWarnings(config) {
  const legacyConfigOptions = {
    silent: "CONFIG_SILENT",
    devtools: "CONFIG_DEVTOOLS",
    ignoredElements: "CONFIG_IGNORED_ELEMENTS",
    keyCodes: "CONFIG_KEY_CODES",
    productionTip: "CONFIG_PRODUCTION_TIP"
  };
  Object.keys(legacyConfigOptions).forEach((key) => {
    let val = config[key];
    Object.defineProperty(config, key, {
      enumerable: true,
      get() {
        return val;
      },
      set(newVal) {
        if (!isCopyingConfig) {
          warnDeprecation$1(legacyConfigOptions[key], null);
        }
        val = newVal;
      }
    });
  });
}
function installLegacyOptionMergeStrats(config) {
  config.optionMergeStrategies = new Proxy({}, {
    get(target, key) {
      if (key in target) {
        return target[key];
      }
      if (key in internalOptionMergeStrats && softAssertCompatEnabled(
        "CONFIG_OPTION_MERGE_STRATS",
        null
      )) {
        return internalOptionMergeStrats[key];
      }
    }
  });
}

let isCopyingConfig = false;
let singletonApp;
let singletonCtor;
function createCompatVue$1(createApp, createSingletonApp) {
  singletonApp = createSingletonApp({});
  const Vue = singletonCtor = function Vue2(options = {}) {
    return createCompatApp(options, Vue2);
  };
  function createCompatApp(options = {}, Ctor) {
    assertCompatEnabled("GLOBAL_MOUNT", null);
    const { data } = options;
    if (data && !isFunction(data) && softAssertCompatEnabled("OPTIONS_DATA_FN", null)) {
      options.data = () => data;
    }
    const app = createApp(options);
    if (Ctor !== Vue) {
      applySingletonPrototype(app, Ctor);
    }
    const vm = app._createRoot(options);
    if (options.el) {
      return vm.$mount(options.el);
    } else {
      return vm;
    }
  }
  Vue.version = `2.6.14-compat:${"3.4.21"}`;
  Vue.config = singletonApp.config;
  Vue.use = (p, ...options) => {
    if (p && isFunction(p.install)) {
      p.install(Vue, ...options);
    } else if (isFunction(p)) {
      p(Vue, ...options);
    }
    return Vue;
  };
  Vue.mixin = (m) => {
    singletonApp.mixin(m);
    return Vue;
  };
  Vue.component = (name, comp) => {
    if (comp) {
      singletonApp.component(name, comp);
      return Vue;
    } else {
      return singletonApp.component(name);
    }
  };
  Vue.directive = (name, dir) => {
    if (dir) {
      singletonApp.directive(name, dir);
      return Vue;
    } else {
      return singletonApp.directive(name);
    }
  };
  Vue.options = { _base: Vue };
  let cid = 1;
  Vue.cid = cid;
  Vue.nextTick = nextTick;
  const extendCache = /* @__PURE__ */ new WeakMap();
  function extendCtor(extendOptions = {}) {
    assertCompatEnabled("GLOBAL_EXTEND", null);
    if (isFunction(extendOptions)) {
      extendOptions = extendOptions.options;
    }
    if (extendCache.has(extendOptions)) {
      return extendCache.get(extendOptions);
    }
    const Super = this;
    function SubVue(inlineOptions) {
      if (!inlineOptions) {
        return createCompatApp(SubVue.options, SubVue);
      } else {
        return createCompatApp(
          mergeOptions(
            extend({}, SubVue.options),
            inlineOptions,
            internalOptionMergeStrats
          ),
          SubVue
        );
      }
    }
    SubVue.super = Super;
    SubVue.prototype = Object.create(Vue.prototype);
    SubVue.prototype.constructor = SubVue;
    const mergeBase = {};
    for (const key in Super.options) {
      const superValue = Super.options[key];
      mergeBase[key] = isArray(superValue) ? superValue.slice() : isObject(superValue) ? extend(/* @__PURE__ */ Object.create(null), superValue) : superValue;
    }
    SubVue.options = mergeOptions(
      mergeBase,
      extendOptions,
      internalOptionMergeStrats
    );
    SubVue.options._base = SubVue;
    SubVue.extend = extendCtor.bind(SubVue);
    SubVue.mixin = Super.mixin;
    SubVue.use = Super.use;
    SubVue.cid = ++cid;
    extendCache.set(extendOptions, SubVue);
    return SubVue;
  }
  Vue.extend = extendCtor.bind(Vue);
  Vue.set = (target, key, value) => {
    assertCompatEnabled("GLOBAL_SET", null);
    target[key] = value;
  };
  Vue.delete = (target, key) => {
    assertCompatEnabled("GLOBAL_DELETE", null);
    delete target[key];
  };
  Vue.observable = (target) => {
    assertCompatEnabled("GLOBAL_OBSERVABLE", null);
    return reactive(target);
  };
  Vue.filter = (name, filter) => {
    if (filter) {
      singletonApp.filter(name, filter);
      return Vue;
    } else {
      return singletonApp.filter(name);
    }
  };
  const util = {
    warn:  false ? 0 : NOOP,
    extend,
    mergeOptions: (parent, child, vm) => mergeOptions(
      parent,
      child,
      vm ? void 0 : internalOptionMergeStrats
    ),
    defineReactive
  };
  Object.defineProperty(Vue, "util", {
    get() {
      assertCompatEnabled("GLOBAL_PRIVATE_UTIL", null);
      return util;
    }
  });
  Vue.configureCompat = configureCompat$1;
  return Vue;
}
function installAppCompatProperties(app, context, render) {
  installFilterMethod(app, context);
  installLegacyOptionMergeStrats(app.config);
  if (!singletonApp) {
    return;
  }
  installCompatMount(app, context, render);
  installLegacyAPIs(app);
  applySingletonAppMutations(app);
  if (false)
    {}
}
function installFilterMethod(app, context) {
  context.filters = {};
  app.filter = (name, filter) => {
    assertCompatEnabled("FILTERS", null);
    if (!filter) {
      return context.filters[name];
    }
    if (false) {}
    context.filters[name] = filter;
    return app;
  };
}
function installLegacyAPIs(app) {
  Object.defineProperties(app, {
    // so that app.use() can work with legacy plugins that extend prototypes
    prototype: {
      get() {
         false && 0;
        return app.config.globalProperties;
      }
    },
    nextTick: { value: nextTick },
    extend: { value: singletonCtor.extend },
    set: { value: singletonCtor.set },
    delete: { value: singletonCtor.delete },
    observable: { value: singletonCtor.observable },
    util: {
      get() {
        return singletonCtor.util;
      }
    }
  });
}
function applySingletonAppMutations(app) {
  app._context.mixins = [...singletonApp._context.mixins];
  ["components", "directives", "filters"].forEach((key) => {
    app._context[key] = Object.create(singletonApp._context[key]);
  });
  isCopyingConfig = true;
  for (const key in singletonApp.config) {
    if (key === "isNativeTag")
      continue;
    if (isRuntimeOnly() && (key === "isCustomElement" || key === "compilerOptions")) {
      continue;
    }
    const val = singletonApp.config[key];
    app.config[key] = isObject(val) ? Object.create(val) : val;
    if (key === "ignoredElements" && isCompatEnabled$1("CONFIG_IGNORED_ELEMENTS", null) && !isRuntimeOnly() && isArray(val)) {
      app.config.compilerOptions.isCustomElement = (tag) => {
        return val.some((v) => isString(v) ? v === tag : v.test(tag));
      };
    }
  }
  isCopyingConfig = false;
  applySingletonPrototype(app, singletonCtor);
}
function applySingletonPrototype(app, Ctor) {
  const enabled = isCompatEnabled$1("GLOBAL_PROTOTYPE", null);
  if (enabled) {
    app.config.globalProperties = Object.create(Ctor.prototype);
  }
  let hasPrototypeAugmentations = false;
  const descriptors = Object.getOwnPropertyDescriptors(Ctor.prototype);
  for (const key in descriptors) {
    if (key !== "constructor") {
      hasPrototypeAugmentations = true;
      if (enabled) {
        Object.defineProperty(
          app.config.globalProperties,
          key,
          descriptors[key]
        );
      }
    }
  }
  if (false) {}
}
function installCompatMount(app, context, render) {
  let isMounted = false;
  app._createRoot = (options) => {
    const component = app._component;
    const vnode = createVNode(component, options.propsData || null);
    vnode.appContext = context;
    const hasNoRender = !isFunction(component) && !component.render && !component.template;
    const emptyRender = () => {
    };
    const instance = createComponentInstance(vnode, null, null);
    if (hasNoRender) {
      instance.render = emptyRender;
    }
    setupComponent(instance);
    vnode.component = instance;
    vnode.isCompatRoot = true;
    instance.ctx._compat_mount = (selectorOrEl) => {
      if (isMounted) {
         false && 0;
        return;
      }
      let container;
      if (typeof selectorOrEl === "string") {
        const result = document.querySelector(selectorOrEl);
        if (!result) {
           false && 0;
          return;
        }
        container = result;
      } else {
        container = selectorOrEl || document.createElement("div");
      }
      let namespace;
      if (container instanceof SVGElement)
        namespace = "svg";
      else if (typeof MathMLElement === "function" && container instanceof MathMLElement)
        namespace = "mathml";
      if (false) {}
      if (hasNoRender && instance.render === emptyRender) {
        if (false) {}
        instance.render = null;
        component.template = container.innerHTML;
        finishComponentSetup(
          instance,
          false,
          true
          /* skip options */
        );
      }
      container.innerHTML = "";
      render(vnode, container, namespace);
      if (container instanceof Element) {
        container.removeAttribute("v-cloak");
        container.setAttribute("data-v-app", "");
      }
      isMounted = true;
      app._container = container;
      container.__vue_app__ = app;
      if ( false || __VUE_PROD_DEVTOOLS__) {
        devtoolsInitApp(app, version);
      }
      return instance.proxy;
    };
    instance.ctx._compat_destroy = () => {
      if (isMounted) {
        render(null, app._container);
        if ( false || __VUE_PROD_DEVTOOLS__) {
          devtoolsUnmountApp(app);
        }
        delete app._container.__vue_app__;
      } else {
        const { bum, scope, um } = instance;
        if (bum) {
          invokeArrayFns(bum);
        }
        if (isCompatEnabled$1("INSTANCE_EVENT_HOOKS", instance)) {
          instance.emit("hook:beforeDestroy");
        }
        if (scope) {
          scope.stop();
        }
        if (um) {
          invokeArrayFns(um);
        }
        if (isCompatEnabled$1("INSTANCE_EVENT_HOOKS", instance)) {
          instance.emit("hook:destroyed");
        }
      }
    };
    return instance.proxy;
  };
}
const methodsToPatch = [
  "push",
  "pop",
  "shift",
  "unshift",
  "splice",
  "sort",
  "reverse"
];
const patched = /* @__PURE__ */ new WeakSet();
function defineReactive(obj, key, val) {
  if (isObject(val) && !isReactive(val) && !patched.has(val)) {
    const reactiveVal = reactive(val);
    if (isArray(val)) {
      methodsToPatch.forEach((m) => {
        val[m] = (...args) => {
          Array.prototype[m].call(reactiveVal, ...args);
        };
      });
    } else {
      Object.keys(val).forEach((key2) => {
        try {
          defineReactiveSimple(val, key2, val[key2]);
        } catch (e) {
        }
      });
    }
  }
  const i = obj.$;
  if (i && obj === i.proxy) {
    defineReactiveSimple(i.ctx, key, val);
    i.accessCache = /* @__PURE__ */ Object.create(null);
  } else if (isReactive(obj)) {
    obj[key] = val;
  } else {
    defineReactiveSimple(obj, key, val);
  }
}
function defineReactiveSimple(obj, key, val) {
  val = isObject(val) ? reactive(val) : val;
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get() {
      track(obj, "get", key);
      return val;
    },
    set(newVal) {
      val = isObject(newVal) ? reactive(newVal) : newVal;
      trigger(obj, "set", key, newVal);
    }
  });
}

function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render, hydrate) {
  return function createApp(rootComponent, rootProps = null) {
    if (!isFunction(rootComponent)) {
      rootComponent = extend({}, rootComponent);
    }
    if (rootProps != null && !isObject(rootProps)) {
       false && 0;
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new WeakSet();
    let isMounted = false;
    const app = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version,
      get config() {
        return context.config;
      },
      set config(v) {
        if (false) {}
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin)) {
           false && 0;
        } else if (plugin && isFunction(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app, ...options);
        } else if (isFunction(plugin)) {
          installedPlugins.add(plugin);
          plugin(app, ...options);
        } else if (false) {}
        return app;
      },
      mixin(mixin) {
        if (__VUE_OPTIONS_API__) {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          } else if (false) {}
        } else if (false) {}
        return app;
      },
      component(name, component) {
        if (false) {}
        if (!component) {
          return context.components[name];
        }
        if (false) {}
        context.components[name] = component;
        return app;
      },
      directive(name, directive) {
        if (false) {}
        if (!directive) {
          return context.directives[name];
        }
        if (false) {}
        context.directives[name] = directive;
        return app;
      },
      mount(rootContainer, isHydrate, namespace) {
        if (!isMounted) {
          if (false) {}
          const vnode = createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (namespace === true) {
            namespace = "svg";
          } else if (namespace === false) {
            namespace = void 0;
          }
          if (false) {}
          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render(vnode, rootContainer, namespace);
          }
          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;
          if ( false || __VUE_PROD_DEVTOOLS__) {
            app._instance = vnode.component;
            devtoolsInitApp(app, version);
          }
          return getExposeProxy(vnode.component) || vnode.component.proxy;
        } else if (false) {}
      },
      unmount() {
        if (isMounted) {
          render(null, app._container);
          if ( false || __VUE_PROD_DEVTOOLS__) {
            app._instance = null;
            devtoolsUnmountApp(app);
          }
          delete app._container.__vue_app__;
        } else if (false) {}
      },
      provide(key, value) {
        if (false) {}
        context.provides[key] = value;
        return app;
      },
      runWithContext(fn) {
        const lastApp = currentApp;
        currentApp = app;
        try {
          return fn();
        } finally {
          currentApp = lastApp;
        }
      }
    };
    {
      installAppCompatProperties(app, context, render);
    }
    return app;
  };
}
let currentApp = null;

function provide(key, value) {
  if (!currentInstance) {
    if (false) {}
  } else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance || currentApp) {
    const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
    } else if (false) {}
  } else if (false) {}
}
function hasInjectionContext() {
  return !!(currentInstance || currentRenderingInstance || currentApp);
}

function createPropsDefaultThis(instance, rawProps, propKey) {
  return new Proxy(
    {},
    {
      get(_, key) {
         false && 0;
        if (key === "$options") {
          return resolveMergedOptions(instance);
        }
        if (key in rawProps) {
          return rawProps[key];
        }
        const injections = instance.type.inject;
        if (injections) {
          if (isArray(injections)) {
            if (injections.includes(key)) {
              return inject(key);
            }
          } else if (key in injections) {
            return inject(key);
          }
        }
      }
    }
  );
}

function shouldSkipAttr(key, instance) {
  if (key === "is") {
    return true;
  }
  if ((key === "class" || key === "style") && isCompatEnabled$1("INSTANCE_ATTRS_CLASS_STYLE", instance)) {
    return true;
  }
  if (isOn(key) && isCompatEnabled$1("INSTANCE_LISTENERS", instance)) {
    return true;
  }
  if (key.startsWith("routerView") || key === "registerRouteInstance") {
    return true;
  }
  return false;
}

function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = {};
  def(attrs, InternalObjectKey, 1);
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (false) {}
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function isInHmrContext(instance) {
  while (instance) {
    if (instance.type.__hmrId)
      return true;
    instance = instance.parent;
  }
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const {
    props,
    attrs,
    vnode: { patchFlag }
  } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
     true && (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(
              options,
              rawCurrentProps,
              camelizedKey,
              value,
              instance,
              false
            );
          }
        } else {
          {
            if (isOn(key) && key.endsWith("Native")) {
              key = key.slice(0, -6);
            } else if (shouldSkipAttr(key, instance)) {
              continue;
            }
          }
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn(rawProps, key) && !hasOwn(rawProps, key + "Native")) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance, "set", "$attrs");
  }
  if (false) {}
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      {
        if (key.startsWith("onHook:")) {
          softAssertCompatEnabled(
            "INSTANCE_EVENT_HOOKS",
            instance,
            key.slice(2).toLowerCase()
          );
        }
        if (key === "inline-template") {
          continue;
        }
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        {
          if (isOn(key) && key.endsWith("Native")) {
            key = key.slice(0, -6);
          } else if (shouldSkipAttr(key, instance)) {
            continue;
          }
        }
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(
        options,
        rawCurrentProps,
        key,
        castValues[key],
        instance,
        !hasOwn(castValues, key)
      );
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && !opt.skipFactory && isFunction(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          const reset = setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(
            isCompatEnabled$1("PROPS_DEFAULT_THIS", instance) ? createPropsDefaultThis(instance, props, key) : null,
            props
          );
          reset();
        }
      } else {
        value = defaultValue;
      }
    }
    if (opt[0 /* shouldCast */]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[1 /* shouldCastTrue */] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (__VUE_OPTIONS_API__ && !isFunction(comp)) {
    const extendProps = (raw2) => {
      if (isFunction(raw2)) {
        raw2 = raw2.options;
      }
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw2, appContext, true);
      extend(normalized, props);
      if (keys)
        needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject(comp)) {
      cache.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray(raw)) {
    for (let i = 0; i < raw.length; i++) {
      if (false) {}
      const normalizedKey = camelize(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    if (false) {}
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray(opt) || isFunction(opt) ? { type: opt } : extend({}, opt);
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[0 /* shouldCast */] = booleanIndex > -1;
          prop[1 /* shouldCastTrue */] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject(comp)) {
    cache.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$" && !isReservedProp(key)) {
    return true;
  } else if (false) {}
  return false;
}
function getType(ctor) {
  if (ctor === null) {
    return "null";
  }
  if (typeof ctor === "function") {
    return ctor.name || "";
  } else if (typeof ctor === "object") {
    const name = ctor.constructor && ctor.constructor.name;
    return name || "";
  }
  return "";
}
function isSameType(a, b) {
  return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
  if (isArray(expectedTypes)) {
    return expectedTypes.findIndex((t) => isSameType(t, type));
  } else if (isFunction(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  return -1;
}
function validateProps(rawProps, props, instance) {
  const resolvedValues = toRaw(props);
  const options = instance.propsOptions[0];
  for (const key in options) {
    let opt = options[key];
    if (opt == null)
      continue;
    validateProp(
      key,
      resolvedValues[key],
      opt,
       false ? 0 : resolvedValues,
      !hasOwn(rawProps, key) && !hasOwn(rawProps, hyphenate(key))
    );
  }
}
function validateProp(name, value, prop, props, isAbsent) {
  const { type, required, validator, skipCheck } = prop;
  if (required && isAbsent) {
    warn$1('Missing required prop: "' + name + '"');
    return;
  }
  if (value == null && !required) {
    return;
  }
  if (type != null && type !== true && !skipCheck) {
    let isValid = false;
    const types = isArray(type) ? type : [type];
    const expectedTypes = [];
    for (let i = 0; i < types.length && !isValid; i++) {
      const { valid, expectedType } = assertType(value, types[i]);
      expectedTypes.push(expectedType || "");
      isValid = valid;
    }
    if (!isValid) {
      warn$1(getInvalidTypeMessage(name, value, expectedTypes));
      return;
    }
  }
  if (validator && !validator(value, props)) {
    warn$1('Invalid prop: custom validator check failed for prop "' + name + '".');
  }
}
const isSimpleType = /* @__PURE__ */ (/* unused pure expression or super */ null && (makeMap(
  "String,Number,Boolean,Function,Symbol,BigInt"
)));
function assertType(value, type) {
  let valid;
  const expectedType = getType(type);
  if (isSimpleType(expectedType)) {
    const t = typeof value;
    valid = t === expectedType.toLowerCase();
    if (!valid && t === "object") {
      valid = value instanceof type;
    }
  } else if (expectedType === "Object") {
    valid = isObject(value);
  } else if (expectedType === "Array") {
    valid = isArray(value);
  } else if (expectedType === "null") {
    valid = value === null;
  } else {
    valid = value instanceof type;
  }
  return {
    valid,
    expectedType
  };
}
function getInvalidTypeMessage(name, value, expectedTypes) {
  if (expectedTypes.length === 0) {
    return `Prop type [] for prop "${name}" won't match anything. Did you mean to use type Array instead?`;
  }
  let message = `Invalid prop: type check failed for prop "${name}". Expected ${expectedTypes.map(capitalize).join(" | ")}`;
  const expectedType = expectedTypes[0];
  const receivedType = toRawType(value);
  const expectedValue = styleValue(value, expectedType);
  const receivedValue = styleValue(value, receivedType);
  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
    message += ` with value ${expectedValue}`;
  }
  message += `, got ${receivedType} `;
  if (isExplicable(receivedType)) {
    message += `with value ${receivedValue}.`;
  }
  return message;
}
function styleValue(value, type) {
  if (type === "String") {
    return `"${value}"`;
  } else if (type === "Number") {
    return `${Number(value)}`;
  } else {
    return `${value}`;
  }
}
function isExplicable(type) {
  const explicitTypes = ["string", "number", "boolean"];
  return explicitTypes.some((elem) => type.toLowerCase() === elem);
}
function isBoolean(...args) {
  return args.some((elem) => elem.toLowerCase() === "boolean");
}

const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value) => isArray(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (false) {}
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key))
      continue;
    const value = rawSlots[key];
    if (isFunction(value)) {
      slots[key] = normalizeSlot(key, value, ctx);
    } else if (value != null) {
      if (false) {}
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  if (false) {}
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      instance.slots = toRaw(children);
      def(children, "_", type);
    } else {
      normalizeObjectSlots(
        children,
        instance.slots = {},
        instance
      );
    }
  } else {
    instance.slots = {};
    if (children) {
      normalizeVNodeSlots(instance, children);
    }
  }
  def(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (false) {} else if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        extend(slots, children);
        if (!optimized && type === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots, instance);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
        delete slots[key];
      }
    }
  }
};

function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray(rawRef)) {
    rawRef.forEach(
      (r, i) => setRef(
        r,
        oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef),
        parentSuspense,
        vnode,
        isUnmount
      )
    );
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref } = rawRef;
  if (false) {}
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref) {
    if (isString(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction(ref)) {
    callWithErrorHandling(ref, owner, 12, [value, refs]);
  } else {
    const _isString = isString(ref);
    const _isRef = isRef(ref);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? hasOwn(setupState, ref) ? setupState[ref] : refs[ref] : ref.value;
          if (isUnmount) {
            isArray(existing) && remove(existing, refValue);
          } else {
            if (!isArray(existing)) {
              if (_isString) {
                refs[ref] = [refValue];
                if (hasOwn(setupState, ref)) {
                  setupState[ref] = refs[ref];
                }
              } else {
                ref.value = [refValue];
                if (rawRef.k)
                  refs[rawRef.k] = ref.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref] = value;
          if (hasOwn(setupState, ref)) {
            setupState[ref] = value;
          }
        } else if (_isRef) {
          ref.value = value;
          if (rawRef.k)
            refs[rawRef.k] = value;
        } else if (false) {}
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    } else if (false) {}
  }
}

let hasMismatch = false;
const isSVGContainer = (container) => container.namespaceURI.includes("svg") && container.tagName !== "foreignObject";
const isMathMLContainer = (container) => container.namespaceURI.includes("MathML");
const getContainerType = (container) => {
  if (isSVGContainer(container))
    return "svg";
  if (isMathMLContainer(container))
    return "mathml";
  return void 0;
};
const isComment = (node) => node.nodeType === 8 /* COMMENT */;
function createHydrationFunctions(rendererInternals) {
  const {
    mt: mountComponent,
    p: patch,
    o: {
      patchProp,
      createText,
      nextSibling,
      parentNode,
      remove,
      insert,
      createComment
    }
  } = rendererInternals;
  const hydrate = (vnode, container) => {
    if (!container.hasChildNodes()) {
      ( false || __VUE_PROD_HYDRATION_MISMATCH_DETAILS__) && warn$1(
        `Attempting to hydrate existing markup but container is empty. Performing full mount instead.`
      );
      patch(null, vnode, container);
      flushPostFlushCbs();
      container._vnode = vnode;
      return;
    }
    hasMismatch = false;
    hydrateNode(container.firstChild, vnode, null, null, null);
    flushPostFlushCbs();
    container._vnode = vnode;
    if (hasMismatch && true) {
      console.error(`Hydration completed but contains mismatches.`);
    }
  };
  const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
    const isFragmentStart = isComment(node) && node.data === "[";
    const onMismatch = () => handleMismatch(
      node,
      vnode,
      parentComponent,
      parentSuspense,
      slotScopeIds,
      isFragmentStart
    );
    const { type, ref, shapeFlag, patchFlag } = vnode;
    let domType = node.nodeType;
    vnode.el = node;
    if ( false || __VUE_PROD_DEVTOOLS__) {
      if (!("__vnode" in node)) {
        Object.defineProperty(node, "__vnode", {
          value: vnode,
          enumerable: false
        });
      }
      if (!("__vueParentComponent" in node)) {
        Object.defineProperty(node, "__vueParentComponent", {
          value: parentComponent,
          enumerable: false
        });
      }
    }
    if (patchFlag === -2) {
      optimized = false;
      vnode.dynamicChildren = null;
    }
    let nextNode = null;
    switch (type) {
      case Text:
        if (domType !== 3 /* TEXT */) {
          if (vnode.children === "") {
            insert(vnode.el = createText(""), parentNode(node), node);
            nextNode = node;
          } else {
            nextNode = onMismatch();
          }
        } else {
          if (node.data !== vnode.children) {
            hasMismatch = true;
            ( false || __VUE_PROD_HYDRATION_MISMATCH_DETAILS__) && warn$1(
              `Hydration text mismatch in`,
              node.parentNode,
              `
  - rendered on server: ${JSON.stringify(
                node.data
              )}
  - expected on client: ${JSON.stringify(vnode.children)}`
            );
            node.data = vnode.children;
          }
          nextNode = nextSibling(node);
        }
        break;
      case Comment:
        if (isTemplateNode(node)) {
          nextNode = nextSibling(node);
          replaceNode(
            vnode.el = node.content.firstChild,
            node,
            parentComponent
          );
        } else if (domType !== 8 /* COMMENT */ || isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = nextSibling(node);
        }
        break;
      case Static:
        if (isFragmentStart) {
          node = nextSibling(node);
          domType = node.nodeType;
        }
        if (domType === 1 /* ELEMENT */ || domType === 3 /* TEXT */) {
          nextNode = node;
          const needToAdoptContent = !vnode.children.length;
          for (let i = 0; i < vnode.staticCount; i++) {
            if (needToAdoptContent)
              vnode.children += nextNode.nodeType === 1 /* ELEMENT */ ? nextNode.outerHTML : nextNode.data;
            if (i === vnode.staticCount - 1) {
              vnode.anchor = nextNode;
            }
            nextNode = nextSibling(nextNode);
          }
          return isFragmentStart ? nextSibling(nextNode) : nextNode;
        } else {
          onMismatch();
        }
        break;
      case Fragment:
        if (!isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = hydrateFragment(
            node,
            vnode,
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
        }
        break;
      default:
        if (shapeFlag & 1) {
          if ((domType !== 1 /* ELEMENT */ || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) && !isTemplateNode(node)) {
            nextNode = onMismatch();
          } else {
            nextNode = hydrateElement(
              node,
              vnode,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
          }
        } else if (shapeFlag & 6) {
          vnode.slotScopeIds = slotScopeIds;
          const container = parentNode(node);
          if (isFragmentStart) {
            nextNode = locateClosingAnchor(node);
          } else if (isComment(node) && node.data === "teleport start") {
            nextNode = locateClosingAnchor(node, node.data, "teleport end");
          } else {
            nextNode = nextSibling(node);
          }
          mountComponent(
            vnode,
            container,
            null,
            parentComponent,
            parentSuspense,
            getContainerType(container),
            optimized
          );
          if (isAsyncWrapper(vnode)) {
            let subTree;
            if (isFragmentStart) {
              subTree = createVNode(Fragment);
              subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
            } else {
              subTree = node.nodeType === 3 ? createTextVNode("") : createVNode("div");
            }
            subTree.el = node;
            vnode.component.subTree = subTree;
          }
        } else if (shapeFlag & 64) {
          if (domType !== 8 /* COMMENT */) {
            nextNode = onMismatch();
          } else {
            nextNode = vnode.type.hydrate(
              node,
              vnode,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized,
              rendererInternals,
              hydrateChildren
            );
          }
        } else if (shapeFlag & 128) {
          nextNode = vnode.type.hydrate(
            node,
            vnode,
            parentComponent,
            parentSuspense,
            getContainerType(parentNode(node)),
            slotScopeIds,
            optimized,
            rendererInternals,
            hydrateNode
          );
        } else if ( false || __VUE_PROD_HYDRATION_MISMATCH_DETAILS__) {
          warn$1("Invalid HostVNode type:", type, `(${typeof type})`);
        }
    }
    if (ref != null) {
      setRef(ref, null, parentSuspense, vnode);
    }
    return nextNode;
  };
  const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!vnode.dynamicChildren;
    const { type, props, patchFlag, shapeFlag, dirs, transition } = vnode;
    const forcePatch = type === "input" || type === "option";
    if ( false || forcePatch || patchFlag !== -1) {
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      let needCallTransitionHooks = false;
      if (isTemplateNode(el)) {
        needCallTransitionHooks = needTransition(parentSuspense, transition) && parentComponent && parentComponent.vnode.props && parentComponent.vnode.props.appear;
        const content = el.content.firstChild;
        if (needCallTransitionHooks) {
          transition.beforeEnter(content);
        }
        replaceNode(content, el, parentComponent);
        vnode.el = el = content;
      }
      if (shapeFlag & 16 && // skip if element has innerHTML / textContent
      !(props && (props.innerHTML || props.textContent))) {
        let next = hydrateChildren(
          el.firstChild,
          vnode,
          el,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
        let hasWarned = false;
        while (next) {
          hasMismatch = true;
          if (( false || __VUE_PROD_HYDRATION_MISMATCH_DETAILS__) && !hasWarned) {
            warn$1(
              `Hydration children mismatch on`,
              el,
              `
Server rendered element contains more child nodes than client vdom.`
            );
            hasWarned = true;
          }
          const cur = next;
          next = next.nextSibling;
          remove(cur);
        }
      } else if (shapeFlag & 8) {
        if (el.textContent !== vnode.children) {
          hasMismatch = true;
          ( false || __VUE_PROD_HYDRATION_MISMATCH_DETAILS__) && warn$1(
            `Hydration text content mismatch on`,
            el,
            `
  - rendered on server: ${el.textContent}
  - expected on client: ${vnode.children}`
          );
          el.textContent = vnode.children;
        }
      }
      if (props) {
        if ( false || forcePatch || !optimized || patchFlag & (16 | 32)) {
          for (const key in props) {
            if (false) {}
            if (forcePatch && (key.endsWith("value") || key === "indeterminate") || isOn(key) && !isReservedProp(key) || // force hydrate v-bind with .prop modifiers
            key[0] === ".") {
              patchProp(
                el,
                key,
                null,
                props[key],
                void 0,
                void 0,
                parentComponent
              );
            }
          }
        } else if (props.onClick) {
          patchProp(
            el,
            "onClick",
            null,
            props.onClick,
            void 0,
            void 0,
            parentComponent
          );
        }
      }
      let vnodeHooks;
      if (vnodeHooks = props && props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHooks, parentComponent, vnode);
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      if ((vnodeHooks = props && props.onVnodeMounted) || dirs || needCallTransitionHooks) {
        queueEffectWithSuspense(() => {
          vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
          needCallTransitionHooks && transition.enter(el);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
    }
    return el.nextSibling;
  };
  const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!parentVNode.dynamicChildren;
    const children = parentVNode.children;
    const l = children.length;
    let hasWarned = false;
    for (let i = 0; i < l; i++) {
      const vnode = optimized ? children[i] : children[i] = normalizeVNode(children[i]);
      if (node) {
        node = hydrateNode(
          node,
          vnode,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      } else if (vnode.type === Text && !vnode.children) {
        continue;
      } else {
        hasMismatch = true;
        if (( false || __VUE_PROD_HYDRATION_MISMATCH_DETAILS__) && !hasWarned) {
          warn$1(
            `Hydration children mismatch on`,
            container,
            `
Server rendered element contains fewer child nodes than client vdom.`
          );
          hasWarned = true;
        }
        patch(
          null,
          vnode,
          container,
          null,
          parentComponent,
          parentSuspense,
          getContainerType(container),
          slotScopeIds
        );
      }
    }
    return node;
  };
  const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    const { slotScopeIds: fragmentSlotScopeIds } = vnode;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    const container = parentNode(node);
    const next = hydrateChildren(
      nextSibling(node),
      vnode,
      container,
      parentComponent,
      parentSuspense,
      slotScopeIds,
      optimized
    );
    if (next && isComment(next) && next.data === "]") {
      return nextSibling(vnode.anchor = next);
    } else {
      hasMismatch = true;
      insert(vnode.anchor = createComment(`]`), container, next);
      return next;
    }
  };
  const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {
    hasMismatch = true;
    ( false || __VUE_PROD_HYDRATION_MISMATCH_DETAILS__) && warn$1(
      `Hydration node mismatch:
- rendered on server:`,
      node,
      node.nodeType === 3 /* TEXT */ ? `(text)` : isComment(node) && node.data === "[" ? `(start of fragment)` : ``,
      `
- expected on client:`,
      vnode.type
    );
    vnode.el = null;
    if (isFragment) {
      const end = locateClosingAnchor(node);
      while (true) {
        const next2 = nextSibling(node);
        if (next2 && next2 !== end) {
          remove(next2);
        } else {
          break;
        }
      }
    }
    const next = nextSibling(node);
    const container = parentNode(node);
    remove(node);
    patch(
      null,
      vnode,
      container,
      next,
      parentComponent,
      parentSuspense,
      getContainerType(container),
      slotScopeIds
    );
    return next;
  };
  const locateClosingAnchor = (node, open = "[", close = "]") => {
    let match = 0;
    while (node) {
      node = nextSibling(node);
      if (node && isComment(node)) {
        if (node.data === open)
          match++;
        if (node.data === close) {
          if (match === 0) {
            return nextSibling(node);
          } else {
            match--;
          }
        }
      }
    }
    return node;
  };
  const replaceNode = (newNode, oldNode, parentComponent) => {
    const parentNode2 = oldNode.parentNode;
    if (parentNode2) {
      parentNode2.replaceChild(newNode, oldNode);
    }
    let parent = parentComponent;
    while (parent) {
      if (parent.vnode.el === oldNode) {
        parent.vnode.el = parent.subTree.el = newNode;
      }
      parent = parent.parent;
    }
  };
  const isTemplateNode = (node) => {
    return node.nodeType === 1 /* ELEMENT */ && node.tagName.toLowerCase() === "template";
  };
  return [hydrate, hydrateNode];
}
function propHasMismatch(el, key, clientValue, vnode, instance) {
  var _a;
  let mismatchType;
  let mismatchKey;
  let actual;
  let expected;
  if (key === "class") {
    actual = el.getAttribute("class");
    expected = normalizeClass(clientValue);
    if (!isSetEqual(toClassSet(actual || ""), toClassSet(expected))) {
      mismatchType = mismatchKey = `class`;
    }
  } else if (key === "style") {
    actual = el.getAttribute("style");
    expected = isString(clientValue) ? clientValue : stringifyStyle(normalizeStyle(clientValue));
    const actualMap = toStyleMap(actual);
    const expectedMap = toStyleMap(expected);
    if (vnode.dirs) {
      for (const { dir, value } of vnode.dirs) {
        if (dir.name === "show" && !value) {
          expectedMap.set("display", "none");
        }
      }
    }
    const root = instance == null ? void 0 : instance.subTree;
    if (vnode === root || (root == null ? void 0 : root.type) === Fragment && root.children.includes(vnode)) {
      const cssVars = (_a = instance == null ? void 0 : instance.getCssVars) == null ? void 0 : _a.call(instance);
      for (const key2 in cssVars) {
        expectedMap.set(`--${key2}`, String(cssVars[key2]));
      }
    }
    if (!isMapEqual(actualMap, expectedMap)) {
      mismatchType = mismatchKey = "style";
    }
  } else if (el instanceof SVGElement && isKnownSvgAttr(key) || el instanceof HTMLElement && (isBooleanAttr(key) || isKnownHtmlAttr(key))) {
    if (isBooleanAttr(key)) {
      actual = el.hasAttribute(key);
      expected = includeBooleanAttr(clientValue);
    } else if (clientValue == null) {
      actual = el.hasAttribute(key);
      expected = false;
    } else {
      if (el.hasAttribute(key)) {
        actual = el.getAttribute(key);
      } else if (key === "value" && el.tagName === "TEXTAREA") {
        actual = el.value;
      } else {
        actual = false;
      }
      expected = isRenderableAttrValue(clientValue) ? String(clientValue) : false;
    }
    if (actual !== expected) {
      mismatchType = `attribute`;
      mismatchKey = key;
    }
  }
  if (mismatchType) {
    const format = (v) => v === false ? `(not rendered)` : `${mismatchKey}="${v}"`;
    const preSegment = `Hydration ${mismatchType} mismatch on`;
    const postSegment = `
  - rendered on server: ${format(actual)}
  - expected on client: ${format(expected)}
  Note: this mismatch is check-only. The DOM will not be rectified in production due to performance overhead.
  You should fix the source of the mismatch.`;
    {
      warn$1(preSegment, el, postSegment);
    }
    return true;
  }
  return false;
}
function toClassSet(str) {
  return new Set(str.trim().split(/\s+/));
}
function isSetEqual(a, b) {
  if (a.size !== b.size) {
    return false;
  }
  for (const s of a) {
    if (!b.has(s)) {
      return false;
    }
  }
  return true;
}
function toStyleMap(str) {
  const styleMap = /* @__PURE__ */ new Map();
  for (const item of str.split(";")) {
    let [key, value] = item.split(":");
    key = key == null ? void 0 : key.trim();
    value = value == null ? void 0 : value.trim();
    if (key && value) {
      styleMap.set(key, value);
    }
  }
  return styleMap;
}
function isMapEqual(a, b) {
  if (a.size !== b.size) {
    return false;
  }
  for (const [key, value] of a) {
    if (value !== b.get(key)) {
      return false;
    }
  }
  return true;
}

let supported;
let perf;
function startMeasure(instance, type) {
  if (instance.appContext.config.performance && isSupported()) {
    perf.mark(`vue-${type}-${instance.uid}`);
  }
  if ( false || __VUE_PROD_DEVTOOLS__) {
    devtoolsPerfStart(instance, type, isSupported() ? perf.now() : Date.now());
  }
}
function endMeasure(instance, type) {
  if (instance.appContext.config.performance && isSupported()) {
    const startTag = `vue-${type}-${instance.uid}`;
    const endTag = startTag + `:end`;
    perf.mark(endTag);
    perf.measure(
      `<${formatComponentName(instance, instance.type)}> ${type}`,
      startTag,
      endTag
    );
    perf.clearMarks(startTag);
    perf.clearMarks(endTag);
  }
  if ( false || __VUE_PROD_DEVTOOLS__) {
    devtoolsPerfEnd(instance, type, isSupported() ? perf.now() : Date.now());
  }
}
function isSupported() {
  if (supported !== void 0) {
    return supported;
  }
  if (typeof window !== "undefined" && window.performance) {
    supported = true;
    perf = window.performance;
  } else {
    supported = false;
  }
  return supported;
}

function initFeatureFlags() {
  const needWarn = [];
  if (typeof __VUE_OPTIONS_API__ !== "boolean") {
     false && 0;
    getGlobalThis().__VUE_OPTIONS_API__ = true;
  }
  if (typeof __VUE_PROD_DEVTOOLS__ !== "boolean") {
     false && 0;
    getGlobalThis().__VUE_PROD_DEVTOOLS__ = false;
  }
  if (typeof __VUE_PROD_HYDRATION_MISMATCH_DETAILS__ !== "boolean") {
     false && 0;
    getGlobalThis().__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ = false;
  }
  if (false) {}
}

const queuePostRenderEffect = queueEffectWithSuspense ;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function createHydrationRenderer(options) {
  return baseCreateRenderer(options, createHydrationFunctions);
}
function baseCreateRenderer(options, createHydrationFns) {
  {
    initFeatureFlags();
  }
  const target = getGlobalThis();
  target.__VUE__ = true;
  if ( false || __VUE_PROD_DEVTOOLS__) {
    setDevtoolsHook$1(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
  }
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = NOOP,
    insertStaticContent: hostInsertStaticContent
  } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized =  false ? 0 : !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, namespace);
        } else if (false) {}
        break;
      case Fragment:
        processFragment(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        break;
      default:
        if (shapeFlag & 1) {
          processElement(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 6) {
          processComponent(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 64) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (shapeFlag & 128) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (false) {}
    }
    if (ref != null && parentComponent) {
      setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateText(n2.children),
        container,
        anchor
      );
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateComment(n2.children || ""),
        container,
        anchor
      );
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, namespace) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(
      n2.children,
      container,
      anchor,
      namespace,
      n2.el,
      n2.anchor
    );
  };
  const patchStaticNode = (n1, n2, container, namespace) => {
    if (n2.children !== n1.children) {
      const anchor = hostNextSibling(n1.anchor);
      removeStaticNode(n1);
      [n2.el, n2.anchor] = hostInsertStaticContent(
        n2.children,
        container,
        anchor,
        namespace
      );
    } else {
      n2.el = n1.el;
      n2.anchor = n1.anchor;
    }
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    if (n2.type === "svg") {
      namespace = "svg";
    } else if (n2.type === "math") {
      namespace = "mathml";
    }
    if (n1 == null) {
      mountElement(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      patchElement(
        n1,
        n2,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { props, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(
      vnode.type,
      namespace,
      props && props.is,
      props
    );
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(
        vnode.children,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(vnode, namespace),
        slotScopeIds,
        optimized
      );
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(
            el,
            key,
            null,
            props[key],
            namespace,
            vnode.children,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        }
      }
      if ("value" in props) {
        hostPatchProp(el, "value", null, props.value, namespace);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if ( false || __VUE_PROD_DEVTOOLS__) {
      Object.defineProperty(el, "__vnode", {
        value: vnode,
        enumerable: false
      });
      Object.defineProperty(el, "__vueParentComponent", {
        value: parentComponent,
        enumerable: false
      });
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = needTransition(parentSuspense, transition);
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el, slotScopeIds[i]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (false) {}
      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(
          el,
          parentVNode,
          parentVNode.scopeId,
          parentVNode.slotScopeIds,
          parentComponent.parent
        );
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
    for (let i = start; i < children.length; i++) {
      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(
        null,
        child,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    if (false) {}
    if (dynamicChildren) {
      patchBlockChildren(
        n1.dynamicChildren,
        dynamicChildren,
        el,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds
      );
      if (false) {}
    } else if (!optimized) {
      patchChildren(
        n1,
        n2,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds,
        false
      );
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(
          el,
          n2,
          oldProps,
          newProps,
          parentComponent,
          parentSuspense,
          namespace
        );
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, namespace);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key = propsToUpdate[i];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(
                el,
                key,
                prev,
                next,
                namespace,
                n1.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(
        el,
        n2,
        oldProps,
        newProps,
        parentComponent,
        parentSuspense,
        namespace
      );
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch(
        oldVNode,
        newVNode,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        true
      );
    }
  };
  const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, namespace) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(
              el,
              key,
              oldProps[key],
              null,
              namespace,
              vnode.children,
              parentComponent,
              parentSuspense,
              unmountChildren
            );
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key))
          continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(
            el,
            key,
            prev,
            next,
            namespace,
            vnode.children,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (false) {}
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(
        // #10007
        // such fragment like `<></>` will be compiled into
        // a fragment which doesn't have a children.
        // In this case fallback to an empty array
        n2.children || [],
        container,
        fragmentEndAnchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          container,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        if (false) {} else if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n2.key != null || parentComponent && n2 === parentComponent.subTree
        ) {
          traverseStaticChildren(
            n1,
            n2,
            true
            /* shallow */
          );
        }
      } else {
        patchChildren(
          n1,
          n2,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(
          n2,
          container,
          anchor,
          namespace,
          optimized
        );
      } else {
        mountComponent(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          optimized
        );
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
    const compatMountInstance = initialVNode.isCompatRoot && initialVNode.component;
    const instance = compatMountInstance || (initialVNode.component = createComponentInstance(
      initialVNode,
      parentComponent,
      parentSuspense
    ));
    if (false) {}
    if (false) {}
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    if (!compatMountInstance) {
      if (false) {}
      setupComponent(instance);
      if (false) {}
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
    } else {
      setupRenderEffect(
        instance,
        initialVNode,
        container,
        anchor,
        parentSuspense,
        namespace,
        optimized
      );
    }
    if (false) {}
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        if (false) {}
        updateComponentPreRender(instance, n2, optimized);
        if (false) {}
        return;
      } else {
        instance.next = n2;
        invalidateJob(instance.update);
        instance.effect.dirty = true;
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m, parent } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        if (isCompatEnabled$1("INSTANCE_EVENT_HOOKS", instance)) {
          instance.emit("hook:beforeMount");
        }
        toggleRecurse(instance, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            if (false) {}
            instance.subTree = renderComponentRoot(instance);
            if (false) {}
            if (false) {}
            hydrateNode(
              el,
              instance.subTree,
              instance,
              parentSuspense,
              null
            );
            if (false) {}
          };
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(
              // note: we are moving the render call into an async callback,
              // which means it won't track dependencies - but it's ok because
              // a server-rendered async wrapper is already in resolved state
              // and it will never need to change.
              () => !instance.isUnmounted && hydrateSubTree()
            );
          } else {
            hydrateSubTree();
          }
        } else {
          if (false) {}
          const subTree = instance.subTree = renderComponentRoot(instance);
          if (false) {}
          if (false) {}
          patch(
            null,
            subTree,
            container,
            anchor,
            instance,
            parentSuspense,
            namespace
          );
          if (false) {}
          initialVNode.el = subTree.el;
        }
        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
            parentSuspense
          );
        }
        if (isCompatEnabled$1("INSTANCE_EVENT_HOOKS", instance)) {
          queuePostRenderEffect(
            () => instance.emit("hook:mounted"),
            parentSuspense
          );
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
          if (isCompatEnabled$1("INSTANCE_EVENT_HOOKS", instance)) {
            queuePostRenderEffect(
              () => instance.emit("hook:activated"),
              parentSuspense
            );
          }
        }
        instance.isMounted = true;
        if ( false || __VUE_PROD_DEVTOOLS__) {
          devtoolsComponentAdded(instance);
        }
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u, parent, vnode } = instance;
        {
          const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
          if (nonHydratedAsyncRoot) {
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance, next, optimized);
            }
            nonHydratedAsyncRoot.asyncDep.then(() => {
              if (!instance.isUnmounted) {
                componentUpdateFn();
              }
            });
            return;
          }
        }
        let originNext = next;
        let vnodeHook;
        if (false) {}
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        if (isCompatEnabled$1("INSTANCE_EVENT_HOOKS", instance)) {
          instance.emit("hook:beforeUpdate");
        }
        toggleRecurse(instance, true);
        if (false) {}
        const nextTree = renderComponentRoot(instance);
        if (false) {}
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        if (false) {}
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          namespace
        );
        if (false) {}
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, next, vnode),
            parentSuspense
          );
        }
        if (isCompatEnabled$1("INSTANCE_EVENT_HOOKS", instance)) {
          queuePostRenderEffect(
            () => instance.emit("hook:updated"),
            parentSuspense
          );
        }
        if ( false || __VUE_PROD_DEVTOOLS__) {
          devtoolsComponentUpdated(instance);
        }
        if (false) {}
      }
    };
    const effect = instance.effect = new ReactiveEffect(
      componentUpdateFn,
      NOOP,
      () => queueJob(update),
      instance.scope
      // track it in component's effect scope
    );
    const update = instance.update = () => {
      if (effect.dirty) {
        effect.run();
      }
    };
    update.id = instance.uid;
    toggleRecurse(instance, true);
    if (false) {}
    update();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs(instance);
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;
    for (i = 0; i < commonLength; i++) {
      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(
        c1[i],
        nextChild,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
    if (oldLength > newLength) {
      unmountChildren(
        c1,
        parentComponent,
        parentSuspense,
        true,
        false,
        commonLength
      );
    } else {
      mountChildren(
        c2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized,
        commonLength
      );
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i <= e1 && i <= e2) {
      const n1 = c1[i];
      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      i++;
    }
    while (i <= e1 && i <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i <= e2) {
          patch(
            null,
            c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          i++;
        }
      }
    } else if (i > e2) {
      while (i <= e1) {
        unmount(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } else {
      const s1 = i;
      const s2 = i;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i = s2; i <= e2; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (nextChild.key != null) {
          if (false) {}
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i = 0; i < toBePatched; i++)
        newIndexToOldIndexMap[i] = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(
            prevChild,
            c2[newIndex],
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i] === 0) {
          patch(
            null,
            nextChild,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (moved) {
          if (j < 0 || i !== increasingNewIndexSequence[j]) {
            move(nextChild, container, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition2) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove2 = () => hostInsert(el, container, anchor);
        const performLeave = () => {
          leave(el, () => {
            remove2();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove2, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type,
      props,
      ref,
      children,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs
    } = vnode;
    if (ref != null) {
      setRef(ref, null, parentSuspense, vnode, true);
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(
          vnode,
          parentComponent,
          parentSuspense,
          optimized,
          internals,
          doRemove
        );
      } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(
          dynamicChildren,
          parentComponent,
          parentSuspense,
          false,
          true
        );
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      if (false) {} else {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    if (false) {}
    const { bum, scope, update, subTree, um } = instance;
    if (bum) {
      invokeArrayFns(bum);
    }
    if (isCompatEnabled$1("INSTANCE_EVENT_HOOKS", instance)) {
      instance.emit("hook:beforeDestroy");
    }
    scope.stop();
    if (update) {
      update.active = false;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    if (isCompatEnabled$1("INSTANCE_EVENT_HOOKS", instance)) {
      queuePostRenderEffect(
        () => instance.emit("hook:destroyed"),
        parentSuspense
      );
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
    if ( false || __VUE_PROD_DEVTOOLS__) {
      devtoolsComponentRemoved(instance);
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i = start; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    return hostNextSibling(vnode.anchor || vnode.el);
  };
  let isFlushing = false;
  const render = (vnode, container, namespace) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(
        container._vnode || null,
        vnode,
        container,
        null,
        null,
        null,
        namespace
      );
    }
    if (!isFlushing) {
      isFlushing = true;
      flushPreFlushCbs();
      flushPostFlushCbs();
      isFlushing = false;
    }
    container._vnode = vnode;
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate, hydrateNode] = createHydrationFns(
      internals
    );
  }
  return {
    render,
    hydrate,
    createApp: createAppAPI(render, hydrate)
  };
}
function resolveChildrenNamespace({ type, props }, currentNamespace) {
  return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
}
function toggleRecurse({ effect, update }, allowed) {
  effect.allowRecurse = update.allowRecurse = allowed;
}
function needTransition(parentSuspense, transition) {
  return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray(ch1) && isArray(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      const c1 = ch1[i];
      let c2 = ch2[i];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }
        if (!shallow)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text) {
        c2.el = c1.el;
      }
      if (false) {}
    }
  }
}
function getSequence(arr) {
  const p = arr.slice();
  const result = [0];
  let i, j, u, v, c;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p[i] = j;
        result.push(i);
        continue;
      }
      u = 0;
      v = result.length - 1;
      while (u < v) {
        c = u + v >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = result.length;
  v = result[u - 1];
  while (u-- > 0) {
    result[u] = v;
    v = p[v];
  }
  return result;
}
function locateNonHydratedAsyncRoot(instance) {
  const subComponent = instance.subTree.component;
  if (subComponent) {
    if (subComponent.asyncDep && !subComponent.asyncResolved) {
      return subComponent;
    } else {
      return locateNonHydratedAsyncRoot(subComponent);
    }
  }
}

const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
const isTargetMathML = (target) => typeof MathMLElement === "function" && target instanceof MathMLElement;
const resolveTarget = (props, select) => {
  const targetSelector = props && props.to;
  if (isString(targetSelector)) {
    if (!select) {
       false && 0;
      return null;
    } else {
      const target = select(targetSelector);
      if (!target) {
         false && 0;
      }
      return target;
    }
  } else {
    if (false) {}
    return targetSelector;
  }
};
const TeleportImpl = {
  name: "Teleport",
  __isTeleport: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
    const {
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      o: { insert, querySelector, createText, createComment }
    } = internals;
    const disabled = isTeleportDisabled(n2.props);
    let { shapeFlag, children, dynamicChildren } = n2;
    if (false) {}
    if (n1 == null) {
      const placeholder = n2.el =  false ? 0 : createText("");
      const mainAnchor = n2.anchor =  false ? 0 : createText("");
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      const target = n2.target = resolveTarget(n2.props, querySelector);
      const targetAnchor = n2.targetAnchor = createText("");
      if (target) {
        insert(targetAnchor, target);
        if (namespace === "svg" || isTargetSVG(target)) {
          namespace = "svg";
        } else if (namespace === "mathml" || isTargetMathML(target)) {
          namespace = "mathml";
        }
      } else if (false) {}
      const mount = (container2, anchor2) => {
        if (shapeFlag & 16) {
          mountChildren(
            children,
            container2,
            anchor2,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      };
      if (disabled) {
        mount(container, mainAnchor);
      } else if (target) {
        mount(target, targetAnchor);
      }
    } else {
      n2.el = n1.el;
      const mainAnchor = n2.anchor = n1.anchor;
      const target = n2.target = n1.target;
      const targetAnchor = n2.targetAnchor = n1.targetAnchor;
      const wasDisabled = isTeleportDisabled(n1.props);
      const currentContainer = wasDisabled ? container : target;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      if (namespace === "svg" || isTargetSVG(target)) {
        namespace = "svg";
      } else if (namespace === "mathml" || isTargetMathML(target)) {
        namespace = "mathml";
      }
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          currentContainer,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(
          n1,
          n2,
          currentContainer,
          currentAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          false
        );
      }
      if (disabled) {
        if (!wasDisabled) {
          moveTeleport(
            n2,
            container,
            mainAnchor,
            internals,
            1
          );
        } else {
          if (n2.props && n1.props && n2.props.to !== n1.props.to) {
            n2.props.to = n1.props.to;
          }
        }
      } else {
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          const nextTarget = n2.target = resolveTarget(
            n2.props,
            querySelector
          );
          if (nextTarget) {
            moveTeleport(
              n2,
              nextTarget,
              null,
              internals,
              0
            );
          } else if (false) {}
        } else if (wasDisabled) {
          moveTeleport(
            n2,
            target,
            targetAnchor,
            internals,
            1
          );
        }
      }
    }
    updateCssVars(n2);
  },
  remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
    const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
    if (target) {
      hostRemove(targetAnchor);
    }
    doRemove && hostRemove(anchor);
    if (shapeFlag & 16) {
      const shouldRemove = doRemove || !isTeleportDisabled(props);
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        unmount(
          child,
          parentComponent,
          parentSuspense,
          shouldRemove,
          !!child.dynamicChildren
        );
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
  if (moveType === 0) {
    insert(vnode.targetAnchor, container, parentAnchor);
  }
  const { el, anchor, shapeFlag, children, props } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert(el, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props)) {
    if (shapeFlag & 16) {
      for (let i = 0; i < children.length; i++) {
        move(
          children[i],
          container,
          parentAnchor,
          2
        );
      }
    }
  }
  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
  o: { nextSibling, parentNode, querySelector }
}, hydrateChildren) {
  const target = vnode.target = resolveTarget(
    vnode.props,
    querySelector
  );
  if (target) {
    const targetNode = target._lpa || target.firstChild;
    if (vnode.shapeFlag & 16) {
      if (isTeleportDisabled(vnode.props)) {
        vnode.anchor = hydrateChildren(
          nextSibling(node),
          vnode,
          parentNode(node),
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
        vnode.targetAnchor = targetNode;
      } else {
        vnode.anchor = nextSibling(node);
        let targetAnchor = targetNode;
        while (targetAnchor) {
          targetAnchor = nextSibling(targetAnchor);
          if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
            vnode.targetAnchor = targetAnchor;
            target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
            break;
          }
        }
        hydrateChildren(
          targetNode,
          vnode,
          target,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      }
    }
    updateCssVars(vnode);
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
function updateCssVars(vnode) {
  const ctx = vnode.ctx;
  if (ctx && ctx.ut) {
    let node = vnode.children[0].el;
    while (node && node !== vnode.targetAnchor) {
      if (node.nodeType === 1)
        node.setAttribute("data-v-owner", ctx.uid);
      node = node.nextSibling;
    }
    ctx.ut();
  }
}

const normalizedAsyncComponentMap = /* @__PURE__ */ new WeakMap();
function convertLegacyAsyncComponent(comp) {
  if (normalizedAsyncComponentMap.has(comp)) {
    return normalizedAsyncComponentMap.get(comp);
  }
  let resolve;
  let reject;
  const fallbackPromise = new Promise((r, rj) => {
    resolve = r, reject = rj;
  });
  const res = comp(resolve, reject);
  let converted;
  if (isPromise(res)) {
    converted = defineAsyncComponent(() => res);
  } else if (isObject(res) && !isVNode(res) && !isArray(res)) {
    converted = defineAsyncComponent({
      loader: () => res.component,
      loadingComponent: res.loading,
      errorComponent: res.error,
      delay: res.delay,
      timeout: res.timeout
    });
  } else if (res == null) {
    converted = defineAsyncComponent(() => fallbackPromise);
  } else {
    converted = comp;
  }
  normalizedAsyncComponentMap.set(comp, converted);
  return converted;
}

function convertLegacyComponent(comp, instance) {
  if (comp.__isBuiltIn) {
    return comp;
  }
  if (isFunction(comp) && comp.cid) {
    comp = comp.options;
  }
  if (isFunction(comp) && checkCompatEnabled$1("COMPONENT_ASYNC", instance, comp)) {
    return convertLegacyAsyncComponent(comp);
  }
  if (isObject(comp) && comp.functional && softAssertCompatEnabled(
    "COMPONENT_FUNCTIONAL",
    instance,
    comp
  )) {
    return convertLegacyFunctionalComponent(comp);
  }
  return comp;
}

const Fragment = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value) {
  isBlockTreeEnabled += value;
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(
    createBaseVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      true
    )
  );
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(
    createVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      true
    )
  );
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  if (false) {}
  return n1.type === n2.type && n1.key === n2.key;
}
let vnodeArgsTransformer;
function transformVNodeArgs(transformer) {
  vnodeArgsTransformer = transformer;
}
const createVNodeWithArgsTransform = (...args) => {
  return _createVNode(
    ...vnodeArgsTransformer ? vnodeArgsTransformer(args, currentRenderingInstance) : args
  );
};
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({
  ref,
  ref_key,
  ref_for
}) => {
  if (typeof ref === "number") {
    ref = "" + ref;
  }
  return ref != null ? isString(ref) || isRef(ref) || isFunction(ref) ? { i: currentRenderingInstance, r: ref, k: ref_key, f: !!ref_for } : ref : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString(children) ? 8 : 16;
  }
  if (false) {}
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  {
    convertLegacyVModelProps(vnode);
    defineLegacyVNodeProperties(vnode);
  }
  return vnode;
}
const createVNode =  false ? 0 : _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    if (false) {}
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(
      type,
      props,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag |= -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  {
    type = convertLegacyComponent(type, currentRenderingInstance);
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style } = props;
    if (klass && !isString(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject(style)) {
      if (isProxy(style) && !isArray(style)) {
        style = extend({}, style);
      }
      props.style = normalizeStyle(style);
    }
  }
  const shapeFlag = isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject(type) ? 4 : isFunction(type) ? 2 : 0;
  if (false) {}
  return createBaseVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  );
}
function guardReactiveProps(props) {
  if (!props)
    return null;
  return isProxy(props) || InternalObjectKey in props ? extend({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
  const { props, ref, patchFlag, children } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref ? isArray(ref) ? ref.concat(normalizeRef(extraProps)) : [ref, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children:  false ? 0 : children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition: vnode.transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  {
    defineLegacyVNodeProperties(cloned);
  }
  return cloned;
}
function deepCloneVNode(vnode) {
  const cloned = cloneVNode(vnode);
  if (isArray(vnode.children)) {
    cloned.children = vnode.children.map(deepCloneVNode);
  }
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createStaticVNode(content, numberOfNodes) {
  const vnode = createVNode(Static, null, content);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !(InternalObjectKey in children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}

const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    attrsProxy: null,
    slotsProxy: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  if (false) {} else {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let setInSSRSetupState;
{
  const g = getGlobalThis();
  const registerGlobalSetter = (key, setter) => {
    let setters;
    if (!(setters = g[key]))
      setters = g[key] = [];
    setters.push(setter);
    return (v) => {
      if (setters.length > 1)
        setters.forEach((set) => set(v));
      else
        setters[0](v);
    };
  };
  internalSetCurrentInstance = registerGlobalSetter(
    `__VUE_INSTANCE_SETTERS__`,
    (v) => currentInstance = v
  );
  setInSSRSetupState = registerGlobalSetter(
    `__VUE_SSR_SETTERS__`,
    (v) => isInSSRComponentSetup = v
  );
}
const setCurrentInstance = (instance) => {
  const prev = currentInstance;
  internalSetCurrentInstance(instance);
  instance.scope.on();
  return () => {
    instance.scope.off();
    internalSetCurrentInstance(prev);
  };
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
};
const isBuiltInTag = /* @__PURE__ */ (/* unused pure expression or super */ null && (makeMap("slot,component")));
function validateComponentName(name, { isNativeTag }) {
  if (isBuiltInTag(name) || isNativeTag(name)) {
    warn$1(
      "Do not use built-in or reserved HTML elements as component id: " + name
    );
  }
}
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isSSR && setInSSRSetupState(isSSR);
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isSSR && setInSSRSetupState(false);
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  var _a;
  const Component = instance.type;
  if (false) {}
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
  if (false) {}
  const { setup } = Component;
  if (setup) {
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    const reset = setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling(
      setup,
      instance,
      0,
      [
         false ? 0 : instance.props,
        setupContext
      ]
    );
    resetTracking();
    reset();
    if (isPromise(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e) => {
          handleError(e, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
        if (false) {}
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject(setupResult)) {
    if (false) {}
    if ( false || __VUE_PROD_DEVTOOLS__) {
      instance.devtoolsRawSetupState = setupResult;
    }
    instance.setupState = proxyRefs(setupResult);
    if (false) {}
  } else if (false) {}
  finishComponentSetup(instance, isSSR);
}
let compile$1;
let installWithProxy;
function registerRuntimeCompiler(_compile) {
  compile$1 = _compile;
  installWithProxy = (i) => {
    if (i.render._rc) {
      i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
    }
  };
}
const isRuntimeOnly = () => !compile$1;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  {
    convertLegacyRenderFn(instance);
    if (false) {}
  }
  if (!instance.render) {
    if (!isSSR && compile$1 && !Component.render) {
      const template = instance.vnode.props && instance.vnode.props["inline-template"] || Component.template || resolveMergedOptions(instance).template;
      if (template) {
        if (false) {}
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend(
          extend(
            {
              isCustomElement,
              delimiters
            },
            compilerOptions
          ),
          componentCompilerOptions
        );
        {
          finalCompilerOptions.compatConfig = Object.create(globalCompatConfig);
          if (Component.compatConfig) {
            extend(finalCompilerOptions.compatConfig, Component.compatConfig);
          }
        }
        Component.render = compile$1(template, finalCompilerOptions);
        if (false) {}
      }
    }
    instance.render = Component.render || NOOP;
    if (installWithProxy) {
      installWithProxy(instance);
    }
  }
  if (__VUE_OPTIONS_API__ && !skipOptions) {
    const reset = setCurrentInstance(instance);
    pauseTracking();
    try {
      applyOptions(instance);
    } finally {
      resetTracking();
      reset();
    }
  }
  if (false) {}
}
function getAttrsProxy(instance) {
  return instance.attrsProxy || (instance.attrsProxy = new Proxy(
    instance.attrs,
     false ? 0 : {
      get(target, key) {
        track(instance, "get", "$attrs");
        return target[key];
      }
    }
  ));
}
function getSlotsProxy(instance) {
  return instance.slotsProxy || (instance.slotsProxy = new Proxy(instance.slots, {
    get(target, key) {
      track(instance, "get", "$slots");
      return target[key];
    }
  }));
}
function createSetupContext(instance) {
  const expose = (exposed) => {
    if (false) {}
    instance.exposed = exposed || {};
  };
  if (false) {} else {
    return {
      get attrs() {
        return getAttrsProxy(instance);
      },
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getExposeProxy(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component, includeInferred = true) {
  return isFunction(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance, Component, isRoot = false) {
  let name = getComponentName(Component);
  if (!name && Component.__file) {
    const match = Component.__file.match(/([^/\\]+)\.\w+$/);
    if (match) {
      name = match[1];
    }
  }
  if (!name && instance && instance.parent) {
    const inferFromRegistry = (registry) => {
      for (const key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    };
    name = inferFromRegistry(
      instance.components || instance.parent.type.components
    ) || inferFromRegistry(instance.appContext.components);
  }
  return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
  return isFunction(value) && "__vccOpts" in value;
}

const computed = (getterOrOptions, debugOptions) => {
  const c = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
  if (false) {}
  return c;
};

function useModel(props, name, options = EMPTY_OBJ) {
  const i = getCurrentInstance();
  if (false) {}
  if (false) {}
  const camelizedName = camelize(name);
  const hyphenatedName = hyphenate(name);
  const res = customRef((track, trigger) => {
    let localValue;
    watchSyncEffect(() => {
      const propValue = props[name];
      if (hasChanged(localValue, propValue)) {
        localValue = propValue;
        trigger();
      }
    });
    return {
      get() {
        track();
        return options.get ? options.get(localValue) : localValue;
      },
      set(value) {
        const rawProps = i.vnode.props;
        if (!(rawProps && // check if parent has passed v-model
        (name in rawProps || camelizedName in rawProps || hyphenatedName in rawProps) && (`onUpdate:${name}` in rawProps || `onUpdate:${camelizedName}` in rawProps || `onUpdate:${hyphenatedName}` in rawProps)) && hasChanged(value, localValue)) {
          localValue = value;
          trigger();
        }
        i.emit(`update:${name}`, options.set ? options.set(value) : value);
      }
    };
  });
  const modifierKey = name === "modelValue" ? "modelModifiers" : `${name}Modifiers`;
  res[Symbol.iterator] = () => {
    let i2 = 0;
    return {
      next() {
        if (i2 < 2) {
          return { value: i2++ ? props[modifierKey] || {} : res, done: false };
        } else {
          return { done: true };
        }
      }
    };
  };
  return res;
}

function h(type, propsOrChildren, children) {
  const l = arguments.length;
  if (l === 2) {
    if (isObject(propsOrChildren) && !isArray(propsOrChildren)) {
      if (isVNode(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildren, children);
  }
}

function initCustomFormatter() {
  if (true) {
    return;
  }
  const vueStyle = { style: "color:#3ba776" };
  const numberStyle = { style: "color:#1677ff" };
  const stringStyle = { style: "color:#f5222d" };
  const keywordStyle = { style: "color:#eb2f96" };
  const formatter = {
    header(obj) {
      if (!isObject(obj)) {
        return null;
      }
      if (obj.__isVue) {
        return ["div", vueStyle, `VueInstance`];
      } else if (isRef(obj)) {
        return [
          "div",
          {},
          ["span", vueStyle, genRefFlag(obj)],
          "<",
          formatValue(obj.value),
          `>`
        ];
      } else if (isReactive(obj)) {
        return [
          "div",
          {},
          ["span", vueStyle, isShallow(obj) ? "ShallowReactive" : "Reactive"],
          "<",
          formatValue(obj),
          `>${isReadonly(obj) ? ` (readonly)` : ``}`
        ];
      } else if (isReadonly(obj)) {
        return [
          "div",
          {},
          ["span", vueStyle, isShallow(obj) ? "ShallowReadonly" : "Readonly"],
          "<",
          formatValue(obj),
          ">"
        ];
      }
      return null;
    },
    hasBody(obj) {
      return obj && obj.__isVue;
    },
    body(obj) {
      if (obj && obj.__isVue) {
        return [
          "div",
          {},
          ...formatInstance(obj.$)
        ];
      }
    }
  };
  function formatInstance(instance) {
    const blocks = [];
    if (instance.type.props && instance.props) {
      blocks.push(createInstanceBlock("props", toRaw(instance.props)));
    }
    if (instance.setupState !== EMPTY_OBJ) {
      blocks.push(createInstanceBlock("setup", instance.setupState));
    }
    if (instance.data !== EMPTY_OBJ) {
      blocks.push(createInstanceBlock("data", toRaw(instance.data)));
    }
    const computed = extractKeys(instance, "computed");
    if (computed) {
      blocks.push(createInstanceBlock("computed", computed));
    }
    const injected = extractKeys(instance, "inject");
    if (injected) {
      blocks.push(createInstanceBlock("injected", injected));
    }
    blocks.push([
      "div",
      {},
      [
        "span",
        {
          style: keywordStyle.style + ";opacity:0.66"
        },
        "$ (internal): "
      ],
      ["object", { object: instance }]
    ]);
    return blocks;
  }
  function createInstanceBlock(type, target) {
    target = extend({}, target);
    if (!Object.keys(target).length) {
      return ["span", {}];
    }
    return [
      "div",
      { style: "line-height:1.25em;margin-bottom:0.6em" },
      [
        "div",
        {
          style: "color:#476582"
        },
        type
      ],
      [
        "div",
        {
          style: "padding-left:1.25em"
        },
        ...Object.keys(target).map((key) => {
          return [
            "div",
            {},
            ["span", keywordStyle, key + ": "],
            formatValue(target[key], false)
          ];
        })
      ]
    ];
  }
  function formatValue(v, asRaw = true) {
    if (typeof v === "number") {
      return ["span", numberStyle, v];
    } else if (typeof v === "string") {
      return ["span", stringStyle, JSON.stringify(v)];
    } else if (typeof v === "boolean") {
      return ["span", keywordStyle, v];
    } else if (isObject(v)) {
      return ["object", { object: asRaw ? toRaw(v) : v }];
    } else {
      return ["span", stringStyle, String(v)];
    }
  }
  function extractKeys(instance, type) {
    const Comp = instance.type;
    if (isFunction(Comp)) {
      return;
    }
    const extracted = {};
    for (const key in instance.ctx) {
      if (isKeyOfType(Comp, key, type)) {
        extracted[key] = instance.ctx[key];
      }
    }
    return extracted;
  }
  function isKeyOfType(Comp, key, type) {
    const opts = Comp[type];
    if (isArray(opts) && opts.includes(key) || isObject(opts) && key in opts) {
      return true;
    }
    if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
      return true;
    }
    if (Comp.mixins && Comp.mixins.some((m) => isKeyOfType(m, key, type))) {
      return true;
    }
  }
  function genRefFlag(v) {
    if (isShallow(v)) {
      return `ShallowRef`;
    }
    if (v.effect) {
      return `ComputedRef`;
    }
    return `Ref`;
  }
  if (window.devtoolsFormatters) {
    window.devtoolsFormatters.push(formatter);
  } else {
    window.devtoolsFormatters = [formatter];
  }
}

function withMemo(memo, render, cache, index) {
  const cached = cache[index];
  if (cached && isMemoSame(cached, memo)) {
    return cached;
  }
  const ret = render();
  ret.memo = memo.slice();
  return cache[index] = ret;
}
function isMemoSame(cached, memo) {
  const prev = cached.memo;
  if (prev.length != memo.length) {
    return false;
  }
  for (let i = 0; i < prev.length; i++) {
    if (hasChanged(prev[i], memo[i])) {
      return false;
    }
  }
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(cached);
  }
  return true;
}

const version = "3.4.21";
const warn =  false ? 0 : NOOP;
const ErrorTypeStrings = ErrorTypeStrings$1 ;
const devtools =  true ? devtools$1 : 0;
const setDevtoolsHook =  true ? setDevtoolsHook$1 : 0;
const _ssrUtils = {
  createComponentInstance,
  setupComponent,
  renderComponentRoot,
  setCurrentRenderingInstance,
  isVNode: isVNode,
  normalizeVNode
};
const ssrUtils = _ssrUtils ;
const resolveFilter = resolveFilter$1 ;
const _compatUtils = {
  warnDeprecation: warnDeprecation$1,
  createCompatVue: createCompatVue$1,
  isCompatEnabled: isCompatEnabled$1,
  checkCompatEnabled: checkCompatEnabled$1,
  softAssertCompatEnabled
};
const compatUtils = _compatUtils ;
const DeprecationTypes = DeprecationTypes$1 ;

const svgNS = "http://www.w3.org/2000/svg";
const mathmlNS = "http://www.w3.org/1998/Math/MathML";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, namespace, is, props) => {
    const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : doc.createElement(tag, is ? { is } : void 0);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id) {
    el.setAttribute(id, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent, anchor, namespace, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling))
          break;
      }
    } else {
      templateContainer.innerHTML = namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content;
      const template = templateContainer.content;
      if (namespace === "svg" || namespace === "mathml") {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      // first
      before ? before.nextSibling : parent.firstChild,
      // last
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};

const TRANSITION$1 = "transition";
const ANIMATION = "animation";
const vtcKey = Symbol("_vtc");
const Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);
Transition.displayName = "Transition";
{
  Transition.__isBuiltIn = true;
}
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
const TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend(
  {},
  BaseTransitionPropsValidators,
  DOMTransitionPropsValidators
);
const callHook = (hook, args = []) => {
  if (isArray(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? isArray(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const {
    name = "v",
    type,
    duration,
    enterFromClass = `${name}-enter-from`,
    enterActiveClass = `${name}-enter-active`,
    enterToClass = `${name}-enter-to`,
    appearFromClass = enterFromClass,
    appearActiveClass = enterActiveClass,
    appearToClass = enterToClass,
    leaveFromClass = `${name}-leave-from`,
    leaveActiveClass = `${name}-leave-active`,
    leaveToClass = `${name}-leave-to`
  } = rawProps;
  const legacyClassEnabled = compatUtils.isCompatEnabled("TRANSITION_CLASSES", null);
  let legacyEnterFromClass;
  let legacyAppearFromClass;
  let legacyLeaveFromClass;
  if (legacyClassEnabled) {
    const toLegacyClass = (cls) => cls.replace(/-from$/, "");
    if (!rawProps.enterFromClass) {
      legacyEnterFromClass = toLegacyClass(enterFromClass);
    }
    if (!rawProps.appearFromClass) {
      legacyAppearFromClass = toLegacyClass(appearFromClass);
    }
    if (!rawProps.leaveFromClass) {
      legacyLeaveFromClass = toLegacyClass(leaveFromClass);
    }
  }
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const {
    onBeforeEnter,
    onEnter,
    onEnterCancelled,
    onLeave,
    onLeaveCancelled,
    onBeforeAppear = onBeforeEnter,
    onAppear = onEnter,
    onAppearCancelled = onEnterCancelled
  } = baseProps;
  const finishEnter = (el, isAppear, done) => {
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el, done) => {
    el._isLeaving = false;
    removeTransitionClass(el, leaveFromClass);
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve = () => finishEnter(el, isAppear, done);
      callHook(hook, [el, resolve]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        if (legacyClassEnabled) {
          const legacyClass = isAppear ? legacyAppearFromClass : legacyEnterFromClass;
          if (legacyClass) {
            removeTransitionClass(el, legacyClass);
          }
        }
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type, enterDuration, resolve);
        }
      });
    };
  };
  return extend(baseProps, {
    onBeforeEnter(el) {
      callHook(onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      if (legacyClassEnabled && legacyEnterFromClass) {
        addTransitionClass(el, legacyEnterFromClass);
      }
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      if (legacyClassEnabled && legacyAppearFromClass) {
        addTransitionClass(el, legacyAppearFromClass);
      }
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done) {
      el._isLeaving = true;
      const resolve = () => finishLeave(el, done);
      addTransitionClass(el, leaveFromClass);
      if (legacyClassEnabled && legacyLeaveFromClass) {
        addTransitionClass(el, legacyLeaveFromClass);
      }
      forceReflow();
      addTransitionClass(el, leaveActiveClass);
      nextFrame(() => {
        if (!el._isLeaving) {
          return;
        }
        removeTransitionClass(el, leaveFromClass);
        if (legacyClassEnabled && legacyLeaveFromClass) {
          removeTransitionClass(el, legacyLeaveFromClass);
        }
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el, type, leaveDuration, resolve);
        }
      });
      callHook(onLeave, [el, resolve]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false);
      callHook(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true);
      callHook(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook(onLeaveCancelled, [el]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n = NumberOf(duration);
    return [n, n];
  }
}
function NumberOf(val) {
  const res = toNumber(val);
  if (false) {}
  return res;
}
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
  (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el[vtcKey] = void 0;
    }
  }
}
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
  const id = el._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id === el._endId) {
      resolve();
    }
  };
  if (explicitTimeout) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
  if (!type) {
    return resolve();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end = () => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e) => {
    if (e.target === el && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el);
  const getStyleProperties = (key) => (styles[key] || "").split(", ");
  const transitionDelays = getStyleProperties(`${TRANSITION$1}Delay`);
  const transitionDurations = getStyleProperties(`${TRANSITION$1}Duration`);
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION$1) {
    if (transitionTimeout > 0) {
      type = TRANSITION$1;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION$1 : ANIMATION : null;
    propCount = type ? type === TRANSITION$1 ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION$1 && /\b(transform|all)(,|$)/.test(
    getStyleProperties(`${TRANSITION$1}Property`).toString()
  );
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
}
function toMs(s) {
  if (s === "auto")
    return 0;
  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}

function patchClass(el, value, isSVG) {
  const transitionClasses = el[vtcKey];
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}

const vShowOriginalDisplay = Symbol("_vod");
const vShowHidden = Symbol("_vsh");
const vShow = {
  beforeMount(el, { value }, { transition }) {
    el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
    if (transition && value) {
      transition.beforeEnter(el);
    } else {
      setDisplay(el, value);
    }
  },
  mounted(el, { value }, { transition }) {
    if (transition && value) {
      transition.enter(el);
    }
  },
  updated(el, { value, oldValue }, { transition }) {
    if (!value === !oldValue)
      return;
    if (transition) {
      if (value) {
        transition.beforeEnter(el);
        setDisplay(el, true);
        transition.enter(el);
      } else {
        transition.leave(el, () => {
          setDisplay(el, false);
        });
      }
    } else {
      setDisplay(el, value);
    }
  },
  beforeUnmount(el, { value }) {
    setDisplay(el, value);
  }
};
if (false) {}
function setDisplay(el, value) {
  el.style.display = value ? el[vShowOriginalDisplay] : "none";
  el[vShowHidden] = !value;
}
function initVShowForSSR() {
  vShow.getSSRProps = ({ value }) => {
    if (!value) {
      return { style: { display: "none" } };
    }
  };
}

const CSS_VAR_TEXT = Symbol( false ? 0 : "");
function useCssVars(getter) {
  const instance = getCurrentInstance();
  if (!instance) {
     false && 0;
    return;
  }
  const updateTeleports = instance.ut = (vars = getter(instance.proxy)) => {
    Array.from(
      document.querySelectorAll(`[data-v-owner="${instance.uid}"]`)
    ).forEach((node) => setVarsOnNode(node, vars));
  };
  if (false) {}
  const setVars = () => {
    const vars = getter(instance.proxy);
    setVarsOnVNode(instance.subTree, vars);
    updateTeleports(vars);
  };
  watchPostEffect(setVars);
  onMounted(() => {
    const ob = new MutationObserver(setVars);
    ob.observe(instance.subTree.el.parentNode, { childList: true });
    onUnmounted(() => ob.disconnect());
  });
}
function setVarsOnVNode(vnode, vars) {
  if (vnode.shapeFlag & 128) {
    const suspense = vnode.suspense;
    vnode = suspense.activeBranch;
    if (suspense.pendingBranch && !suspense.isHydrating) {
      suspense.effects.push(() => {
        setVarsOnVNode(suspense.activeBranch, vars);
      });
    }
  }
  while (vnode.component) {
    vnode = vnode.component.subTree;
  }
  if (vnode.shapeFlag & 1 && vnode.el) {
    setVarsOnNode(vnode.el, vars);
  } else if (vnode.type === Fragment) {
    vnode.children.forEach((c) => setVarsOnVNode(c, vars));
  } else if (vnode.type === Static) {
    let { el, anchor } = vnode;
    while (el) {
      setVarsOnNode(el, vars);
      if (el === anchor)
        break;
      el = el.nextSibling;
    }
  }
}
function setVarsOnNode(el, vars) {
  if (el.nodeType === 1) {
    const style = el.style;
    let cssText = "";
    for (const key in vars) {
      style.setProperty(`--${key}`, vars[key]);
      cssText += `--${key}: ${vars[key]};`;
    }
    style[CSS_VAR_TEXT] = cssText;
  }
}

const displayRE = /(^|;)\s*display\s*:/;
function patchStyle(el, prev, next) {
  const style = el.style;
  const isCssString = isString(next);
  let hasControlledDisplay = false;
  if (next && !isCssString) {
    if (prev) {
      if (!isString(prev)) {
        for (const key in prev) {
          if (next[key] == null) {
            setStyle(style, key, "");
          }
        }
      } else {
        for (const prevStyle of prev.split(";")) {
          const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
          if (next[key] == null) {
            setStyle(style, key, "");
          }
        }
      }
    }
    for (const key in next) {
      if (key === "display") {
        hasControlledDisplay = true;
      }
      setStyle(style, key, next[key]);
    }
  } else {
    if (isCssString) {
      if (prev !== next) {
        const cssVarText = style[CSS_VAR_TEXT];
        if (cssVarText) {
          next += ";" + cssVarText;
        }
        style.cssText = next;
        hasControlledDisplay = displayRE.test(next);
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
  }
  if (vShowOriginalDisplay in el) {
    el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
    if (el[vShowHidden]) {
      style.display = "none";
    }
  }
}
const semicolonRE = /[^\\];\s*$/;
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
  if (isArray(val)) {
    val.forEach((v) => setStyle(style, name, v));
  } else {
    if (val == null)
      val = "";
    if (false) {}
    if (name.startsWith("--")) {
      style.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style, name);
      if (importantRE.test(val)) {
        style.setProperty(
          hyphenate(prefixed),
          val.replace(importantRE, ""),
          "important"
        );
      } else {
        style[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize(rawName);
  if (name !== "filter" && name in style) {
    return prefixCache[rawName] = name;
  }
  name = capitalize(name);
  for (let i = 0; i < prefixes.length; i++) {
    const prefixed = prefixes[i] + name;
    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}

const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    if (compatCoerceAttr(el, key, value, instance)) {
      return;
    }
    const isBoolean = isSpecialBooleanAttr(key);
    if (value == null || isBoolean && !includeBooleanAttr(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, isBoolean ? "" : value);
    }
  }
}
const isEnumeratedAttr = /* @__PURE__ */ makeMap("contenteditable,draggable,spellcheck") ;
function compatCoerceAttr(el, key, value, instance = null) {
  if (isEnumeratedAttr(key)) {
    const v2CoercedValue = value === null ? "false" : typeof value !== "boolean" && value !== void 0 ? "true" : null;
    if (v2CoercedValue && compatUtils.softAssertCompatEnabled(
      "ATTR_ENUMERATED_COERCION",
      instance,
      key,
      value,
      v2CoercedValue
    )) {
      el.setAttribute(key, v2CoercedValue);
      return true;
    }
  } else if (value === false && !isSpecialBooleanAttr(key) && compatUtils.softAssertCompatEnabled(
    "ATTR_FALSE_VALUE",
    instance,
    key
  )) {
    el.removeAttribute(key);
    return true;
  }
  return false;
}

function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key === "innerHTML" || key === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el[key] = value == null ? "" : value;
    return;
  }
  const tag = el.tagName;
  if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
  !tag.includes("-")) {
    const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
    const newValue = value == null ? "" : value;
    if (oldValue !== newValue || !("_value" in el)) {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key);
    }
    el._value = value;
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type === "string") {
      value = "";
      needRemove = true;
    } else if (type === "number") {
      value = 0;
      needRemove = true;
    }
  } else {
    if (value === false && compatUtils.isCompatEnabled(
      "ATTR_FALSE_VALUE",
      parentComponent
    )) {
      const type = typeof el[key];
      if (type === "string" || type === "number") {
         false && 0;
        value = type === "number" ? 0 : "";
        needRemove = true;
      }
    }
  }
  try {
    el[key] = value;
  } catch (e) {
    if (false) {}
  }
  needRemove && el.removeAttribute(key);
}

function addEventListener(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
const veiKey = Symbol("_vei");
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el[veiKey] || (el[veiKey] = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(nextValue, instance);
      addEventListener(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m;
    while (m = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m[0].length);
      options[m[0].toLowerCase()] = true;
    }
  }
  const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
  return [event, options];
}
let cachedNow = 0;
const p = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = (e) => {
    if (!e._vts) {
      e._vts = Date.now();
    } else if (e._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(
      patchStopImmediatePropagation(e, invoker.value),
      instance,
      5,
      [e]
    );
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e, value) {
  if (isArray(value)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value.map((fn) => (e2) => !e2._stopped && fn && fn(e2));
  } else {
    return value;
  }
}

const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
const patchProp = (el, key, prevValue, nextValue, namespace, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  const isSVG = namespace === "svg";
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(
      el,
      key,
      nextValue,
      prevChildren,
      parentComponent,
      parentSuspense,
      unmountChildren
    );
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG, parentComponent);
  }
};
function shouldSetAsProp(el, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && isNativeOn(key) && isFunction(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (key === "width" || key === "height") {
    const tag = el.tagName;
    if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
      return false;
    }
  }
  if (isNativeOn(key) && isString(value)) {
    return false;
  }
  return key in el;
}

/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineCustomElement(options, hydrate2) {
  const Comp = defineComponent(options);
  class VueCustomElement extends VueElement {
    constructor(initialProps) {
      super(Comp, initialProps, hydrate2);
    }
  }
  VueCustomElement.def = Comp;
  return VueCustomElement;
}
/*! #__NO_SIDE_EFFECTS__ */
const defineSSRCustomElement = /* @__NO_SIDE_EFFECTS__ */ (options) => {
  return /* @__PURE__ */ defineCustomElement(options, hydrate);
};
const BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
};
class VueElement extends BaseClass {
  constructor(_def, _props = {}, hydrate2) {
    super();
    this._def = _def;
    this._props = _props;
    /**
     * @internal
     */
    this._instance = null;
    this._connected = false;
    this._resolved = false;
    this._numberProps = null;
    this._ob = null;
    if (this.shadowRoot && hydrate2) {
      hydrate2(this._createVNode(), this.shadowRoot);
    } else {
      if (false) {}
      this.attachShadow({ mode: "open" });
      if (!this._def.__asyncLoader) {
        this._resolveProps(this._def);
      }
    }
  }
  connectedCallback() {
    this._connected = true;
    if (!this._instance) {
      if (this._resolved) {
        this._update();
      } else {
        this._resolveDef();
      }
    }
  }
  disconnectedCallback() {
    this._connected = false;
    if (this._ob) {
      this._ob.disconnect();
      this._ob = null;
    }
    nextTick(() => {
      if (!this._connected) {
        render(null, this.shadowRoot);
        this._instance = null;
      }
    });
  }
  /**
   * resolve inner component definition (handle possible async component)
   */
  _resolveDef() {
    this._resolved = true;
    for (let i = 0; i < this.attributes.length; i++) {
      this._setAttr(this.attributes[i].name);
    }
    this._ob = new MutationObserver((mutations) => {
      for (const m of mutations) {
        this._setAttr(m.attributeName);
      }
    });
    this._ob.observe(this, { attributes: true });
    const resolve = (def, isAsync = false) => {
      const { props, styles } = def;
      let numberProps;
      if (props && !isArray(props)) {
        for (const key in props) {
          const opt = props[key];
          if (opt === Number || opt && opt.type === Number) {
            if (key in this._props) {
              this._props[key] = toNumber(this._props[key]);
            }
            (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[camelize(key)] = true;
          }
        }
      }
      this._numberProps = numberProps;
      if (isAsync) {
        this._resolveProps(def);
      }
      this._applyStyles(styles);
      this._update();
    };
    const asyncDef = this._def.__asyncLoader;
    if (asyncDef) {
      asyncDef().then((def) => resolve(def, true));
    } else {
      resolve(this._def);
    }
  }
  _resolveProps(def) {
    const { props } = def;
    const declaredPropKeys = isArray(props) ? props : Object.keys(props || {});
    for (const key of Object.keys(this)) {
      if (key[0] !== "_" && declaredPropKeys.includes(key)) {
        this._setProp(key, this[key], true, false);
      }
    }
    for (const key of declaredPropKeys.map(camelize)) {
      Object.defineProperty(this, key, {
        get() {
          return this._getProp(key);
        },
        set(val) {
          this._setProp(key, val);
        }
      });
    }
  }
  _setAttr(key) {
    let value = this.getAttribute(key);
    const camelKey = camelize(key);
    if (this._numberProps && this._numberProps[camelKey]) {
      value = toNumber(value);
    }
    this._setProp(camelKey, value, false);
  }
  /**
   * @internal
   */
  _getProp(key) {
    return this._props[key];
  }
  /**
   * @internal
   */
  _setProp(key, val, shouldReflect = true, shouldUpdate = true) {
    if (val !== this._props[key]) {
      this._props[key] = val;
      if (shouldUpdate && this._instance) {
        this._update();
      }
      if (shouldReflect) {
        if (val === true) {
          this.setAttribute(hyphenate(key), "");
        } else if (typeof val === "string" || typeof val === "number") {
          this.setAttribute(hyphenate(key), val + "");
        } else if (!val) {
          this.removeAttribute(hyphenate(key));
        }
      }
    }
  }
  _update() {
    render(this._createVNode(), this.shadowRoot);
  }
  _createVNode() {
    const vnode = createVNode(this._def, extend({}, this._props));
    if (!this._instance) {
      vnode.ce = (instance) => {
        this._instance = instance;
        instance.isCE = true;
        if (false) {}
        const dispatch = (event, args) => {
          this.dispatchEvent(
            new CustomEvent(event, {
              detail: args
            })
          );
        };
        instance.emit = (event, ...args) => {
          dispatch(event, args);
          if (hyphenate(event) !== event) {
            dispatch(hyphenate(event), args);
          }
        };
        let parent = this;
        while (parent = parent && (parent.parentNode || parent.host)) {
          if (parent instanceof VueElement) {
            instance.parent = parent._instance;
            instance.provides = parent._instance.provides;
            break;
          }
        }
      };
    }
    return vnode;
  }
  _applyStyles(styles) {
    if (styles) {
      styles.forEach((css) => {
        const s = document.createElement("style");
        s.textContent = css;
        this.shadowRoot.appendChild(s);
        if (false) {}
      });
    }
  }
}

function useCssModule(name = "$style") {
  {
    const instance = getCurrentInstance();
    if (!instance) {
       false && 0;
      return EMPTY_OBJ;
    }
    const modules = instance.type.__cssModules;
    if (!modules) {
       false && 0;
      return EMPTY_OBJ;
    }
    const mod = modules[name];
    if (!mod) {
       false && 0;
      return EMPTY_OBJ;
    }
    return mod;
  }
}

const positionMap = /* @__PURE__ */ new WeakMap();
const newPositionMap = /* @__PURE__ */ new WeakMap();
const moveCbKey = Symbol("_moveCb");
const enterCbKey = Symbol("_enterCb");
const TransitionGroupImpl = {
  name: "TransitionGroup",
  props: /* @__PURE__ */ extend({}, TransitionPropsValidators, {
    tag: String,
    moveClass: String
  }),
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevChildren;
    let children;
    onUpdated(() => {
      if (!prevChildren.length) {
        return;
      }
      const moveClass = props.moveClass || `${props.name || "v"}-move`;
      if (!hasCSSTransform(
        prevChildren[0].el,
        instance.vnode.el,
        moveClass
      )) {
        return;
      }
      prevChildren.forEach(callPendingCbs);
      prevChildren.forEach(recordPosition);
      const movedChildren = prevChildren.filter(applyTranslation);
      forceReflow();
      movedChildren.forEach((c) => {
        const el = c.el;
        const style = el.style;
        addTransitionClass(el, moveClass);
        style.transform = style.webkitTransform = style.transitionDuration = "";
        const cb = el[moveCbKey] = (e) => {
          if (e && e.target !== el) {
            return;
          }
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener("transitionend", cb);
            el[moveCbKey] = null;
            removeTransitionClass(el, moveClass);
          }
        };
        el.addEventListener("transitionend", cb);
      });
    });
    return () => {
      const rawProps = toRaw(props);
      const cssTransitionProps = resolveTransitionProps(rawProps);
      let tag = rawProps.tag || Fragment;
      if (!rawProps.tag && compatUtils.checkCompatEnabled(
        "TRANSITION_GROUP_ROOT",
        instance.parent
      )) {
        tag = "span";
      }
      prevChildren = children;
      children = slots.default ? getTransitionRawChildren(slots.default()) : [];
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (child.key != null) {
          setTransitionHooks(
            child,
            resolveTransitionHooks(child, cssTransitionProps, state, instance)
          );
        } else if (false) {}
      }
      if (prevChildren) {
        for (let i = 0; i < prevChildren.length; i++) {
          const child = prevChildren[i];
          setTransitionHooks(
            child,
            resolveTransitionHooks(child, cssTransitionProps, state, instance)
          );
          positionMap.set(child, child.el.getBoundingClientRect());
        }
      }
      return createVNode(tag, null, children);
    };
  }
};
{
  TransitionGroupImpl.__isBuiltIn = true;
}
const removeMode = (props) => delete props.mode;
/* @__PURE__ */ removeMode(TransitionGroupImpl.props);
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c) {
  const el = c.el;
  if (el[moveCbKey]) {
    el[moveCbKey]();
  }
  if (el[enterCbKey]) {
    el[enterCbKey]();
  }
}
function recordPosition(c) {
  newPositionMap.set(c, c.el.getBoundingClientRect());
}
function applyTranslation(c) {
  const oldPos = positionMap.get(c);
  const newPos = newPositionMap.get(c);
  const dx = oldPos.left - newPos.left;
  const dy = oldPos.top - newPos.top;
  if (dx || dy) {
    const s = c.el.style;
    s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
    s.transitionDuration = "0s";
    return c;
  }
}
function hasCSSTransform(el, root, moveClass) {
  const clone = el.cloneNode();
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.forEach((cls) => {
      cls.split(/\s+/).forEach((c) => c && clone.classList.remove(c));
    });
  }
  moveClass.split(/\s+/).forEach((c) => c && clone.classList.add(c));
  clone.style.display = "none";
  const container = root.nodeType === 1 ? root : root.parentNode;
  container.appendChild(clone);
  const { hasTransform } = getTransitionInfo(clone);
  container.removeChild(clone);
  return hasTransform;
}

const getModelAssigner = (vnode) => {
  const fn = vnode.props["onUpdate:modelValue"] || vnode.props["onModelCompat:input"];
  return isArray(fn) ? (value) => invokeArrayFns(fn, value) : fn;
};
function onCompositionStart(e) {
  e.target.composing = true;
}
function onCompositionEnd(e) {
  const target = e.target;
  if (target.composing) {
    target.composing = false;
    target.dispatchEvent(new Event("input"));
  }
}
const assignKey = Symbol("_assign");
const vModelText = {
  created(el, { modifiers: { lazy, trim, number } }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    const castToNumber = number || vnode.props && vnode.props.type === "number";
    addEventListener(el, lazy ? "change" : "input", (e) => {
      if (e.target.composing)
        return;
      let domValue = el.value;
      if (trim) {
        domValue = domValue.trim();
      }
      if (castToNumber) {
        domValue = looseToNumber(domValue);
      }
      el[assignKey](domValue);
    });
    if (trim) {
      addEventListener(el, "change", () => {
        el.value = el.value.trim();
      });
    }
    if (!lazy) {
      addEventListener(el, "compositionstart", onCompositionStart);
      addEventListener(el, "compositionend", onCompositionEnd);
      addEventListener(el, "change", onCompositionEnd);
    }
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(el, { value }) {
    el.value = value == null ? "" : value;
  },
  beforeUpdate(el, { value, modifiers: { lazy, trim, number } }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    if (el.composing)
      return;
    const elValue = number || el.type === "number" ? looseToNumber(el.value) : el.value;
    const newValue = value == null ? "" : value;
    if (elValue === newValue) {
      return;
    }
    if (document.activeElement === el && el.type !== "range") {
      if (lazy) {
        return;
      }
      if (trim && el.value.trim() === newValue) {
        return;
      }
    }
    el.value = newValue;
  }
};
const vModelCheckbox = {
  // #4096 array checkboxes need to be deep traversed
  deep: true,
  created(el, _, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    addEventListener(el, "change", () => {
      const modelValue = el._modelValue;
      const elementValue = getValue(el);
      const checked = el.checked;
      const assign = el[assignKey];
      if (isArray(modelValue)) {
        const index = looseIndexOf(modelValue, elementValue);
        const found = index !== -1;
        if (checked && !found) {
          assign(modelValue.concat(elementValue));
        } else if (!checked && found) {
          const filtered = [...modelValue];
          filtered.splice(index, 1);
          assign(filtered);
        }
      } else if (isSet(modelValue)) {
        const cloned = new Set(modelValue);
        if (checked) {
          cloned.add(elementValue);
        } else {
          cloned.delete(elementValue);
        }
        assign(cloned);
      } else {
        assign(getCheckboxValue(el, checked));
      }
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: setChecked,
  beforeUpdate(el, binding, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    setChecked(el, binding, vnode);
  }
};
function setChecked(el, { value, oldValue }, vnode) {
  el._modelValue = value;
  if (isArray(value)) {
    el.checked = looseIndexOf(value, vnode.props.value) > -1;
  } else if (isSet(value)) {
    el.checked = value.has(vnode.props.value);
  } else if (value !== oldValue) {
    el.checked = looseEqual(value, getCheckboxValue(el, true));
  }
}
const vModelRadio = {
  created(el, { value }, vnode) {
    el.checked = looseEqual(value, vnode.props.value);
    el[assignKey] = getModelAssigner(vnode);
    addEventListener(el, "change", () => {
      el[assignKey](getValue(el));
    });
  },
  beforeUpdate(el, { value, oldValue }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    if (value !== oldValue) {
      el.checked = looseEqual(value, vnode.props.value);
    }
  }
};
const vModelSelect = {
  // <select multiple> value need to be deep traversed
  deep: true,
  created(el, { value, modifiers: { number } }, vnode) {
    const isSetModel = isSet(value);
    addEventListener(el, "change", () => {
      const selectedVal = Array.prototype.filter.call(el.options, (o) => o.selected).map(
        (o) => number ? looseToNumber(getValue(o)) : getValue(o)
      );
      el[assignKey](
        el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]
      );
      el._assigning = true;
      nextTick(() => {
        el._assigning = false;
      });
    });
    el[assignKey] = getModelAssigner(vnode);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(el, { value, modifiers: { number } }) {
    setSelected(el, value, number);
  },
  beforeUpdate(el, _binding, vnode) {
    el[assignKey] = getModelAssigner(vnode);
  },
  updated(el, { value, modifiers: { number } }) {
    if (!el._assigning) {
      setSelected(el, value, number);
    }
  }
};
function setSelected(el, value, number) {
  const isMultiple = el.multiple;
  const isArrayValue = isArray(value);
  if (isMultiple && !isArrayValue && !isSet(value)) {
     false && 0;
    return;
  }
  for (let i = 0, l = el.options.length; i < l; i++) {
    const option = el.options[i];
    const optionValue = getValue(option);
    if (isMultiple) {
      if (isArrayValue) {
        const optionType = typeof optionValue;
        if (optionType === "string" || optionType === "number") {
          option.selected = value.includes(
            number ? looseToNumber(optionValue) : optionValue
          );
        } else {
          option.selected = looseIndexOf(value, optionValue) > -1;
        }
      } else {
        option.selected = value.has(optionValue);
      }
    } else if (looseEqual(getValue(option), value)) {
      if (el.selectedIndex !== i)
        el.selectedIndex = i;
      return;
    }
  }
  if (!isMultiple && el.selectedIndex !== -1) {
    el.selectedIndex = -1;
  }
}
function getValue(el) {
  return "_value" in el ? el._value : el.value;
}
function getCheckboxValue(el, checked) {
  const key = checked ? "_trueValue" : "_falseValue";
  return key in el ? el[key] : checked;
}
const vModelDynamic = {
  created(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "created");
  },
  mounted(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "mounted");
  },
  beforeUpdate(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
  },
  updated(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "updated");
  }
};
function resolveDynamicModel(tagName, type) {
  switch (tagName) {
    case "SELECT":
      return vModelSelect;
    case "TEXTAREA":
      return vModelText;
    default:
      switch (type) {
        case "checkbox":
          return vModelCheckbox;
        case "radio":
          return vModelRadio;
        default:
          return vModelText;
      }
  }
}
function callModelHook(el, binding, vnode, prevVNode, hook) {
  const modelToUse = resolveDynamicModel(
    el.tagName,
    vnode.props && vnode.props.type
  );
  const fn = modelToUse[hook];
  fn && fn(el, binding, vnode, prevVNode);
}
function initVModelForSSR() {
  vModelText.getSSRProps = ({ value }) => ({ value });
  vModelRadio.getSSRProps = ({ value }, vnode) => {
    if (vnode.props && looseEqual(vnode.props.value, value)) {
      return { checked: true };
    }
  };
  vModelCheckbox.getSSRProps = ({ value }, vnode) => {
    if (isArray(value)) {
      if (vnode.props && looseIndexOf(value, vnode.props.value) > -1) {
        return { checked: true };
      }
    } else if (isSet(value)) {
      if (vnode.props && value.has(vnode.props.value)) {
        return { checked: true };
      }
    } else if (value) {
      return { checked: true };
    }
  };
  vModelDynamic.getSSRProps = (binding, vnode) => {
    if (typeof vnode.type !== "string") {
      return;
    }
    const modelToUse = resolveDynamicModel(
      // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
      vnode.type.toUpperCase(),
      vnode.props && vnode.props.type
    );
    if (modelToUse.getSSRProps) {
      return modelToUse.getSSRProps(binding, vnode);
    }
  };
}

const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: (e) => e.stopPropagation(),
  prevent: (e) => e.preventDefault(),
  self: (e) => e.target !== e.currentTarget,
  ctrl: (e) => !e.ctrlKey,
  shift: (e) => !e.shiftKey,
  alt: (e) => !e.altKey,
  meta: (e) => !e.metaKey,
  left: (e) => "button" in e && e.button !== 0,
  middle: (e) => "button" in e && e.button !== 1,
  right: (e) => "button" in e && e.button !== 2,
  exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
};
const withModifiers = (fn, modifiers) => {
  const cache = fn._withMods || (fn._withMods = {});
  const cacheKey = modifiers.join(".");
  return cache[cacheKey] || (cache[cacheKey] = (event, ...args) => {
    for (let i = 0; i < modifiers.length; i++) {
      const guard = modifierGuards[modifiers[i]];
      if (guard && guard(event, modifiers))
        return;
    }
    return fn(event, ...args);
  });
};
const keyNames = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
};
const withKeys = (fn, modifiers) => {
  let globalKeyCodes;
  let instance = null;
  {
    instance = getCurrentInstance();
    if (compatUtils.isCompatEnabled("CONFIG_KEY_CODES", instance)) {
      if (instance) {
        globalKeyCodes = instance.appContext.config.keyCodes;
      }
    }
    if (false) {}
  }
  const cache = fn._withKeys || (fn._withKeys = {});
  const cacheKey = modifiers.join(".");
  return cache[cacheKey] || (cache[cacheKey] = (event) => {
    if (!("key" in event)) {
      return;
    }
    const eventKey = hyphenate(event.key);
    if (modifiers.some((k) => k === eventKey || keyNames[k] === eventKey)) {
      return fn(event);
    }
    {
      const keyCode = String(event.keyCode);
      if (compatUtils.isCompatEnabled(
        "V_ON_KEYCODE_MODIFIER",
        instance
      ) && modifiers.some((mod) => mod == keyCode)) {
        return fn(event);
      }
      if (globalKeyCodes) {
        for (const mod of modifiers) {
          const codes = globalKeyCodes[mod];
          if (codes) {
            const matches = isArray(codes) ? codes.some((code) => String(code) === keyCode) : String(codes) === keyCode;
            if (matches) {
              return fn(event);
            }
          }
        }
      }
    }
  });
};

const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
let renderer;
let enabledHydration = false;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
function ensureHydrationRenderer() {
  renderer = enabledHydration ? renderer : createHydrationRenderer(rendererOptions);
  enabledHydration = true;
  return renderer;
}
const render = (...args) => {
  ensureRenderer().render(...args);
};
const hydrate = (...args) => {
  ensureHydrationRenderer().hydrate(...args);
};
const createApp = (...args) => {
  const app = ensureRenderer().createApp(...args);
  if (false) {}
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container)
      return;
    const component = app._component;
    if (!isFunction(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
      if (false) {}
    }
    container.innerHTML = "";
    const proxy = mount(container, false, resolveRootNamespace(container));
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app;
};
const createSSRApp = (...args) => {
  const app = ensureHydrationRenderer().createApp(...args);
  if (false) {}
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (container) {
      return mount(container, true, resolveRootNamespace(container));
    }
  };
  return app;
};
function resolveRootNamespace(container) {
  if (container instanceof SVGElement) {
    return "svg";
  }
  if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
    return "mathml";
  }
}
function injectNativeTagCheck(app) {
  Object.defineProperty(app.config, "isNativeTag", {
    value: (tag) => isHTMLTag(tag) || isSVGTag(tag) || isMathMLTag(tag),
    writable: false
  });
}
function injectCompilerOptionsCheck(app) {
  if (isRuntimeOnly()) {
    const isCustomElement = app.config.isCustomElement;
    Object.defineProperty(app.config, "isCustomElement", {
      get() {
        return isCustomElement;
      },
      set() {
        warn(
          `The \`isCustomElement\` config option is deprecated. Use \`compilerOptions.isCustomElement\` instead.`
        );
      }
    });
    const compilerOptions = app.config.compilerOptions;
    const msg = `The \`compilerOptions\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, \`compilerOptions\` must be passed to \`@vue/compiler-dom\` in the build setup instead.
- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.
- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader
- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc`;
    Object.defineProperty(app.config, "compilerOptions", {
      get() {
        warn(msg);
        return compilerOptions;
      },
      set() {
        warn(msg);
      }
    });
  }
}
function normalizeContainer(container) {
  if (isString(container)) {
    const res = document.querySelector(container);
    if (false) {}
    return res;
  }
  if (false) {}
  return container;
}
let ssrDirectiveInitialized = false;
const initDirectivesForSSR = () => {
  if (!ssrDirectiveInitialized) {
    ssrDirectiveInitialized = true;
    initVModelForSSR();
    initVShowForSSR();
  }
} ;

var runtimeDom = /*#__PURE__*/Object.freeze({
  __proto__: null,
  BaseTransition: BaseTransition,
  BaseTransitionPropsValidators: BaseTransitionPropsValidators,
  Comment: Comment,
  DeprecationTypes: DeprecationTypes,
  EffectScope: EffectScope,
  ErrorCodes: ErrorCodes,
  ErrorTypeStrings: ErrorTypeStrings,
  Fragment: Fragment,
  KeepAlive: KeepAlive,
  ReactiveEffect: ReactiveEffect,
  Static: Static,
  Suspense: Suspense,
  Teleport: Teleport,
  Text: Text,
  TrackOpTypes: TrackOpTypes,
  Transition: Transition,
  TransitionGroup: TransitionGroup,
  TriggerOpTypes: TriggerOpTypes,
  VueElement: VueElement,
  assertNumber: assertNumber,
  callWithAsyncErrorHandling: callWithAsyncErrorHandling,
  callWithErrorHandling: callWithErrorHandling,
  camelize: camelize,
  capitalize: capitalize,
  cloneVNode: cloneVNode,
  compatUtils: compatUtils,
  computed: computed,
  createApp: createApp,
  createBlock: createBlock,
  createCommentVNode: createCommentVNode,
  createElementBlock: createElementBlock,
  createElementVNode: createBaseVNode,
  createHydrationRenderer: createHydrationRenderer,
  createPropsRestProxy: createPropsRestProxy,
  createRenderer: createRenderer,
  createSSRApp: createSSRApp,
  createSlots: createSlots,
  createStaticVNode: createStaticVNode,
  createTextVNode: createTextVNode,
  createVNode: createVNode,
  customRef: customRef,
  defineAsyncComponent: defineAsyncComponent,
  defineComponent: defineComponent,
  defineCustomElement: defineCustomElement,
  defineEmits: defineEmits,
  defineExpose: defineExpose,
  defineModel: defineModel,
  defineOptions: defineOptions,
  defineProps: defineProps,
  defineSSRCustomElement: defineSSRCustomElement,
  defineSlots: defineSlots,
  devtools: devtools,
  effect: effect,
  effectScope: effectScope,
  getCurrentInstance: getCurrentInstance,
  getCurrentScope: getCurrentScope,
  getTransitionRawChildren: getTransitionRawChildren,
  guardReactiveProps: guardReactiveProps,
  h: h,
  handleError: handleError,
  hasInjectionContext: hasInjectionContext,
  hydrate: hydrate,
  initCustomFormatter: initCustomFormatter,
  initDirectivesForSSR: initDirectivesForSSR,
  inject: inject,
  isMemoSame: isMemoSame,
  isProxy: isProxy,
  isReactive: isReactive,
  isReadonly: isReadonly,
  isRef: isRef,
  isRuntimeOnly: isRuntimeOnly,
  isShallow: isShallow,
  isVNode: isVNode,
  markRaw: markRaw,
  mergeDefaults: mergeDefaults,
  mergeModels: mergeModels,
  mergeProps: mergeProps,
  nextTick: nextTick,
  normalizeClass: normalizeClass,
  normalizeProps: normalizeProps,
  normalizeStyle: normalizeStyle,
  onActivated: onActivated,
  onBeforeMount: onBeforeMount,
  onBeforeUnmount: onBeforeUnmount,
  onBeforeUpdate: onBeforeUpdate,
  onDeactivated: onDeactivated,
  onErrorCaptured: onErrorCaptured,
  onMounted: onMounted,
  onRenderTracked: onRenderTracked,
  onRenderTriggered: onRenderTriggered,
  onScopeDispose: onScopeDispose,
  onServerPrefetch: onServerPrefetch,
  onUnmounted: onUnmounted,
  onUpdated: onUpdated,
  openBlock: openBlock,
  popScopeId: popScopeId,
  provide: provide,
  proxyRefs: proxyRefs,
  pushScopeId: pushScopeId,
  queuePostFlushCb: queuePostFlushCb,
  reactive: reactive,
  readonly: readonly,
  ref: ref,
  registerRuntimeCompiler: registerRuntimeCompiler,
  render: render,
  renderList: renderList,
  renderSlot: renderSlot,
  resolveComponent: resolveComponent,
  resolveDirective: resolveDirective,
  resolveDynamicComponent: resolveDynamicComponent,
  resolveFilter: resolveFilter,
  resolveTransitionHooks: resolveTransitionHooks,
  setBlockTracking: setBlockTracking,
  setDevtoolsHook: setDevtoolsHook,
  setTransitionHooks: setTransitionHooks,
  shallowReactive: shallowReactive,
  shallowReadonly: shallowReadonly,
  shallowRef: shallowRef,
  ssrContextKey: ssrContextKey,
  ssrUtils: ssrUtils,
  stop: stop,
  toDisplayString: toDisplayString,
  toHandlerKey: toHandlerKey,
  toHandlers: toHandlers,
  toRaw: toRaw,
  toRef: toRef,
  toRefs: toRefs,
  toValue: toValue,
  transformVNodeArgs: transformVNodeArgs,
  triggerRef: triggerRef,
  unref: unref,
  useAttrs: useAttrs,
  useCssModule: useCssModule,
  useCssVars: useCssVars,
  useModel: useModel,
  useSSRContext: useSSRContext,
  useSlots: useSlots,
  useTransitionState: useTransitionState,
  vModelCheckbox: vModelCheckbox,
  vModelDynamic: vModelDynamic,
  vModelRadio: vModelRadio,
  vModelSelect: vModelSelect,
  vModelText: vModelText,
  vShow: vShow,
  version: version,
  warn: warn,
  watch: watch,
  watchEffect: watchEffect,
  watchPostEffect: watchPostEffect,
  watchSyncEffect: watchSyncEffect,
  withAsyncContext: withAsyncContext,
  withCtx: withCtx,
  withDefaults: withDefaults,
  withDirectives: withDirectives,
  withKeys: withKeys,
  withMemo: withMemo,
  withModifiers: withModifiers,
  withScopeId: withScopeId
});

function initDev() {
  {
    initCustomFormatter();
  }
}

if (false) {}
function wrappedCreateApp(...args) {
  const app = createApp(...args);
  if (compatUtils.isCompatEnabled("RENDER_FUNCTION", null)) {
    app.component("__compat__transition", Transition);
    app.component("__compat__transition-group", TransitionGroup);
    app.component("__compat__keep-alive", KeepAlive);
    app._context.directives.show = vShow;
    app._context.directives.model = vModelDynamic;
  }
  return app;
}
function createCompatVue() {
  const Vue = compatUtils.createCompatVue(createApp, wrappedCreateApp);
  extend(Vue, runtimeDom);
  return Vue;
}

const FRAGMENT = Symbol( false ? 0 : ``);
const TELEPORT = Symbol( false ? 0 : ``);
const SUSPENSE = Symbol( false ? 0 : ``);
const KEEP_ALIVE = Symbol( false ? 0 : ``);
const BASE_TRANSITION = Symbol( false ? 0 : ``);
const OPEN_BLOCK = Symbol( false ? 0 : ``);
const CREATE_BLOCK = Symbol( false ? 0 : ``);
const CREATE_ELEMENT_BLOCK = Symbol( false ? 0 : ``);
const CREATE_VNODE = Symbol( false ? 0 : ``);
const CREATE_ELEMENT_VNODE = Symbol( false ? 0 : ``);
const CREATE_COMMENT = Symbol( false ? 0 : ``);
const CREATE_TEXT = Symbol( false ? 0 : ``);
const CREATE_STATIC = Symbol( false ? 0 : ``);
const RESOLVE_COMPONENT = Symbol( false ? 0 : ``);
const RESOLVE_DYNAMIC_COMPONENT = Symbol(
   false ? 0 : ``
);
const RESOLVE_DIRECTIVE = Symbol( false ? 0 : ``);
const RESOLVE_FILTER = Symbol( false ? 0 : ``);
const WITH_DIRECTIVES = Symbol( false ? 0 : ``);
const RENDER_LIST = Symbol( false ? 0 : ``);
const RENDER_SLOT = Symbol( false ? 0 : ``);
const CREATE_SLOTS = Symbol( false ? 0 : ``);
const TO_DISPLAY_STRING = Symbol( false ? 0 : ``);
const MERGE_PROPS = Symbol( false ? 0 : ``);
const NORMALIZE_CLASS = Symbol( false ? 0 : ``);
const NORMALIZE_STYLE = Symbol( false ? 0 : ``);
const NORMALIZE_PROPS = Symbol( false ? 0 : ``);
const GUARD_REACTIVE_PROPS = Symbol( false ? 0 : ``);
const TO_HANDLERS = Symbol( false ? 0 : ``);
const CAMELIZE = Symbol( false ? 0 : ``);
const CAPITALIZE = Symbol( false ? 0 : ``);
const TO_HANDLER_KEY = Symbol( false ? 0 : ``);
const SET_BLOCK_TRACKING = Symbol( false ? 0 : ``);
const PUSH_SCOPE_ID = Symbol( false ? 0 : ``);
const POP_SCOPE_ID = Symbol( false ? 0 : ``);
const WITH_CTX = Symbol( false ? 0 : ``);
const UNREF = Symbol( false ? 0 : ``);
const IS_REF = Symbol( false ? 0 : ``);
const WITH_MEMO = Symbol( false ? 0 : ``);
const IS_MEMO_SAME = Symbol( false ? 0 : ``);
const helperNameMap = {
  [FRAGMENT]: `Fragment`,
  [TELEPORT]: `Teleport`,
  [SUSPENSE]: `Suspense`,
  [KEEP_ALIVE]: `KeepAlive`,
  [BASE_TRANSITION]: `BaseTransition`,
  [OPEN_BLOCK]: `openBlock`,
  [CREATE_BLOCK]: `createBlock`,
  [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
  [CREATE_VNODE]: `createVNode`,
  [CREATE_ELEMENT_VNODE]: `createElementVNode`,
  [CREATE_COMMENT]: `createCommentVNode`,
  [CREATE_TEXT]: `createTextVNode`,
  [CREATE_STATIC]: `createStaticVNode`,
  [RESOLVE_COMPONENT]: `resolveComponent`,
  [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
  [RESOLVE_DIRECTIVE]: `resolveDirective`,
  [RESOLVE_FILTER]: `resolveFilter`,
  [WITH_DIRECTIVES]: `withDirectives`,
  [RENDER_LIST]: `renderList`,
  [RENDER_SLOT]: `renderSlot`,
  [CREATE_SLOTS]: `createSlots`,
  [TO_DISPLAY_STRING]: `toDisplayString`,
  [MERGE_PROPS]: `mergeProps`,
  [NORMALIZE_CLASS]: `normalizeClass`,
  [NORMALIZE_STYLE]: `normalizeStyle`,
  [NORMALIZE_PROPS]: `normalizeProps`,
  [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
  [TO_HANDLERS]: `toHandlers`,
  [CAMELIZE]: `camelize`,
  [CAPITALIZE]: `capitalize`,
  [TO_HANDLER_KEY]: `toHandlerKey`,
  [SET_BLOCK_TRACKING]: `setBlockTracking`,
  [PUSH_SCOPE_ID]: `pushScopeId`,
  [POP_SCOPE_ID]: `popScopeId`,
  [WITH_CTX]: `withCtx`,
  [UNREF]: `unref`,
  [IS_REF]: `isRef`,
  [WITH_MEMO]: `withMemo`,
  [IS_MEMO_SAME]: `isMemoSame`
};
function registerRuntimeHelpers(helpers) {
  Object.getOwnPropertySymbols(helpers).forEach((s) => {
    helperNameMap[s] = helpers[s];
  });
}

const locStub = {
  start: { line: 1, column: 1, offset: 0 },
  end: { line: 1, column: 1, offset: 0 },
  source: ""
};
function createRoot(children, source = "") {
  return {
    type: 0,
    source,
    children,
    helpers: /* @__PURE__ */ new Set(),
    components: [],
    directives: [],
    hoists: [],
    imports: [],
    cached: 0,
    temps: 0,
    codegenNode: void 0,
    loc: locStub
  };
}
function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent = false, loc = locStub) {
  if (context) {
    if (isBlock) {
      context.helper(OPEN_BLOCK);
      context.helper(getVNodeBlockHelper(context.inSSR, isComponent));
    } else {
      context.helper(getVNodeHelper(context.inSSR, isComponent));
    }
    if (directives) {
      context.helper(WITH_DIRECTIVES);
    }
  }
  return {
    type: 13,
    tag,
    props,
    children,
    patchFlag,
    dynamicProps,
    directives,
    isBlock,
    disableTracking,
    isComponent,
    loc
  };
}
function createArrayExpression(elements, loc = locStub) {
  return {
    type: 17,
    loc,
    elements
  };
}
function createObjectExpression(properties, loc = locStub) {
  return {
    type: 15,
    loc,
    properties
  };
}
function createObjectProperty(key, value) {
  return {
    type: 16,
    loc: locStub,
    key: isString(key) ? createSimpleExpression(key, true) : key,
    value
  };
}
function createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0) {
  return {
    type: 4,
    loc,
    content,
    isStatic,
    constType: isStatic ? 3 : constType
  };
}
function createCompoundExpression(children, loc = locStub) {
  return {
    type: 8,
    loc,
    children
  };
}
function createCallExpression(callee, args = [], loc = locStub) {
  return {
    type: 14,
    loc,
    callee,
    arguments: args
  };
}
function createFunctionExpression(params, returns = void 0, newline = false, isSlot = false, loc = locStub) {
  return {
    type: 18,
    params,
    returns,
    newline,
    isSlot,
    loc
  };
}
function createConditionalExpression(test, consequent, alternate, newline = true) {
  return {
    type: 19,
    test,
    consequent,
    alternate,
    newline,
    loc: locStub
  };
}
function createCacheExpression(index, value, isVNode = false) {
  return {
    type: 20,
    index,
    value,
    isVNode,
    loc: locStub
  };
}
function createBlockStatement(body) {
  return {
    type: 21,
    body,
    loc: locStub
  };
}
function getVNodeHelper(ssr, isComponent) {
  return ssr || isComponent ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
}
function getVNodeBlockHelper(ssr, isComponent) {
  return ssr || isComponent ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
}
function convertToBlock(node, { helper, removeHelper, inSSR }) {
  if (!node.isBlock) {
    node.isBlock = true;
    removeHelper(getVNodeHelper(inSSR, node.isComponent));
    helper(OPEN_BLOCK);
    helper(getVNodeBlockHelper(inSSR, node.isComponent));
  }
}

const defaultDelimitersOpen = new Uint8Array([123, 123]);
const defaultDelimitersClose = new Uint8Array([125, 125]);
function isTagStartChar(c) {
  return c >= 97 && c <= 122 || c >= 65 && c <= 90;
}
function isWhitespace(c) {
  return c === 32 || c === 10 || c === 9 || c === 12 || c === 13;
}
function isEndOfTagSection(c) {
  return c === 47 || c === 62 || isWhitespace(c);
}
function toCharCodes(str) {
  const ret = new Uint8Array(str.length);
  for (let i = 0; i < str.length; i++) {
    ret[i] = str.charCodeAt(i);
  }
  return ret;
}
const Sequences = {
  Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
  // CDATA[
  CdataEnd: new Uint8Array([93, 93, 62]),
  // ]]>
  CommentEnd: new Uint8Array([45, 45, 62]),
  // `-->`
  ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
  // `<\/script`
  StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
  // `</style`
  TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]),
  // `</title`
  TextareaEnd: new Uint8Array([
    60,
    47,
    116,
    101,
    120,
    116,
    97,
    114,
    101,
    97
  ])
  // `</textarea
};
class Tokenizer {
  constructor(stack, cbs) {
    this.stack = stack;
    this.cbs = cbs;
    /** The current state the tokenizer is in. */
    this.state = 1;
    /** The read buffer. */
    this.buffer = "";
    /** The beginning of the section that is currently being read. */
    this.sectionStart = 0;
    /** The index within the buffer that we are currently looking at. */
    this.index = 0;
    /** The start of the last entity. */
    this.entityStart = 0;
    /** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */
    this.baseState = 1;
    /** For special parsing behavior inside of script and style tags. */
    this.inRCDATA = false;
    /** For disabling RCDATA tags handling */
    this.inXML = false;
    /** For disabling interpolation parsing in v-pre */
    this.inVPre = false;
    /** Record newline positions for fast line / column calculation */
    this.newlines = [];
    this.mode = 0;
    this.delimiterOpen = defaultDelimitersOpen;
    this.delimiterClose = defaultDelimitersClose;
    this.delimiterIndex = -1;
    this.currentSequence = void 0;
    this.sequenceIndex = 0;
  }
  get inSFCRoot() {
    return this.mode === 2 && this.stack.length === 0;
  }
  reset() {
    this.state = 1;
    this.mode = 0;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = 1;
    this.inRCDATA = false;
    this.currentSequence = void 0;
    this.newlines.length = 0;
    this.delimiterOpen = defaultDelimitersOpen;
    this.delimiterClose = defaultDelimitersClose;
  }
  /**
   * Generate Position object with line / column information using recorded
   * newline positions. We know the index is always going to be an already
   * processed index, so all the newlines up to this index should have been
   * recorded.
   */
  getPos(index) {
    let line = 1;
    let column = index + 1;
    for (let i = this.newlines.length - 1; i >= 0; i--) {
      const newlineIndex = this.newlines[i];
      if (index > newlineIndex) {
        line = i + 2;
        column = index - newlineIndex;
        break;
      }
    }
    return {
      column,
      line,
      offset: index
    };
  }
  peek() {
    return this.buffer.charCodeAt(this.index + 1);
  }
  stateText(c) {
    if (c === 60) {
      if (this.index > this.sectionStart) {
        this.cbs.ontext(this.sectionStart, this.index);
      }
      this.state = 5;
      this.sectionStart = this.index;
    } else if (!this.inVPre && c === this.delimiterOpen[0]) {
      this.state = 2;
      this.delimiterIndex = 0;
      this.stateInterpolationOpen(c);
    }
  }
  stateInterpolationOpen(c) {
    if (c === this.delimiterOpen[this.delimiterIndex]) {
      if (this.delimiterIndex === this.delimiterOpen.length - 1) {
        const start = this.index + 1 - this.delimiterOpen.length;
        if (start > this.sectionStart) {
          this.cbs.ontext(this.sectionStart, start);
        }
        this.state = 3;
        this.sectionStart = start;
      } else {
        this.delimiterIndex++;
      }
    } else if (this.inRCDATA) {
      this.state = 32;
      this.stateInRCDATA(c);
    } else {
      this.state = 1;
      this.stateText(c);
    }
  }
  stateInterpolation(c) {
    if (c === this.delimiterClose[0]) {
      this.state = 4;
      this.delimiterIndex = 0;
      this.stateInterpolationClose(c);
    }
  }
  stateInterpolationClose(c) {
    if (c === this.delimiterClose[this.delimiterIndex]) {
      if (this.delimiterIndex === this.delimiterClose.length - 1) {
        this.cbs.oninterpolation(this.sectionStart, this.index + 1);
        if (this.inRCDATA) {
          this.state = 32;
        } else {
          this.state = 1;
        }
        this.sectionStart = this.index + 1;
      } else {
        this.delimiterIndex++;
      }
    } else {
      this.state = 3;
      this.stateInterpolation(c);
    }
  }
  stateSpecialStartSequence(c) {
    const isEnd = this.sequenceIndex === this.currentSequence.length;
    const isMatch = isEnd ? (
      // If we are at the end of the sequence, make sure the tag name has ended
      isEndOfTagSection(c)
    ) : (
      // Otherwise, do a case-insensitive comparison
      (c | 32) === this.currentSequence[this.sequenceIndex]
    );
    if (!isMatch) {
      this.inRCDATA = false;
    } else if (!isEnd) {
      this.sequenceIndex++;
      return;
    }
    this.sequenceIndex = 0;
    this.state = 6;
    this.stateInTagName(c);
  }
  /** Look for an end tag. For <title> and <textarea>, also decode entities. */
  stateInRCDATA(c) {
    if (this.sequenceIndex === this.currentSequence.length) {
      if (c === 62 || isWhitespace(c)) {
        const endOfText = this.index - this.currentSequence.length;
        if (this.sectionStart < endOfText) {
          const actualIndex = this.index;
          this.index = endOfText;
          this.cbs.ontext(this.sectionStart, endOfText);
          this.index = actualIndex;
        }
        this.sectionStart = endOfText + 2;
        this.stateInClosingTagName(c);
        this.inRCDATA = false;
        return;
      }
      this.sequenceIndex = 0;
    }
    if ((c | 32) === this.currentSequence[this.sequenceIndex]) {
      this.sequenceIndex += 1;
    } else if (this.sequenceIndex === 0) {
      if (this.currentSequence === Sequences.TitleEnd || this.currentSequence === Sequences.TextareaEnd && !this.inSFCRoot) {
        if (c === this.delimiterOpen[0]) {
          this.state = 2;
          this.delimiterIndex = 0;
          this.stateInterpolationOpen(c);
        }
      } else if (this.fastForwardTo(60)) {
        this.sequenceIndex = 1;
      }
    } else {
      this.sequenceIndex = Number(c === 60);
    }
  }
  stateCDATASequence(c) {
    if (c === Sequences.Cdata[this.sequenceIndex]) {
      if (++this.sequenceIndex === Sequences.Cdata.length) {
        this.state = 28;
        this.currentSequence = Sequences.CdataEnd;
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
      }
    } else {
      this.sequenceIndex = 0;
      this.state = 23;
      this.stateInDeclaration(c);
    }
  }
  /**
   * When we wait for one specific character, we can speed things up
   * by skipping through the buffer until we find it.
   *
   * @returns Whether the character was found.
   */
  fastForwardTo(c) {
    while (++this.index < this.buffer.length) {
      const cc = this.buffer.charCodeAt(this.index);
      if (cc === 10) {
        this.newlines.push(this.index);
      }
      if (cc === c) {
        return true;
      }
    }
    this.index = this.buffer.length - 1;
    return false;
  }
  /**
   * Comments and CDATA end with `-->` and `]]>`.
   *
   * Their common qualities are:
   * - Their end sequences have a distinct character they start with.
   * - That character is then repeated, so we have to check multiple repeats.
   * - All characters but the start character of the sequence can be skipped.
   */
  stateInCommentLike(c) {
    if (c === this.currentSequence[this.sequenceIndex]) {
      if (++this.sequenceIndex === this.currentSequence.length) {
        if (this.currentSequence === Sequences.CdataEnd) {
          this.cbs.oncdata(this.sectionStart, this.index - 2);
        } else {
          this.cbs.oncomment(this.sectionStart, this.index - 2);
        }
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
        this.state = 1;
      }
    } else if (this.sequenceIndex === 0) {
      if (this.fastForwardTo(this.currentSequence[0])) {
        this.sequenceIndex = 1;
      }
    } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
      this.sequenceIndex = 0;
    }
  }
  startSpecial(sequence, offset) {
    this.enterRCDATA(sequence, offset);
    this.state = 31;
  }
  enterRCDATA(sequence, offset) {
    this.inRCDATA = true;
    this.currentSequence = sequence;
    this.sequenceIndex = offset;
  }
  stateBeforeTagName(c) {
    if (c === 33) {
      this.state = 22;
      this.sectionStart = this.index + 1;
    } else if (c === 63) {
      this.state = 24;
      this.sectionStart = this.index + 1;
    } else if (isTagStartChar(c)) {
      this.sectionStart = this.index;
      if (this.mode === 0) {
        this.state = 6;
      } else if (this.inSFCRoot) {
        this.state = 34;
      } else if (!this.inXML) {
        if (c === 116) {
          this.state = 30;
        } else {
          this.state = c === 115 ? 29 : 6;
        }
      } else {
        this.state = 6;
      }
    } else if (c === 47) {
      this.state = 8;
    } else {
      this.state = 1;
      this.stateText(c);
    }
  }
  stateInTagName(c) {
    if (isEndOfTagSection(c)) {
      this.handleTagName(c);
    }
  }
  stateInSFCRootTagName(c) {
    if (isEndOfTagSection(c)) {
      const tag = this.buffer.slice(this.sectionStart, this.index);
      if (tag !== "template") {
        this.enterRCDATA(toCharCodes(`</` + tag), 0);
      }
      this.handleTagName(c);
    }
  }
  handleTagName(c) {
    this.cbs.onopentagname(this.sectionStart, this.index);
    this.sectionStart = -1;
    this.state = 11;
    this.stateBeforeAttrName(c);
  }
  stateBeforeClosingTagName(c) {
    if (isWhitespace(c)) ; else if (c === 62) {
      if (false) {}
      this.state = 1;
      this.sectionStart = this.index + 1;
    } else {
      this.state = isTagStartChar(c) ? 9 : 27;
      this.sectionStart = this.index;
    }
  }
  stateInClosingTagName(c) {
    if (c === 62 || isWhitespace(c)) {
      this.cbs.onclosetag(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = 10;
      this.stateAfterClosingTagName(c);
    }
  }
  stateAfterClosingTagName(c) {
    if (c === 62) {
      this.state = 1;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeAttrName(c) {
    if (c === 62) {
      this.cbs.onopentagend(this.index);
      if (this.inRCDATA) {
        this.state = 32;
      } else {
        this.state = 1;
      }
      this.sectionStart = this.index + 1;
    } else if (c === 47) {
      this.state = 7;
      if (false) {}
    } else if (c === 60 && this.peek() === 47) {
      this.cbs.onopentagend(this.index);
      this.state = 5;
      this.sectionStart = this.index;
    } else if (!isWhitespace(c)) {
      if (false) {}
      this.handleAttrStart(c);
    }
  }
  handleAttrStart(c) {
    if (c === 118 && this.peek() === 45) {
      this.state = 13;
      this.sectionStart = this.index;
    } else if (c === 46 || c === 58 || c === 64 || c === 35) {
      this.cbs.ondirname(this.index, this.index + 1);
      this.state = 14;
      this.sectionStart = this.index + 1;
    } else {
      this.state = 12;
      this.sectionStart = this.index;
    }
  }
  stateInSelfClosingTag(c) {
    if (c === 62) {
      this.cbs.onselfclosingtag(this.index);
      this.state = 1;
      this.sectionStart = this.index + 1;
      this.inRCDATA = false;
    } else if (!isWhitespace(c)) {
      this.state = 11;
      this.stateBeforeAttrName(c);
    }
  }
  stateInAttrName(c) {
    if (c === 61 || isEndOfTagSection(c)) {
      this.cbs.onattribname(this.sectionStart, this.index);
      this.handleAttrNameEnd(c);
    } else if (false) {}
  }
  stateInDirName(c) {
    if (c === 61 || isEndOfTagSection(c)) {
      this.cbs.ondirname(this.sectionStart, this.index);
      this.handleAttrNameEnd(c);
    } else if (c === 58) {
      this.cbs.ondirname(this.sectionStart, this.index);
      this.state = 14;
      this.sectionStart = this.index + 1;
    } else if (c === 46) {
      this.cbs.ondirname(this.sectionStart, this.index);
      this.state = 16;
      this.sectionStart = this.index + 1;
    }
  }
  stateInDirArg(c) {
    if (c === 61 || isEndOfTagSection(c)) {
      this.cbs.ondirarg(this.sectionStart, this.index);
      this.handleAttrNameEnd(c);
    } else if (c === 91) {
      this.state = 15;
    } else if (c === 46) {
      this.cbs.ondirarg(this.sectionStart, this.index);
      this.state = 16;
      this.sectionStart = this.index + 1;
    }
  }
  stateInDynamicDirArg(c) {
    if (c === 93) {
      this.state = 14;
    } else if (c === 61 || isEndOfTagSection(c)) {
      this.cbs.ondirarg(this.sectionStart, this.index + 1);
      this.handleAttrNameEnd(c);
      if (false) {}
    }
  }
  stateInDirModifier(c) {
    if (c === 61 || isEndOfTagSection(c)) {
      this.cbs.ondirmodifier(this.sectionStart, this.index);
      this.handleAttrNameEnd(c);
    } else if (c === 46) {
      this.cbs.ondirmodifier(this.sectionStart, this.index);
      this.sectionStart = this.index + 1;
    }
  }
  handleAttrNameEnd(c) {
    this.sectionStart = this.index;
    this.state = 17;
    this.cbs.onattribnameend(this.index);
    this.stateAfterAttrName(c);
  }
  stateAfterAttrName(c) {
    if (c === 61) {
      this.state = 18;
    } else if (c === 47 || c === 62) {
      this.cbs.onattribend(0, this.sectionStart);
      this.sectionStart = -1;
      this.state = 11;
      this.stateBeforeAttrName(c);
    } else if (!isWhitespace(c)) {
      this.cbs.onattribend(0, this.sectionStart);
      this.handleAttrStart(c);
    }
  }
  stateBeforeAttrValue(c) {
    if (c === 34) {
      this.state = 19;
      this.sectionStart = this.index + 1;
    } else if (c === 39) {
      this.state = 20;
      this.sectionStart = this.index + 1;
    } else if (!isWhitespace(c)) {
      this.sectionStart = this.index;
      this.state = 21;
      this.stateInAttrValueNoQuotes(c);
    }
  }
  handleInAttrValue(c, quote) {
    if (c === quote || this.fastForwardTo(quote)) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(
        quote === 34 ? 3 : 2,
        this.index + 1
      );
      this.state = 11;
    }
  }
  stateInAttrValueDoubleQuotes(c) {
    this.handleInAttrValue(c, 34);
  }
  stateInAttrValueSingleQuotes(c) {
    this.handleInAttrValue(c, 39);
  }
  stateInAttrValueNoQuotes(c) {
    if (isWhitespace(c) || c === 62) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(1, this.index);
      this.state = 11;
      this.stateBeforeAttrName(c);
    } else if ( false || c === 39 || c === 60 || c === 61 || c === 96) {
      this.cbs.onerr(
        18,
        this.index
      );
    } else ;
  }
  stateBeforeDeclaration(c) {
    if (c === 91) {
      this.state = 26;
      this.sequenceIndex = 0;
    } else {
      this.state = c === 45 ? 25 : 23;
    }
  }
  stateInDeclaration(c) {
    if (c === 62 || this.fastForwardTo(62)) {
      this.state = 1;
      this.sectionStart = this.index + 1;
    }
  }
  stateInProcessingInstruction(c) {
    if (c === 62 || this.fastForwardTo(62)) {
      this.cbs.onprocessinginstruction(this.sectionStart, this.index);
      this.state = 1;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeComment(c) {
    if (c === 45) {
      this.state = 28;
      this.currentSequence = Sequences.CommentEnd;
      this.sequenceIndex = 2;
      this.sectionStart = this.index + 1;
    } else {
      this.state = 23;
    }
  }
  stateInSpecialComment(c) {
    if (c === 62 || this.fastForwardTo(62)) {
      this.cbs.oncomment(this.sectionStart, this.index);
      this.state = 1;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeSpecialS(c) {
    if (c === Sequences.ScriptEnd[3]) {
      this.startSpecial(Sequences.ScriptEnd, 4);
    } else if (c === Sequences.StyleEnd[3]) {
      this.startSpecial(Sequences.StyleEnd, 4);
    } else {
      this.state = 6;
      this.stateInTagName(c);
    }
  }
  stateBeforeSpecialT(c) {
    if (c === Sequences.TitleEnd[3]) {
      this.startSpecial(Sequences.TitleEnd, 4);
    } else if (c === Sequences.TextareaEnd[3]) {
      this.startSpecial(Sequences.TextareaEnd, 4);
    } else {
      this.state = 6;
      this.stateInTagName(c);
    }
  }
  startEntity() {
  }
  stateInEntity() {
  }
  /**
   * Iterates through the buffer, calling the function corresponding to the current state.
   *
   * States that are more likely to be hit are higher up, as a performance improvement.
   */
  parse(input) {
    this.buffer = input;
    while (this.index < this.buffer.length) {
      const c = this.buffer.charCodeAt(this.index);
      if (c === 10) {
        this.newlines.push(this.index);
      }
      switch (this.state) {
        case 1: {
          this.stateText(c);
          break;
        }
        case 2: {
          this.stateInterpolationOpen(c);
          break;
        }
        case 3: {
          this.stateInterpolation(c);
          break;
        }
        case 4: {
          this.stateInterpolationClose(c);
          break;
        }
        case 31: {
          this.stateSpecialStartSequence(c);
          break;
        }
        case 32: {
          this.stateInRCDATA(c);
          break;
        }
        case 26: {
          this.stateCDATASequence(c);
          break;
        }
        case 19: {
          this.stateInAttrValueDoubleQuotes(c);
          break;
        }
        case 12: {
          this.stateInAttrName(c);
          break;
        }
        case 13: {
          this.stateInDirName(c);
          break;
        }
        case 14: {
          this.stateInDirArg(c);
          break;
        }
        case 15: {
          this.stateInDynamicDirArg(c);
          break;
        }
        case 16: {
          this.stateInDirModifier(c);
          break;
        }
        case 28: {
          this.stateInCommentLike(c);
          break;
        }
        case 27: {
          this.stateInSpecialComment(c);
          break;
        }
        case 11: {
          this.stateBeforeAttrName(c);
          break;
        }
        case 6: {
          this.stateInTagName(c);
          break;
        }
        case 34: {
          this.stateInSFCRootTagName(c);
          break;
        }
        case 9: {
          this.stateInClosingTagName(c);
          break;
        }
        case 5: {
          this.stateBeforeTagName(c);
          break;
        }
        case 17: {
          this.stateAfterAttrName(c);
          break;
        }
        case 20: {
          this.stateInAttrValueSingleQuotes(c);
          break;
        }
        case 18: {
          this.stateBeforeAttrValue(c);
          break;
        }
        case 8: {
          this.stateBeforeClosingTagName(c);
          break;
        }
        case 10: {
          this.stateAfterClosingTagName(c);
          break;
        }
        case 29: {
          this.stateBeforeSpecialS(c);
          break;
        }
        case 30: {
          this.stateBeforeSpecialT(c);
          break;
        }
        case 21: {
          this.stateInAttrValueNoQuotes(c);
          break;
        }
        case 7: {
          this.stateInSelfClosingTag(c);
          break;
        }
        case 23: {
          this.stateInDeclaration(c);
          break;
        }
        case 22: {
          this.stateBeforeDeclaration(c);
          break;
        }
        case 25: {
          this.stateBeforeComment(c);
          break;
        }
        case 24: {
          this.stateInProcessingInstruction(c);
          break;
        }
        case 33: {
          this.stateInEntity();
          break;
        }
      }
      this.index++;
    }
    this.cleanup();
    this.finish();
  }
  /**
   * Remove data that has already been consumed from the buffer.
   */
  cleanup() {
    if (this.sectionStart !== this.index) {
      if (this.state === 1 || this.state === 32 && this.sequenceIndex === 0) {
        this.cbs.ontext(this.sectionStart, this.index);
        this.sectionStart = this.index;
      } else if (this.state === 19 || this.state === 20 || this.state === 21) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = this.index;
      }
    }
  }
  finish() {
    this.handleTrailingData();
    this.cbs.onend();
  }
  /** Handle any trailing data. */
  handleTrailingData() {
    const endIndex = this.buffer.length;
    if (this.sectionStart >= endIndex) {
      return;
    }
    if (this.state === 28) {
      if (this.currentSequence === Sequences.CdataEnd) {
        this.cbs.oncdata(this.sectionStart, endIndex);
      } else {
        this.cbs.oncomment(this.sectionStart, endIndex);
      }
    } else if (this.state === 6 || this.state === 11 || this.state === 18 || this.state === 17 || this.state === 12 || this.state === 13 || this.state === 14 || this.state === 15 || this.state === 16 || this.state === 20 || this.state === 19 || this.state === 21 || this.state === 9) ; else {
      this.cbs.ontext(this.sectionStart, endIndex);
    }
  }
  emitCodePoint(cp, consumed) {
  }
}

const deprecationData = {
  ["COMPILER_IS_ON_ELEMENT"]: {
    message: `Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".`,
    link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`
  },
  ["COMPILER_V_BIND_SYNC"]: {
    message: (key) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${key}.sync\` should be changed to \`v-model:${key}\`.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`
  },
  ["COMPILER_V_BIND_OBJECT_ORDER"]: {
    message: `v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`
  },
  ["COMPILER_V_ON_NATIVE"]: {
    message: `.native modifier for v-on has been removed as is no longer necessary.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`
  },
  ["COMPILER_V_IF_V_FOR_PRECEDENCE"]: {
    message: `v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`
  },
  ["COMPILER_NATIVE_TEMPLATE"]: {
    message: `<template> with no special directives will render as a native template element instead of its inner content in Vue 3.`
  },
  ["COMPILER_INLINE_TEMPLATE"]: {
    message: `"inline-template" has been removed in Vue 3.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`
  },
  ["COMPILER_FILTERS"]: {
    message: `filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`
  }
};
function getCompatValue(key, { compatConfig }) {
  const value = compatConfig && compatConfig[key];
  if (key === "MODE") {
    return value || 3;
  } else {
    return value;
  }
}
function isCompatEnabled(key, context) {
  const mode = getCompatValue("MODE", context);
  const value = getCompatValue(key, context);
  return mode === 3 ? value === true : value !== false;
}
function checkCompatEnabled(key, context, loc, ...args) {
  const enabled = isCompatEnabled(key, context);
  if (false) {}
  return enabled;
}
function warnDeprecation(key, context, loc, ...args) {
  const val = getCompatValue(key, context);
  if (val === "suppress-warning") {
    return;
  }
  const { message, link } = deprecationData[key];
  const msg = `(deprecation ${key}) ${typeof message === "function" ? message(...args) : message}${link ? `
  Details: ${link}` : ``}`;
  const err = new SyntaxError(msg);
  err.code = key;
  if (loc)
    err.loc = loc;
  context.onWarn(err);
}

function defaultOnError(error) {
  throw error;
}
function defaultOnWarn(msg) {
   false && 0;
}
function createCompilerError(code, loc, messages, additionalMessage) {
  const msg =  false ? 0 : `https://vuejs.org/error-reference/#compiler-${code}`;
  const error = new SyntaxError(String(msg));
  error.code = code;
  error.loc = loc;
  return error;
}
const errorMessages = {
  // parse errors
  [0]: "Illegal comment.",
  [1]: "CDATA section is allowed only in XML context.",
  [2]: "Duplicate attribute.",
  [3]: "End tag cannot have attributes.",
  [4]: "Illegal '/' in tags.",
  [5]: "Unexpected EOF in tag.",
  [6]: "Unexpected EOF in CDATA section.",
  [7]: "Unexpected EOF in comment.",
  [8]: "Unexpected EOF in script.",
  [9]: "Unexpected EOF in tag.",
  [10]: "Incorrectly closed comment.",
  [11]: "Incorrectly opened comment.",
  [12]: "Illegal tag name. Use '&lt;' to print '<'.",
  [13]: "Attribute value was expected.",
  [14]: "End tag name was expected.",
  [15]: "Whitespace was expected.",
  [16]: "Unexpected '<!--' in comment.",
  [17]: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`,
  [18]: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
  [19]: "Attribute name cannot start with '='.",
  [21]: "'<?' is allowed only in XML context.",
  [20]: `Unexpected null character.`,
  [22]: "Illegal '/' in tags.",
  // Vue-specific parse errors
  [23]: "Invalid end tag.",
  [24]: "Element is missing end tag.",
  [25]: "Interpolation end sign was not found.",
  [27]: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",
  [26]: "Legal directive name was expected.",
  // transform errors
  [28]: `v-if/v-else-if is missing expression.`,
  [29]: `v-if/else branches must use unique keys.`,
  [30]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,
  [31]: `v-for is missing expression.`,
  [32]: `v-for has invalid expression.`,
  [33]: `<template v-for> key should be placed on the <template> tag.`,
  [34]: `v-bind is missing expression.`,
  [52]: `v-bind with same-name shorthand only allows static argument.`,
  [35]: `v-on is missing expression.`,
  [36]: `Unexpected custom directive on <slot> outlet.`,
  [37]: `Mixed v-slot usage on both the component and nested <template>. When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.`,
  [38]: `Duplicate slot names found. `,
  [39]: `Extraneous children found when component already has explicitly named default slot. These children will be ignored.`,
  [40]: `v-slot can only be used on components or <template> tags.`,
  [41]: `v-model is missing expression.`,
  [42]: `v-model value must be a valid JavaScript member expression.`,
  [43]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
  [44]: `v-model cannot be used on a prop, because local prop bindings are not writable.
Use a v-bind binding combined with a v-on listener that emits update:x event instead.`,
  [45]: `Error parsing JavaScript expression: `,
  [46]: `<KeepAlive> expects exactly one child component.`,
  [51]: `@vnode-* hooks in templates are no longer supported. Use the vue: prefix instead. For example, @vnode-mounted should be changed to @vue:mounted. @vnode-* hooks support has been removed in 3.4.`,
  // generic errors
  [47]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
  [48]: `ES module mode is not supported in this build of compiler.`,
  [49]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
  [50]: `"scopeId" option is only supported in module mode.`,
  // just to fulfill types
  [53]: ``
};

const isStaticExp = (p) => p.type === 4 && p.isStatic;
function isCoreComponent(tag) {
  switch (tag) {
    case "Teleport":
    case "teleport":
      return TELEPORT;
    case "Suspense":
    case "suspense":
      return SUSPENSE;
    case "KeepAlive":
    case "keep-alive":
      return KEEP_ALIVE;
    case "BaseTransition":
    case "base-transition":
      return BASE_TRANSITION;
  }
}
const nonIdentifierRE = /^\d|[^\$\w]/;
const isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
const validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
const validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
const whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
const isMemberExpressionBrowser = (path) => {
  path = path.trim().replace(whitespaceRE, (s) => s.trim());
  let state = 0 /* inMemberExp */;
  let stateStack = [];
  let currentOpenBracketCount = 0;
  let currentOpenParensCount = 0;
  let currentStringType = null;
  for (let i = 0; i < path.length; i++) {
    const char = path.charAt(i);
    switch (state) {
      case 0 /* inMemberExp */:
        if (char === "[") {
          stateStack.push(state);
          state = 1 /* inBrackets */;
          currentOpenBracketCount++;
        } else if (char === "(") {
          stateStack.push(state);
          state = 2 /* inParens */;
          currentOpenParensCount++;
        } else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
          return false;
        }
        break;
      case 1 /* inBrackets */:
        if (char === `'` || char === `"` || char === "`") {
          stateStack.push(state);
          state = 3 /* inString */;
          currentStringType = char;
        } else if (char === `[`) {
          currentOpenBracketCount++;
        } else if (char === `]`) {
          if (!--currentOpenBracketCount) {
            state = stateStack.pop();
          }
        }
        break;
      case 2 /* inParens */:
        if (char === `'` || char === `"` || char === "`") {
          stateStack.push(state);
          state = 3 /* inString */;
          currentStringType = char;
        } else if (char === `(`) {
          currentOpenParensCount++;
        } else if (char === `)`) {
          if (i === path.length - 1) {
            return false;
          }
          if (!--currentOpenParensCount) {
            state = stateStack.pop();
          }
        }
        break;
      case 3 /* inString */:
        if (char === currentStringType) {
          state = stateStack.pop();
          currentStringType = null;
        }
        break;
    }
  }
  return !currentOpenBracketCount && !currentOpenParensCount;
};
const isMemberExpression = isMemberExpressionBrowser ;
function assert(condition, msg) {
  if (!condition) {
    throw new Error(msg || `unexpected compiler condition`);
  }
}
function findDir(node, name, allowEmpty = false) {
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 7 && (allowEmpty || p.exp) && (isString(name) ? p.name === name : name.test(p.name))) {
      return p;
    }
  }
}
function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 6) {
      if (dynamicOnly)
        continue;
      if (p.name === name && (p.value || allowEmpty)) {
        return p;
      }
    } else if (p.name === "bind" && (p.exp || allowEmpty) && isStaticArgOf(p.arg, name)) {
      return p;
    }
  }
}
function isStaticArgOf(arg, name) {
  return !!(arg && isStaticExp(arg) && arg.content === name);
}
function hasDynamicKeyVBind(node) {
  return node.props.some(
    (p) => p.type === 7 && p.name === "bind" && (!p.arg || // v-bind="obj"
    p.arg.type !== 4 || // v-bind:[_ctx.foo]
    !p.arg.isStatic)
    // v-bind:[foo]
  );
}
function isText$1(node) {
  return node.type === 5 || node.type === 2;
}
function isVSlot(p) {
  return p.type === 7 && p.name === "slot";
}
function isTemplateNode(node) {
  return node.type === 1 && node.tagType === 3;
}
function isSlotOutlet(node) {
  return node.type === 1 && node.tagType === 2;
}
const propsHelperSet = /* @__PURE__ */ new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
function getUnnormalizedProps(props, callPath = []) {
  if (props && !isString(props) && props.type === 14) {
    const callee = props.callee;
    if (!isString(callee) && propsHelperSet.has(callee)) {
      return getUnnormalizedProps(
        props.arguments[0],
        callPath.concat(props)
      );
    }
  }
  return [props, callPath];
}
function injectProp(node, prop, context) {
  let propsWithInjection;
  let props = node.type === 13 ? node.props : node.arguments[2];
  let callPath = [];
  let parentCall;
  if (props && !isString(props) && props.type === 14) {
    const ret = getUnnormalizedProps(props);
    props = ret[0];
    callPath = ret[1];
    parentCall = callPath[callPath.length - 1];
  }
  if (props == null || isString(props)) {
    propsWithInjection = createObjectExpression([prop]);
  } else if (props.type === 14) {
    const first = props.arguments[0];
    if (!isString(first) && first.type === 15) {
      if (!hasProp(prop, first)) {
        first.properties.unshift(prop);
      }
    } else {
      if (props.callee === TO_HANDLERS) {
        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
          createObjectExpression([prop]),
          props
        ]);
      } else {
        props.arguments.unshift(createObjectExpression([prop]));
      }
    }
    !propsWithInjection && (propsWithInjection = props);
  } else if (props.type === 15) {
    if (!hasProp(prop, props)) {
      props.properties.unshift(prop);
    }
    propsWithInjection = props;
  } else {
    propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
      createObjectExpression([prop]),
      props
    ]);
    if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
      parentCall = callPath[callPath.length - 2];
    }
  }
  if (node.type === 13) {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.props = propsWithInjection;
    }
  } else {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.arguments[2] = propsWithInjection;
    }
  }
}
function hasProp(prop, props) {
  let result = false;
  if (prop.key.type === 4) {
    const propKeyName = prop.key.content;
    result = props.properties.some(
      (p) => p.key.type === 4 && p.key.content === propKeyName
    );
  }
  return result;
}
function toValidAssetId(name, type) {
  return `_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) => {
    return searchValue === "-" ? "_" : name.charCodeAt(replaceValue).toString();
  })}`;
}
function getMemoedVNodeCall(node) {
  if (node.type === 14 && node.callee === WITH_MEMO) {
    return node.arguments[1].returns;
  } else {
    return node;
  }
}
const forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;

const defaultParserOptions = {
  parseMode: "base",
  ns: 0,
  delimiters: [`{{`, `}}`],
  getNamespace: () => 0,
  isVoidTag: NO,
  isPreTag: NO,
  isCustomElement: NO,
  onError: defaultOnError,
  onWarn: defaultOnWarn,
  comments: !!("production" !== "production"),
  prefixIdentifiers: false
};
let currentOptions = defaultParserOptions;
let currentRoot = null;
let currentInput = "";
let currentOpenTag = null;
let currentProp = null;
let currentAttrValue = "";
let currentAttrStartIndex = -1;
let currentAttrEndIndex = -1;
let inPre = 0;
let inVPre = false;
let currentVPreBoundary = null;
const stack = [];
const tokenizer = new Tokenizer(stack, {
  onerr: emitError,
  ontext(start, end) {
    onText(getSlice(start, end), start, end);
  },
  ontextentity(char, start, end) {
    onText(char, start, end);
  },
  oninterpolation(start, end) {
    if (inVPre) {
      return onText(getSlice(start, end), start, end);
    }
    let innerStart = start + tokenizer.delimiterOpen.length;
    let innerEnd = end - tokenizer.delimiterClose.length;
    while (isWhitespace(currentInput.charCodeAt(innerStart))) {
      innerStart++;
    }
    while (isWhitespace(currentInput.charCodeAt(innerEnd - 1))) {
      innerEnd--;
    }
    let exp = getSlice(innerStart, innerEnd);
    if (exp.includes("&")) {
      {
        exp = currentOptions.decodeEntities(exp, false);
      }
    }
    addNode({
      type: 5,
      content: createExp(exp, false, getLoc(innerStart, innerEnd)),
      loc: getLoc(start, end)
    });
  },
  onopentagname(start, end) {
    const name = getSlice(start, end);
    currentOpenTag = {
      type: 1,
      tag: name,
      ns: currentOptions.getNamespace(name, stack[0], currentOptions.ns),
      tagType: 0,
      // will be refined on tag close
      props: [],
      children: [],
      loc: getLoc(start - 1, end),
      codegenNode: void 0
    };
  },
  onopentagend(end) {
    endOpenTag(end);
  },
  onclosetag(start, end) {
    const name = getSlice(start, end);
    if (!currentOptions.isVoidTag(name)) {
      let found = false;
      for (let i = 0; i < stack.length; i++) {
        const e = stack[i];
        if (e.tag.toLowerCase() === name.toLowerCase()) {
          found = true;
          if (i > 0) {
            emitError(24, stack[0].loc.start.offset);
          }
          for (let j = 0; j <= i; j++) {
            const el = stack.shift();
            onCloseTag(el, end, j < i);
          }
          break;
        }
      }
      if (!found) {
        emitError(23, backTrack(start, 60));
      }
    }
  },
  onselfclosingtag(end) {
    var _a;
    const name = currentOpenTag.tag;
    currentOpenTag.isSelfClosing = true;
    endOpenTag(end);
    if (((_a = stack[0]) == null ? void 0 : _a.tag) === name) {
      onCloseTag(stack.shift(), end);
    }
  },
  onattribname(start, end) {
    currentProp = {
      type: 6,
      name: getSlice(start, end),
      nameLoc: getLoc(start, end),
      value: void 0,
      loc: getLoc(start)
    };
  },
  ondirname(start, end) {
    const raw = getSlice(start, end);
    const name = raw === "." || raw === ":" ? "bind" : raw === "@" ? "on" : raw === "#" ? "slot" : raw.slice(2);
    if (!inVPre && name === "") {
      emitError(26, start);
    }
    if (inVPre || name === "") {
      currentProp = {
        type: 6,
        name: raw,
        nameLoc: getLoc(start, end),
        value: void 0,
        loc: getLoc(start)
      };
    } else {
      currentProp = {
        type: 7,
        name,
        rawName: raw,
        exp: void 0,
        arg: void 0,
        modifiers: raw === "." ? ["prop"] : [],
        loc: getLoc(start)
      };
      if (name === "pre") {
        inVPre = tokenizer.inVPre = true;
        currentVPreBoundary = currentOpenTag;
        const props = currentOpenTag.props;
        for (let i = 0; i < props.length; i++) {
          if (props[i].type === 7) {
            props[i] = dirToAttr(props[i]);
          }
        }
      }
    }
  },
  ondirarg(start, end) {
    if (start === end)
      return;
    const arg = getSlice(start, end);
    if (inVPre) {
      currentProp.name += arg;
      setLocEnd(currentProp.nameLoc, end);
    } else {
      const isStatic = arg[0] !== `[`;
      currentProp.arg = createExp(
        isStatic ? arg : arg.slice(1, -1),
        isStatic,
        getLoc(start, end),
        isStatic ? 3 : 0
      );
    }
  },
  ondirmodifier(start, end) {
    const mod = getSlice(start, end);
    if (inVPre) {
      currentProp.name += "." + mod;
      setLocEnd(currentProp.nameLoc, end);
    } else if (currentProp.name === "slot") {
      const arg = currentProp.arg;
      if (arg) {
        arg.content += "." + mod;
        setLocEnd(arg.loc, end);
      }
    } else {
      currentProp.modifiers.push(mod);
    }
  },
  onattribdata(start, end) {
    currentAttrValue += getSlice(start, end);
    if (currentAttrStartIndex < 0)
      currentAttrStartIndex = start;
    currentAttrEndIndex = end;
  },
  onattribentity(char, start, end) {
    currentAttrValue += char;
    if (currentAttrStartIndex < 0)
      currentAttrStartIndex = start;
    currentAttrEndIndex = end;
  },
  onattribnameend(end) {
    const start = currentProp.loc.start.offset;
    const name = getSlice(start, end);
    if (currentProp.type === 7) {
      currentProp.rawName = name;
    }
    if (currentOpenTag.props.some(
      (p) => (p.type === 7 ? p.rawName : p.name) === name
    )) {
      emitError(2, start);
    }
  },
  onattribend(quote, end) {
    if (currentOpenTag && currentProp) {
      setLocEnd(currentProp.loc, end);
      if (quote !== 0) {
        if (currentAttrValue.includes("&")) {
          currentAttrValue = currentOptions.decodeEntities(
            currentAttrValue,
            true
          );
        }
        if (currentProp.type === 6) {
          if (currentProp.name === "class") {
            currentAttrValue = condense(currentAttrValue).trim();
          }
          if (quote === 1 && !currentAttrValue) {
            emitError(13, end);
          }
          currentProp.value = {
            type: 2,
            content: currentAttrValue,
            loc: quote === 1 ? getLoc(currentAttrStartIndex, currentAttrEndIndex) : getLoc(currentAttrStartIndex - 1, currentAttrEndIndex + 1)
          };
          if (tokenizer.inSFCRoot && currentOpenTag.tag === "template" && currentProp.name === "lang" && currentAttrValue && currentAttrValue !== "html") {
            tokenizer.enterRCDATA(toCharCodes(`</template`), 0);
          }
        } else {
          let expParseMode = 0 /* Normal */;
          currentProp.exp = createExp(
            currentAttrValue,
            false,
            getLoc(currentAttrStartIndex, currentAttrEndIndex),
            0,
            expParseMode
          );
          if (currentProp.name === "for") {
            currentProp.forParseResult = parseForExpression(currentProp.exp);
          }
          let syncIndex = -1;
          if (currentProp.name === "bind" && (syncIndex = currentProp.modifiers.indexOf("sync")) > -1 && checkCompatEnabled(
            "COMPILER_V_BIND_SYNC",
            currentOptions,
            currentProp.loc,
            currentProp.rawName
          )) {
            currentProp.name = "model";
            currentProp.modifiers.splice(syncIndex, 1);
          }
        }
      }
      if (currentProp.type !== 7 || currentProp.name !== "pre") {
        currentOpenTag.props.push(currentProp);
      }
    }
    currentAttrValue = "";
    currentAttrStartIndex = currentAttrEndIndex = -1;
  },
  oncomment(start, end) {
    if (currentOptions.comments) {
      addNode({
        type: 3,
        content: getSlice(start, end),
        loc: getLoc(start - 4, end + 3)
      });
    }
  },
  onend() {
    const end = currentInput.length;
    if (false) {}
    for (let index = 0; index < stack.length; index++) {
      onCloseTag(stack[index], end - 1);
      emitError(24, stack[index].loc.start.offset);
    }
  },
  oncdata(start, end) {
    if (stack[0].ns !== 0) {
      onText(getSlice(start, end), start, end);
    } else {
      emitError(1, start - 9);
    }
  },
  onprocessinginstruction(start) {
    if ((stack[0] ? stack[0].ns : currentOptions.ns) === 0) {
      emitError(
        21,
        start - 1
      );
    }
  }
});
const forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
const stripParensRE = /^\(|\)$/g;
function parseForExpression(input) {
  const loc = input.loc;
  const exp = input.content;
  const inMatch = exp.match(forAliasRE);
  if (!inMatch)
    return;
  const [, LHS, RHS] = inMatch;
  const createAliasExpression = (content, offset, asParam = false) => {
    const start = loc.start.offset + offset;
    const end = start + content.length;
    return createExp(
      content,
      false,
      getLoc(start, end),
      0,
      asParam ? 1 /* Params */ : 0 /* Normal */
    );
  };
  const result = {
    source: createAliasExpression(RHS.trim(), exp.indexOf(RHS, LHS.length)),
    value: void 0,
    key: void 0,
    index: void 0,
    finalized: false
  };
  let valueContent = LHS.trim().replace(stripParensRE, "").trim();
  const trimmedOffset = LHS.indexOf(valueContent);
  const iteratorMatch = valueContent.match(forIteratorRE);
  if (iteratorMatch) {
    valueContent = valueContent.replace(forIteratorRE, "").trim();
    const keyContent = iteratorMatch[1].trim();
    let keyOffset;
    if (keyContent) {
      keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
      result.key = createAliasExpression(keyContent, keyOffset, true);
    }
    if (iteratorMatch[2]) {
      const indexContent = iteratorMatch[2].trim();
      if (indexContent) {
        result.index = createAliasExpression(
          indexContent,
          exp.indexOf(
            indexContent,
            result.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length
          ),
          true
        );
      }
    }
  }
  if (valueContent) {
    result.value = createAliasExpression(valueContent, trimmedOffset, true);
  }
  return result;
}
function getSlice(start, end) {
  return currentInput.slice(start, end);
}
function endOpenTag(end) {
  if (tokenizer.inSFCRoot) {
    currentOpenTag.innerLoc = getLoc(end + 1, end + 1);
  }
  addNode(currentOpenTag);
  const { tag, ns } = currentOpenTag;
  if (ns === 0 && currentOptions.isPreTag(tag)) {
    inPre++;
  }
  if (currentOptions.isVoidTag(tag)) {
    onCloseTag(currentOpenTag, end);
  } else {
    stack.unshift(currentOpenTag);
    if (ns === 1 || ns === 2) {
      tokenizer.inXML = true;
    }
  }
  currentOpenTag = null;
}
function onText(content, start, end) {
  var _a;
  {
    const tag = (_a = stack[0]) == null ? void 0 : _a.tag;
    if (tag !== "script" && tag !== "style" && content.includes("&")) {
      content = currentOptions.decodeEntities(content, false);
    }
  }
  const parent = stack[0] || currentRoot;
  const lastNode = parent.children[parent.children.length - 1];
  if ((lastNode == null ? void 0 : lastNode.type) === 2) {
    lastNode.content += content;
    setLocEnd(lastNode.loc, end);
  } else {
    parent.children.push({
      type: 2,
      content,
      loc: getLoc(start, end)
    });
  }
}
function onCloseTag(el, end, isImplied = false) {
  if (isImplied) {
    setLocEnd(el.loc, backTrack(end, 60));
  } else {
    setLocEnd(el.loc, end + 1);
  }
  if (tokenizer.inSFCRoot) {
    if (el.children.length) {
      el.innerLoc.end = extend({}, el.children[el.children.length - 1].loc.end);
    } else {
      el.innerLoc.end = extend({}, el.innerLoc.start);
    }
    el.innerLoc.source = getSlice(
      el.innerLoc.start.offset,
      el.innerLoc.end.offset
    );
  }
  const { tag, ns } = el;
  if (!inVPre) {
    if (tag === "slot") {
      el.tagType = 2;
    } else if (isFragmentTemplate(el)) {
      el.tagType = 3;
    } else if (isComponent(el)) {
      el.tagType = 1;
    }
  }
  if (!tokenizer.inRCDATA) {
    el.children = condenseWhitespace(el.children, el.tag);
  }
  if (ns === 0 && currentOptions.isPreTag(tag)) {
    inPre--;
  }
  if (currentVPreBoundary === el) {
    inVPre = tokenizer.inVPre = false;
    currentVPreBoundary = null;
  }
  if (tokenizer.inXML && (stack[0] ? stack[0].ns : currentOptions.ns) === 0) {
    tokenizer.inXML = false;
  }
  {
    const props = el.props;
    if (false) {}
    if (!tokenizer.inSFCRoot && isCompatEnabled(
      "COMPILER_NATIVE_TEMPLATE",
      currentOptions
    ) && el.tag === "template" && !isFragmentTemplate(el)) {
       false && 0;
      const parent = stack[0] || currentRoot;
      const index = parent.children.indexOf(el);
      parent.children.splice(index, 1, ...el.children);
    }
    const inlineTemplateProp = props.find(
      (p) => p.type === 6 && p.name === "inline-template"
    );
    if (inlineTemplateProp && checkCompatEnabled(
      "COMPILER_INLINE_TEMPLATE",
      currentOptions,
      inlineTemplateProp.loc
    ) && el.children.length) {
      inlineTemplateProp.value = {
        type: 2,
        content: getSlice(
          el.children[0].loc.start.offset,
          el.children[el.children.length - 1].loc.end.offset
        ),
        loc: inlineTemplateProp.loc
      };
    }
  }
}
function backTrack(index, c) {
  let i = index;
  while (currentInput.charCodeAt(i) !== c && i >= 0)
    i--;
  return i;
}
const specialTemplateDir = /* @__PURE__ */ new Set(["if", "else", "else-if", "for", "slot"]);
function isFragmentTemplate({ tag, props }) {
  if (tag === "template") {
    for (let i = 0; i < props.length; i++) {
      if (props[i].type === 7 && specialTemplateDir.has(props[i].name)) {
        return true;
      }
    }
  }
  return false;
}
function isComponent({ tag, props }) {
  var _a;
  if (currentOptions.isCustomElement(tag)) {
    return false;
  }
  if (tag === "component" || isUpperCase(tag.charCodeAt(0)) || isCoreComponent(tag) || ((_a = currentOptions.isBuiltInComponent) == null ? void 0 : _a.call(currentOptions, tag)) || currentOptions.isNativeTag && !currentOptions.isNativeTag(tag)) {
    return true;
  }
  for (let i = 0; i < props.length; i++) {
    const p = props[i];
    if (p.type === 6) {
      if (p.name === "is" && p.value) {
        if (p.value.content.startsWith("vue:")) {
          return true;
        } else if (checkCompatEnabled(
          "COMPILER_IS_ON_ELEMENT",
          currentOptions,
          p.loc
        )) {
          return true;
        }
      }
    } else if (// :is on plain element - only treat as component in compat mode
    p.name === "bind" && isStaticArgOf(p.arg, "is") && checkCompatEnabled(
      "COMPILER_IS_ON_ELEMENT",
      currentOptions,
      p.loc
    )) {
      return true;
    }
  }
  return false;
}
function isUpperCase(c) {
  return c > 64 && c < 91;
}
const windowsNewlineRE = /\r\n/g;
function condenseWhitespace(nodes, tag) {
  var _a, _b;
  const shouldCondense = currentOptions.whitespace !== "preserve";
  let removedWhitespace = false;
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (node.type === 2) {
      if (!inPre) {
        if (isAllWhitespace(node.content)) {
          const prev = (_a = nodes[i - 1]) == null ? void 0 : _a.type;
          const next = (_b = nodes[i + 1]) == null ? void 0 : _b.type;
          if (!prev || !next || shouldCondense && (prev === 3 && (next === 3 || next === 1) || prev === 1 && (next === 3 || next === 1 && hasNewlineChar(node.content)))) {
            removedWhitespace = true;
            nodes[i] = null;
          } else {
            node.content = " ";
          }
        } else if (shouldCondense) {
          node.content = condense(node.content);
        }
      } else {
        node.content = node.content.replace(windowsNewlineRE, "\n");
      }
    }
  }
  if (inPre && tag && currentOptions.isPreTag(tag)) {
    const first = nodes[0];
    if (first && first.type === 2) {
      first.content = first.content.replace(/^\r?\n/, "");
    }
  }
  return removedWhitespace ? nodes.filter(Boolean) : nodes;
}
function isAllWhitespace(str) {
  for (let i = 0; i < str.length; i++) {
    if (!isWhitespace(str.charCodeAt(i))) {
      return false;
    }
  }
  return true;
}
function hasNewlineChar(str) {
  for (let i = 0; i < str.length; i++) {
    const c = str.charCodeAt(i);
    if (c === 10 || c === 13) {
      return true;
    }
  }
  return false;
}
function condense(str) {
  let ret = "";
  let prevCharIsWhitespace = false;
  for (let i = 0; i < str.length; i++) {
    if (isWhitespace(str.charCodeAt(i))) {
      if (!prevCharIsWhitespace) {
        ret += " ";
        prevCharIsWhitespace = true;
      }
    } else {
      ret += str[i];
      prevCharIsWhitespace = false;
    }
  }
  return ret;
}
function addNode(node) {
  (stack[0] || currentRoot).children.push(node);
}
function getLoc(start, end) {
  return {
    start: tokenizer.getPos(start),
    // @ts-expect-error allow late attachment
    end: end == null ? end : tokenizer.getPos(end),
    // @ts-expect-error allow late attachment
    source: end == null ? end : getSlice(start, end)
  };
}
function setLocEnd(loc, end) {
  loc.end = tokenizer.getPos(end);
  loc.source = getSlice(loc.start.offset, end);
}
function dirToAttr(dir) {
  const attr = {
    type: 6,
    name: dir.rawName,
    nameLoc: getLoc(
      dir.loc.start.offset,
      dir.loc.start.offset + dir.rawName.length
    ),
    value: void 0,
    loc: dir.loc
  };
  if (dir.exp) {
    const loc = dir.exp.loc;
    if (loc.end.offset < dir.loc.end.offset) {
      loc.start.offset--;
      loc.start.column--;
      loc.end.offset++;
      loc.end.column++;
    }
    attr.value = {
      type: 2,
      content: dir.exp.content,
      loc
    };
  }
  return attr;
}
function createExp(content, isStatic = false, loc, constType = 0, parseMode = 0 /* Normal */) {
  const exp = createSimpleExpression(content, isStatic, loc, constType);
  return exp;
}
function emitError(code, index, message) {
  currentOptions.onError(
    createCompilerError(code, getLoc(index, index), void 0, message)
  );
}
function reset() {
  tokenizer.reset();
  currentOpenTag = null;
  currentProp = null;
  currentAttrValue = "";
  currentAttrStartIndex = -1;
  currentAttrEndIndex = -1;
  stack.length = 0;
}
function baseParse(input, options) {
  reset();
  currentInput = input;
  currentOptions = extend({}, defaultParserOptions);
  if (options) {
    let key;
    for (key in options) {
      if (options[key] != null) {
        currentOptions[key] = options[key];
      }
    }
  }
  if (false) {}
  tokenizer.mode = currentOptions.parseMode === "html" ? 1 : currentOptions.parseMode === "sfc" ? 2 : 0;
  tokenizer.inXML = currentOptions.ns === 1 || currentOptions.ns === 2;
  const delimiters = options == null ? void 0 : options.delimiters;
  if (delimiters) {
    tokenizer.delimiterOpen = toCharCodes(delimiters[0]);
    tokenizer.delimiterClose = toCharCodes(delimiters[1]);
  }
  const root = currentRoot = createRoot([], input);
  tokenizer.parse(currentInput);
  root.loc = getLoc(0, input.length);
  root.children = condenseWhitespace(root.children);
  currentRoot = null;
  return root;
}

function hoistStatic(root, context) {
  walk(
    root,
    context,
    // Root node is unfortunately non-hoistable due to potential parent
    // fallthrough attributes.
    isSingleElementRoot(root, root.children[0])
  );
}
function isSingleElementRoot(root, child) {
  const { children } = root;
  return children.length === 1 && child.type === 1 && !isSlotOutlet(child);
}
function walk(node, context, doNotHoistNode = false) {
  const { children } = node;
  const originalCount = children.length;
  let hoistedCount = 0;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (child.type === 1 && child.tagType === 0) {
      const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
      if (constantType > 0) {
        if (constantType >= 2) {
          child.codegenNode.patchFlag = -1 + ( false ? 0 : ``);
          child.codegenNode = context.hoist(child.codegenNode);
          hoistedCount++;
          continue;
        }
      } else {
        const codegenNode = child.codegenNode;
        if (codegenNode.type === 13) {
          const flag = getPatchFlag(codegenNode);
          if ((!flag || flag === 512 || flag === 1) && getGeneratedPropsConstantType(child, context) >= 2) {
            const props = getNodeProps(child);
            if (props) {
              codegenNode.props = context.hoist(props);
            }
          }
          if (codegenNode.dynamicProps) {
            codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);
          }
        }
      }
    }
    if (child.type === 1) {
      const isComponent = child.tagType === 1;
      if (isComponent) {
        context.scopes.vSlot++;
      }
      walk(child, context);
      if (isComponent) {
        context.scopes.vSlot--;
      }
    } else if (child.type === 11) {
      walk(child, context, child.children.length === 1);
    } else if (child.type === 9) {
      for (let i2 = 0; i2 < child.branches.length; i2++) {
        walk(
          child.branches[i2],
          context,
          child.branches[i2].children.length === 1
        );
      }
    }
  }
  if (hoistedCount && context.transformHoist) {
    context.transformHoist(children, context, node);
  }
  if (hoistedCount && hoistedCount === originalCount && node.type === 1 && node.tagType === 0 && node.codegenNode && node.codegenNode.type === 13 && isArray(node.codegenNode.children)) {
    const hoisted = context.hoist(
      createArrayExpression(node.codegenNode.children)
    );
    if (context.hmr) {
      hoisted.content = `[...${hoisted.content}]`;
    }
    node.codegenNode.children = hoisted;
  }
}
function getConstantType(node, context) {
  const { constantCache } = context;
  switch (node.type) {
    case 1:
      if (node.tagType !== 0) {
        return 0;
      }
      const cached = constantCache.get(node);
      if (cached !== void 0) {
        return cached;
      }
      const codegenNode = node.codegenNode;
      if (codegenNode.type !== 13) {
        return 0;
      }
      if (codegenNode.isBlock && node.tag !== "svg" && node.tag !== "foreignObject") {
        return 0;
      }
      const flag = getPatchFlag(codegenNode);
      if (!flag) {
        let returnType2 = 3;
        const generatedPropsType = getGeneratedPropsConstantType(node, context);
        if (generatedPropsType === 0) {
          constantCache.set(node, 0);
          return 0;
        }
        if (generatedPropsType < returnType2) {
          returnType2 = generatedPropsType;
        }
        for (let i = 0; i < node.children.length; i++) {
          const childType = getConstantType(node.children[i], context);
          if (childType === 0) {
            constantCache.set(node, 0);
            return 0;
          }
          if (childType < returnType2) {
            returnType2 = childType;
          }
        }
        if (returnType2 > 1) {
          for (let i = 0; i < node.props.length; i++) {
            const p = node.props[i];
            if (p.type === 7 && p.name === "bind" && p.exp) {
              const expType = getConstantType(p.exp, context);
              if (expType === 0) {
                constantCache.set(node, 0);
                return 0;
              }
              if (expType < returnType2) {
                returnType2 = expType;
              }
            }
          }
        }
        if (codegenNode.isBlock) {
          for (let i = 0; i < node.props.length; i++) {
            const p = node.props[i];
            if (p.type === 7) {
              constantCache.set(node, 0);
              return 0;
            }
          }
          context.removeHelper(OPEN_BLOCK);
          context.removeHelper(
            getVNodeBlockHelper(context.inSSR, codegenNode.isComponent)
          );
          codegenNode.isBlock = false;
          context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));
        }
        constantCache.set(node, returnType2);
        return returnType2;
      } else {
        constantCache.set(node, 0);
        return 0;
      }
    case 2:
    case 3:
      return 3;
    case 9:
    case 11:
    case 10:
      return 0;
    case 5:
    case 12:
      return getConstantType(node.content, context);
    case 4:
      return node.constType;
    case 8:
      let returnType = 3;
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if (isString(child) || isSymbol(child)) {
          continue;
        }
        const childType = getConstantType(child, context);
        if (childType === 0) {
          return 0;
        } else if (childType < returnType) {
          returnType = childType;
        }
      }
      return returnType;
    default:
      if (false) {}
      return 0;
  }
}
const allowHoistedHelperSet = /* @__PURE__ */ new Set([
  NORMALIZE_CLASS,
  NORMALIZE_STYLE,
  NORMALIZE_PROPS,
  GUARD_REACTIVE_PROPS
]);
function getConstantTypeOfHelperCall(value, context) {
  if (value.type === 14 && !isString(value.callee) && allowHoistedHelperSet.has(value.callee)) {
    const arg = value.arguments[0];
    if (arg.type === 4) {
      return getConstantType(arg, context);
    } else if (arg.type === 14) {
      return getConstantTypeOfHelperCall(arg, context);
    }
  }
  return 0;
}
function getGeneratedPropsConstantType(node, context) {
  let returnType = 3;
  const props = getNodeProps(node);
  if (props && props.type === 15) {
    const { properties } = props;
    for (let i = 0; i < properties.length; i++) {
      const { key, value } = properties[i];
      const keyType = getConstantType(key, context);
      if (keyType === 0) {
        return keyType;
      }
      if (keyType < returnType) {
        returnType = keyType;
      }
      let valueType;
      if (value.type === 4) {
        valueType = getConstantType(value, context);
      } else if (value.type === 14) {
        valueType = getConstantTypeOfHelperCall(value, context);
      } else {
        valueType = 0;
      }
      if (valueType === 0) {
        return valueType;
      }
      if (valueType < returnType) {
        returnType = valueType;
      }
    }
  }
  return returnType;
}
function getNodeProps(node) {
  const codegenNode = node.codegenNode;
  if (codegenNode.type === 13) {
    return codegenNode.props;
  }
}
function getPatchFlag(node) {
  const flag = node.patchFlag;
  return flag ? parseInt(flag, 10) : void 0;
}

function createTransformContext(root, {
  filename = "",
  prefixIdentifiers = false,
  hoistStatic: hoistStatic2 = false,
  hmr = false,
  cacheHandlers = false,
  nodeTransforms = [],
  directiveTransforms = {},
  transformHoist = null,
  isBuiltInComponent = NOOP,
  isCustomElement = NOOP,
  expressionPlugins = [],
  scopeId = null,
  slotted = true,
  ssr = false,
  inSSR = false,
  ssrCssVars = ``,
  bindingMetadata = EMPTY_OBJ,
  inline = false,
  isTS = false,
  onError = defaultOnError,
  onWarn = defaultOnWarn,
  compatConfig
}) {
  const nameMatch = filename.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/);
  const context = {
    // options
    filename,
    selfName: nameMatch && capitalize(camelize(nameMatch[1])),
    prefixIdentifiers,
    hoistStatic: hoistStatic2,
    hmr,
    cacheHandlers,
    nodeTransforms,
    directiveTransforms,
    transformHoist,
    isBuiltInComponent,
    isCustomElement,
    expressionPlugins,
    scopeId,
    slotted,
    ssr,
    inSSR,
    ssrCssVars,
    bindingMetadata,
    inline,
    isTS,
    onError,
    onWarn,
    compatConfig,
    // state
    root,
    helpers: /* @__PURE__ */ new Map(),
    components: /* @__PURE__ */ new Set(),
    directives: /* @__PURE__ */ new Set(),
    hoists: [],
    imports: [],
    constantCache: /* @__PURE__ */ new WeakMap(),
    temps: 0,
    cached: 0,
    identifiers: /* @__PURE__ */ Object.create(null),
    scopes: {
      vFor: 0,
      vSlot: 0,
      vPre: 0,
      vOnce: 0
    },
    parent: null,
    currentNode: root,
    childIndex: 0,
    inVOnce: false,
    // methods
    helper(name) {
      const count = context.helpers.get(name) || 0;
      context.helpers.set(name, count + 1);
      return name;
    },
    removeHelper(name) {
      const count = context.helpers.get(name);
      if (count) {
        const currentCount = count - 1;
        if (!currentCount) {
          context.helpers.delete(name);
        } else {
          context.helpers.set(name, currentCount);
        }
      }
    },
    helperString(name) {
      return `_${helperNameMap[context.helper(name)]}`;
    },
    replaceNode(node) {
      if (false) {}
      context.parent.children[context.childIndex] = context.currentNode = node;
    },
    removeNode(node) {
      if (false) {}
      const list = context.parent.children;
      const removalIndex = node ? list.indexOf(node) : context.currentNode ? context.childIndex : -1;
      if (false) {}
      if (!node || node === context.currentNode) {
        context.currentNode = null;
        context.onNodeRemoved();
      } else {
        if (context.childIndex > removalIndex) {
          context.childIndex--;
          context.onNodeRemoved();
        }
      }
      context.parent.children.splice(removalIndex, 1);
    },
    onNodeRemoved: NOOP,
    addIdentifiers(exp) {
    },
    removeIdentifiers(exp) {
    },
    hoist(exp) {
      if (isString(exp))
        exp = createSimpleExpression(exp);
      context.hoists.push(exp);
      const identifier = createSimpleExpression(
        `_hoisted_${context.hoists.length}`,
        false,
        exp.loc,
        2
      );
      identifier.hoisted = exp;
      return identifier;
    },
    cache(exp, isVNode = false) {
      return createCacheExpression(context.cached++, exp, isVNode);
    }
  };
  {
    context.filters = /* @__PURE__ */ new Set();
  }
  return context;
}
function transform(root, options) {
  const context = createTransformContext(root, options);
  traverseNode(root, context);
  if (options.hoistStatic) {
    hoistStatic(root, context);
  }
  if (!options.ssr) {
    createRootCodegen(root, context);
  }
  root.helpers = /* @__PURE__ */ new Set([...context.helpers.keys()]);
  root.components = [...context.components];
  root.directives = [...context.directives];
  root.imports = context.imports;
  root.hoists = context.hoists;
  root.temps = context.temps;
  root.cached = context.cached;
  root.transformed = true;
  {
    root.filters = [...context.filters];
  }
}
function createRootCodegen(root, context) {
  const { helper } = context;
  const { children } = root;
  if (children.length === 1) {
    const child = children[0];
    if (isSingleElementRoot(root, child) && child.codegenNode) {
      const codegenNode = child.codegenNode;
      if (codegenNode.type === 13) {
        convertToBlock(codegenNode, context);
      }
      root.codegenNode = codegenNode;
    } else {
      root.codegenNode = child;
    }
  } else if (children.length > 1) {
    let patchFlag = 64;
    let patchFlagText = PatchFlagNames[64];
    if (false) {}
    root.codegenNode = createVNodeCall(
      context,
      helper(FRAGMENT),
      void 0,
      root.children,
      patchFlag + ( false ? 0 : ``),
      void 0,
      void 0,
      true,
      void 0,
      false
    );
  } else ;
}
function traverseChildren(parent, context) {
  let i = 0;
  const nodeRemoved = () => {
    i--;
  };
  for (; i < parent.children.length; i++) {
    const child = parent.children[i];
    if (isString(child))
      continue;
    context.parent = parent;
    context.childIndex = i;
    context.onNodeRemoved = nodeRemoved;
    traverseNode(child, context);
  }
}
function traverseNode(node, context) {
  context.currentNode = node;
  const { nodeTransforms } = context;
  const exitFns = [];
  for (let i2 = 0; i2 < nodeTransforms.length; i2++) {
    const onExit = nodeTransforms[i2](node, context);
    if (onExit) {
      if (isArray(onExit)) {
        exitFns.push(...onExit);
      } else {
        exitFns.push(onExit);
      }
    }
    if (!context.currentNode) {
      return;
    } else {
      node = context.currentNode;
    }
  }
  switch (node.type) {
    case 3:
      if (!context.ssr) {
        context.helper(CREATE_COMMENT);
      }
      break;
    case 5:
      if (!context.ssr) {
        context.helper(TO_DISPLAY_STRING);
      }
      break;
    case 9:
      for (let i2 = 0; i2 < node.branches.length; i2++) {
        traverseNode(node.branches[i2], context);
      }
      break;
    case 10:
    case 11:
    case 1:
    case 0:
      traverseChildren(node, context);
      break;
  }
  context.currentNode = node;
  let i = exitFns.length;
  while (i--) {
    exitFns[i]();
  }
}
function createStructuralDirectiveTransform(name, fn) {
  const matches = isString(name) ? (n) => n === name : (n) => name.test(n);
  return (node, context) => {
    if (node.type === 1) {
      const { props } = node;
      if (node.tagType === 3 && props.some(isVSlot)) {
        return;
      }
      const exitFns = [];
      for (let i = 0; i < props.length; i++) {
        const prop = props[i];
        if (prop.type === 7 && matches(prop.name)) {
          props.splice(i, 1);
          i--;
          const onExit = fn(node, prop, context);
          if (onExit)
            exitFns.push(onExit);
        }
      }
      return exitFns;
    }
  };
}

const PURE_ANNOTATION = `/*#__PURE__*/`;
const aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;
function createCodegenContext(ast, {
  mode = "function",
  prefixIdentifiers = mode === "module",
  sourceMap = false,
  filename = `template.vue.html`,
  scopeId = null,
  optimizeImports = false,
  runtimeGlobalName = `Vue`,
  runtimeModuleName = `vue`,
  ssrRuntimeModuleName = "vue/server-renderer",
  ssr = false,
  isTS = false,
  inSSR = false
}) {
  const context = {
    mode,
    prefixIdentifiers,
    sourceMap,
    filename,
    scopeId,
    optimizeImports,
    runtimeGlobalName,
    runtimeModuleName,
    ssrRuntimeModuleName,
    ssr,
    isTS,
    inSSR,
    source: ast.source,
    code: ``,
    column: 1,
    line: 1,
    offset: 0,
    indentLevel: 0,
    pure: false,
    map: void 0,
    helper(key) {
      return `_${helperNameMap[key]}`;
    },
    push(code, newlineIndex = -2 /* None */, node) {
      context.code += code;
    },
    indent() {
      newline(++context.indentLevel);
    },
    deindent(withoutNewLine = false) {
      if (withoutNewLine) {
        --context.indentLevel;
      } else {
        newline(--context.indentLevel);
      }
    },
    newline() {
      newline(context.indentLevel);
    }
  };
  function newline(n) {
    context.push("\n" + `  `.repeat(n), 0 /* Start */);
  }
  return context;
}
function generate(ast, options = {}) {
  const context = createCodegenContext(ast, options);
  if (options.onContextCreated)
    options.onContextCreated(context);
  const {
    mode,
    push,
    prefixIdentifiers,
    indent,
    deindent,
    newline,
    scopeId,
    ssr
  } = context;
  const helpers = Array.from(ast.helpers);
  const hasHelpers = helpers.length > 0;
  const useWithBlock = !prefixIdentifiers && mode !== "module";
  const preambleContext = context;
  {
    genFunctionPreamble(ast, preambleContext);
  }
  const functionName = ssr ? `ssrRender` : `render`;
  const args = ssr ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
  const signature = args.join(", ");
  {
    push(`function ${functionName}(${signature}) {`);
  }
  indent();
  if (useWithBlock) {
    push(`with (_ctx) {`);
    indent();
    if (hasHelpers) {
      push(
        `const { ${helpers.map(aliasHelper).join(", ")} } = _Vue
`,
        -1 /* End */
      );
      newline();
    }
  }
  if (ast.components.length) {
    genAssets(ast.components, "component", context);
    if (ast.directives.length || ast.temps > 0) {
      newline();
    }
  }
  if (ast.directives.length) {
    genAssets(ast.directives, "directive", context);
    if (ast.temps > 0) {
      newline();
    }
  }
  if (ast.filters && ast.filters.length) {
    newline();
    genAssets(ast.filters, "filter", context);
    newline();
  }
  if (ast.temps > 0) {
    push(`let `);
    for (let i = 0; i < ast.temps; i++) {
      push(`${i > 0 ? `, ` : ``}_temp${i}`);
    }
  }
  if (ast.components.length || ast.directives.length || ast.temps) {
    push(`
`, 0 /* Start */);
    newline();
  }
  if (!ssr) {
    push(`return `);
  }
  if (ast.codegenNode) {
    genNode(ast.codegenNode, context);
  } else {
    push(`null`);
  }
  if (useWithBlock) {
    deindent();
    push(`}`);
  }
  deindent();
  push(`}`);
  return {
    ast,
    code: context.code,
    preamble: ``,
    map: context.map ? context.map.toJSON() : void 0
  };
}
function genFunctionPreamble(ast, context) {
  const {
    ssr,
    prefixIdentifiers,
    push,
    newline,
    runtimeModuleName,
    runtimeGlobalName,
    ssrRuntimeModuleName
  } = context;
  const VueBinding = runtimeGlobalName;
  const helpers = Array.from(ast.helpers);
  if (helpers.length > 0) {
    {
      push(`const _Vue = ${VueBinding}
`, -1 /* End */);
      if (ast.hoists.length) {
        const staticHelpers = [
          CREATE_VNODE,
          CREATE_ELEMENT_VNODE,
          CREATE_COMMENT,
          CREATE_TEXT,
          CREATE_STATIC
        ].filter((helper) => helpers.includes(helper)).map(aliasHelper).join(", ");
        push(`const { ${staticHelpers} } = _Vue
`, -1 /* End */);
      }
    }
  }
  genHoists(ast.hoists, context);
  newline();
  push(`return `);
}
function genAssets(assets, type, { helper, push, newline, isTS }) {
  const resolver = helper(
    type === "filter" ? RESOLVE_FILTER : type === "component" ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE
  );
  for (let i = 0; i < assets.length; i++) {
    let id = assets[i];
    const maybeSelfReference = id.endsWith("__self");
    if (maybeSelfReference) {
      id = id.slice(0, -6);
    }
    push(
      `const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`
    );
    if (i < assets.length - 1) {
      newline();
    }
  }
}
function genHoists(hoists, context) {
  if (!hoists.length) {
    return;
  }
  context.pure = true;
  const { push, newline, helper, scopeId, mode } = context;
  newline();
  for (let i = 0; i < hoists.length; i++) {
    const exp = hoists[i];
    if (exp) {
      push(
        `const _hoisted_${i + 1} = ${``}`
      );
      genNode(exp, context);
      newline();
    }
  }
  context.pure = false;
}
function isText(n) {
  return isString(n) || n.type === 4 || n.type === 2 || n.type === 5 || n.type === 8;
}
function genNodeListAsArray(nodes, context) {
  const multilines = nodes.length > 3 ||  false && 0;
  context.push(`[`);
  multilines && context.indent();
  genNodeList(nodes, context, multilines);
  multilines && context.deindent();
  context.push(`]`);
}
function genNodeList(nodes, context, multilines = false, comma = true) {
  const { push, newline } = context;
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (isString(node)) {
      push(node, -3 /* Unknown */);
    } else if (isArray(node)) {
      genNodeListAsArray(node, context);
    } else {
      genNode(node, context);
    }
    if (i < nodes.length - 1) {
      if (multilines) {
        comma && push(",");
        newline();
      } else {
        comma && push(", ");
      }
    }
  }
}
function genNode(node, context) {
  if (isString(node)) {
    context.push(node, -3 /* Unknown */);
    return;
  }
  if (isSymbol(node)) {
    context.push(context.helper(node));
    return;
  }
  switch (node.type) {
    case 1:
    case 9:
    case 11:
       false && 0;
      genNode(node.codegenNode, context);
      break;
    case 2:
      genText(node, context);
      break;
    case 4:
      genExpression(node, context);
      break;
    case 5:
      genInterpolation(node, context);
      break;
    case 12:
      genNode(node.codegenNode, context);
      break;
    case 8:
      genCompoundExpression(node, context);
      break;
    case 3:
      genComment(node, context);
      break;
    case 13:
      genVNodeCall(node, context);
      break;
    case 14:
      genCallExpression(node, context);
      break;
    case 15:
      genObjectExpression(node, context);
      break;
    case 17:
      genArrayExpression(node, context);
      break;
    case 18:
      genFunctionExpression(node, context);
      break;
    case 19:
      genConditionalExpression(node, context);
      break;
    case 20:
      genCacheExpression(node, context);
      break;
    case 21:
      genNodeList(node.body, context, true, false);
      break;
    case 22:
      break;
    case 23:
      break;
    case 24:
      break;
    case 25:
      break;
    case 26:
      break;
    case 10:
      break;
    default:
      if (false) {}
  }
}
function genText(node, context) {
  context.push(JSON.stringify(node.content), -3 /* Unknown */, node);
}
function genExpression(node, context) {
  const { content, isStatic } = node;
  context.push(
    isStatic ? JSON.stringify(content) : content,
    -3 /* Unknown */,
    node
  );
}
function genInterpolation(node, context) {
  const { push, helper, pure } = context;
  if (pure)
    push(PURE_ANNOTATION);
  push(`${helper(TO_DISPLAY_STRING)}(`);
  genNode(node.content, context);
  push(`)`);
}
function genCompoundExpression(node, context) {
  for (let i = 0; i < node.children.length; i++) {
    const child = node.children[i];
    if (isString(child)) {
      context.push(child, -3 /* Unknown */);
    } else {
      genNode(child, context);
    }
  }
}
function genExpressionAsPropertyKey(node, context) {
  const { push } = context;
  if (node.type === 8) {
    push(`[`);
    genCompoundExpression(node, context);
    push(`]`);
  } else if (node.isStatic) {
    const text = isSimpleIdentifier(node.content) ? node.content : JSON.stringify(node.content);
    push(text, -2 /* None */, node);
  } else {
    push(`[${node.content}]`, -3 /* Unknown */, node);
  }
}
function genComment(node, context) {
  const { push, helper, pure } = context;
  if (pure) {
    push(PURE_ANNOTATION);
  }
  push(
    `${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`,
    -3 /* Unknown */,
    node
  );
}
function genVNodeCall(node, context) {
  const { push, helper, pure } = context;
  const {
    tag,
    props,
    children,
    patchFlag,
    dynamicProps,
    directives,
    isBlock,
    disableTracking,
    isComponent
  } = node;
  if (directives) {
    push(helper(WITH_DIRECTIVES) + `(`);
  }
  if (isBlock) {
    push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
  }
  if (pure) {
    push(PURE_ANNOTATION);
  }
  const callHelper = isBlock ? getVNodeBlockHelper(context.inSSR, isComponent) : getVNodeHelper(context.inSSR, isComponent);
  push(helper(callHelper) + `(`, -2 /* None */, node);
  genNodeList(
    genNullableArgs([tag, props, children, patchFlag, dynamicProps]),
    context
  );
  push(`)`);
  if (isBlock) {
    push(`)`);
  }
  if (directives) {
    push(`, `);
    genNode(directives, context);
    push(`)`);
  }
}
function genNullableArgs(args) {
  let i = args.length;
  while (i--) {
    if (args[i] != null)
      break;
  }
  return args.slice(0, i + 1).map((arg) => arg || `null`);
}
function genCallExpression(node, context) {
  const { push, helper, pure } = context;
  const callee = isString(node.callee) ? node.callee : helper(node.callee);
  if (pure) {
    push(PURE_ANNOTATION);
  }
  push(callee + `(`, -2 /* None */, node);
  genNodeList(node.arguments, context);
  push(`)`);
}
function genObjectExpression(node, context) {
  const { push, indent, deindent, newline } = context;
  const { properties } = node;
  if (!properties.length) {
    push(`{}`, -2 /* None */, node);
    return;
  }
  const multilines = properties.length > 1 ||  false && 0;
  push(multilines ? `{` : `{ `);
  multilines && indent();
  for (let i = 0; i < properties.length; i++) {
    const { key, value } = properties[i];
    genExpressionAsPropertyKey(key, context);
    push(`: `);
    genNode(value, context);
    if (i < properties.length - 1) {
      push(`,`);
      newline();
    }
  }
  multilines && deindent();
  push(multilines ? `}` : ` }`);
}
function genArrayExpression(node, context) {
  genNodeListAsArray(node.elements, context);
}
function genFunctionExpression(node, context) {
  const { push, indent, deindent } = context;
  const { params, returns, body, newline, isSlot } = node;
  if (isSlot) {
    push(`_${helperNameMap[WITH_CTX]}(`);
  }
  push(`(`, -2 /* None */, node);
  if (isArray(params)) {
    genNodeList(params, context);
  } else if (params) {
    genNode(params, context);
  }
  push(`) => `);
  if (newline || body) {
    push(`{`);
    indent();
  }
  if (returns) {
    if (newline) {
      push(`return `);
    }
    if (isArray(returns)) {
      genNodeListAsArray(returns, context);
    } else {
      genNode(returns, context);
    }
  } else if (body) {
    genNode(body, context);
  }
  if (newline || body) {
    deindent();
    push(`}`);
  }
  if (isSlot) {
    if (node.isNonScopedSlot) {
      push(`, undefined, true`);
    }
    push(`)`);
  }
}
function genConditionalExpression(node, context) {
  const { test, consequent, alternate, newline: needNewline } = node;
  const { push, indent, deindent, newline } = context;
  if (test.type === 4) {
    const needsParens = !isSimpleIdentifier(test.content);
    needsParens && push(`(`);
    genExpression(test, context);
    needsParens && push(`)`);
  } else {
    push(`(`);
    genNode(test, context);
    push(`)`);
  }
  needNewline && indent();
  context.indentLevel++;
  needNewline || push(` `);
  push(`? `);
  genNode(consequent, context);
  context.indentLevel--;
  needNewline && newline();
  needNewline || push(` `);
  push(`: `);
  const isNested = alternate.type === 19;
  if (!isNested) {
    context.indentLevel++;
  }
  genNode(alternate, context);
  if (!isNested) {
    context.indentLevel--;
  }
  needNewline && deindent(
    true
    /* without newline */
  );
}
function genCacheExpression(node, context) {
  const { push, helper, indent, deindent, newline } = context;
  push(`_cache[${node.index}] || (`);
  if (node.isVNode) {
    indent();
    push(`${helper(SET_BLOCK_TRACKING)}(-1),`);
    newline();
  }
  push(`_cache[${node.index}] = `);
  genNode(node.value, context);
  if (node.isVNode) {
    push(`,`);
    newline();
    push(`${helper(SET_BLOCK_TRACKING)}(1),`);
    newline();
    push(`_cache[${node.index}]`);
    deindent();
  }
  push(`)`);
}

const prohibitedKeywordRE = new RegExp(
  "\\b" + "arguments,await,break,case,catch,class,const,continue,debugger,default,delete,do,else,export,extends,finally,for,function,if,import,let,new,return,super,switch,throw,try,var,void,while,with,yield".split(",").join("\\b|\\b") + "\\b"
);
const stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
function validateBrowserExpression(node, context, asParams = false, asRawStatements = false) {
  const exp = node.content;
  if (!exp.trim()) {
    return;
  }
  try {
    new Function(
      asRawStatements ? ` ${exp} ` : `return ${asParams ? `(${exp}) => {}` : `(${exp})`}`
    );
  } catch (e) {
    let message = e.message;
    const keywordMatch = exp.replace(stripStringRE, "").match(prohibitedKeywordRE);
    if (keywordMatch) {
      message = `avoid using JavaScript keyword as property name: "${keywordMatch[0]}"`;
    }
    context.onError(
      createCompilerError(
        45,
        node.loc,
        void 0,
        message
      )
    );
  }
}

const transformExpression = (node, context) => {
  if (node.type === 5) {
    node.content = processExpression(
      node.content,
      context
    );
  } else if (node.type === 1) {
    for (let i = 0; i < node.props.length; i++) {
      const dir = node.props[i];
      if (dir.type === 7 && dir.name !== "for") {
        const exp = dir.exp;
        const arg = dir.arg;
        if (exp && exp.type === 4 && !(dir.name === "on" && arg)) {
          dir.exp = processExpression(
            exp,
            context,
            // slot args must be processed as function params
            dir.name === "slot"
          );
        }
        if (arg && arg.type === 4 && !arg.isStatic) {
          dir.arg = processExpression(arg, context);
        }
      }
    }
  }
};
function processExpression(node, context, asParams = false, asRawStatements = false, localVars = Object.create(context.identifiers)) {
  {
    if (false) {}
    return node;
  }
}

const transformIf = createStructuralDirectiveTransform(
  /^(if|else|else-if)$/,
  (node, dir, context) => {
    return processIf(node, dir, context, (ifNode, branch, isRoot) => {
      const siblings = context.parent.children;
      let i = siblings.indexOf(ifNode);
      let key = 0;
      while (i-- >= 0) {
        const sibling = siblings[i];
        if (sibling && sibling.type === 9) {
          key += sibling.branches.length;
        }
      }
      return () => {
        if (isRoot) {
          ifNode.codegenNode = createCodegenNodeForBranch(
            branch,
            key,
            context
          );
        } else {
          const parentCondition = getParentCondition(ifNode.codegenNode);
          parentCondition.alternate = createCodegenNodeForBranch(
            branch,
            key + ifNode.branches.length - 1,
            context
          );
        }
      };
    });
  }
);
function processIf(node, dir, context, processCodegen) {
  if (dir.name !== "else" && (!dir.exp || !dir.exp.content.trim())) {
    const loc = dir.exp ? dir.exp.loc : node.loc;
    context.onError(
      createCompilerError(28, dir.loc)
    );
    dir.exp = createSimpleExpression(`true`, false, loc);
  }
  if (false) {}
  if (dir.name === "if") {
    const branch = createIfBranch(node, dir);
    const ifNode = {
      type: 9,
      loc: node.loc,
      branches: [branch]
    };
    context.replaceNode(ifNode);
    if (processCodegen) {
      return processCodegen(ifNode, branch, true);
    }
  } else {
    const siblings = context.parent.children;
    const comments = [];
    let i = siblings.indexOf(node);
    while (i-- >= -1) {
      const sibling = siblings[i];
      if (sibling && sibling.type === 3) {
        context.removeNode(sibling);
         false && 0;
        continue;
      }
      if (sibling && sibling.type === 2 && !sibling.content.trim().length) {
        context.removeNode(sibling);
        continue;
      }
      if (sibling && sibling.type === 9) {
        if (dir.name === "else-if" && sibling.branches[sibling.branches.length - 1].condition === void 0) {
          context.onError(
            createCompilerError(30, node.loc)
          );
        }
        context.removeNode();
        const branch = createIfBranch(node, dir);
        if (false) {}
        if (false) {}
        sibling.branches.push(branch);
        const onExit = processCodegen && processCodegen(sibling, branch, false);
        traverseNode(branch, context);
        if (onExit)
          onExit();
        context.currentNode = null;
      } else {
        context.onError(
          createCompilerError(30, node.loc)
        );
      }
      break;
    }
  }
}
function createIfBranch(node, dir) {
  const isTemplateIf = node.tagType === 3;
  return {
    type: 10,
    loc: node.loc,
    condition: dir.name === "else" ? void 0 : dir.exp,
    children: isTemplateIf && !findDir(node, "for") ? node.children : [node],
    userKey: findProp(node, `key`),
    isTemplateIf
  };
}
function createCodegenNodeForBranch(branch, keyIndex, context) {
  if (branch.condition) {
    return createConditionalExpression(
      branch.condition,
      createChildrenCodegenNode(branch, keyIndex, context),
      // make sure to pass in asBlock: true so that the comment node call
      // closes the current block.
      createCallExpression(context.helper(CREATE_COMMENT), [
         false ? 0 : '""',
        "true"
      ])
    );
  } else {
    return createChildrenCodegenNode(branch, keyIndex, context);
  }
}
function createChildrenCodegenNode(branch, keyIndex, context) {
  const { helper } = context;
  const keyProperty = createObjectProperty(
    `key`,
    createSimpleExpression(
      `${keyIndex}`,
      false,
      locStub,
      2
    )
  );
  const { children } = branch;
  const firstChild = children[0];
  const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1;
  if (needFragmentWrapper) {
    if (children.length === 1 && firstChild.type === 11) {
      const vnodeCall = firstChild.codegenNode;
      injectProp(vnodeCall, keyProperty, context);
      return vnodeCall;
    } else {
      let patchFlag = 64;
      let patchFlagText = PatchFlagNames[64];
      if (false) {}
      return createVNodeCall(
        context,
        helper(FRAGMENT),
        createObjectExpression([keyProperty]),
        children,
        patchFlag + ( false ? 0 : ``),
        void 0,
        void 0,
        true,
        false,
        false,
        branch.loc
      );
    }
  } else {
    const ret = firstChild.codegenNode;
    const vnodeCall = getMemoedVNodeCall(ret);
    if (vnodeCall.type === 13) {
      convertToBlock(vnodeCall, context);
    }
    injectProp(vnodeCall, keyProperty, context);
    return ret;
  }
}
function isSameKey(a, b) {
  if (!a || a.type !== b.type) {
    return false;
  }
  if (a.type === 6) {
    if (a.value.content !== b.value.content) {
      return false;
    }
  } else {
    const exp = a.exp;
    const branchExp = b.exp;
    if (exp.type !== branchExp.type) {
      return false;
    }
    if (exp.type !== 4 || exp.isStatic !== branchExp.isStatic || exp.content !== branchExp.content) {
      return false;
    }
  }
  return true;
}
function getParentCondition(node) {
  while (true) {
    if (node.type === 19) {
      if (node.alternate.type === 19) {
        node = node.alternate;
      } else {
        return node;
      }
    } else if (node.type === 20) {
      node = node.value;
    }
  }
}

const transformFor = createStructuralDirectiveTransform(
  "for",
  (node, dir, context) => {
    const { helper, removeHelper } = context;
    return processFor(node, dir, context, (forNode) => {
      const renderExp = createCallExpression(helper(RENDER_LIST), [
        forNode.source
      ]);
      const isTemplate = isTemplateNode(node);
      const memo = findDir(node, "memo");
      const keyProp = findProp(node, `key`);
      const keyExp = keyProp && (keyProp.type === 6 ? createSimpleExpression(keyProp.value.content, true) : keyProp.exp);
      const keyProperty = keyProp ? createObjectProperty(`key`, keyExp) : null;
      const isStableFragment = forNode.source.type === 4 && forNode.source.constType > 0;
      const fragmentFlag = isStableFragment ? 64 : keyProp ? 128 : 256;
      forNode.codegenNode = createVNodeCall(
        context,
        helper(FRAGMENT),
        void 0,
        renderExp,
        fragmentFlag + ( false ? 0 : ``),
        void 0,
        void 0,
        true,
        !isStableFragment,
        false,
        node.loc
      );
      return () => {
        let childBlock;
        const { children } = forNode;
        if (false) {}
        const needFragmentWrapper = children.length !== 1 || children[0].type !== 1;
        const slotOutlet = isSlotOutlet(node) ? node : isTemplate && node.children.length === 1 && isSlotOutlet(node.children[0]) ? node.children[0] : null;
        if (slotOutlet) {
          childBlock = slotOutlet.codegenNode;
          if (isTemplate && keyProperty) {
            injectProp(childBlock, keyProperty, context);
          }
        } else if (needFragmentWrapper) {
          childBlock = createVNodeCall(
            context,
            helper(FRAGMENT),
            keyProperty ? createObjectExpression([keyProperty]) : void 0,
            node.children,
            64 + ( false ? 0 : ``),
            void 0,
            void 0,
            true,
            void 0,
            false
          );
        } else {
          childBlock = children[0].codegenNode;
          if (isTemplate && keyProperty) {
            injectProp(childBlock, keyProperty, context);
          }
          if (childBlock.isBlock !== !isStableFragment) {
            if (childBlock.isBlock) {
              removeHelper(OPEN_BLOCK);
              removeHelper(
                getVNodeBlockHelper(context.inSSR, childBlock.isComponent)
              );
            } else {
              removeHelper(
                getVNodeHelper(context.inSSR, childBlock.isComponent)
              );
            }
          }
          childBlock.isBlock = !isStableFragment;
          if (childBlock.isBlock) {
            helper(OPEN_BLOCK);
            helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
          } else {
            helper(getVNodeHelper(context.inSSR, childBlock.isComponent));
          }
        }
        if (memo) {
          const loop = createFunctionExpression(
            createForLoopParams(forNode.parseResult, [
              createSimpleExpression(`_cached`)
            ])
          );
          loop.body = createBlockStatement([
            createCompoundExpression([`const _memo = (`, memo.exp, `)`]),
            createCompoundExpression([
              `if (_cached`,
              ...keyExp ? [` && _cached.key === `, keyExp] : [],
              ` && ${context.helperString(
                IS_MEMO_SAME
              )}(_cached, _memo)) return _cached`
            ]),
            createCompoundExpression([`const _item = `, childBlock]),
            createSimpleExpression(`_item.memo = _memo`),
            createSimpleExpression(`return _item`)
          ]);
          renderExp.arguments.push(
            loop,
            createSimpleExpression(`_cache`),
            createSimpleExpression(String(context.cached++))
          );
        } else {
          renderExp.arguments.push(
            createFunctionExpression(
              createForLoopParams(forNode.parseResult),
              childBlock,
              true
            )
          );
        }
      };
    });
  }
);
function processFor(node, dir, context, processCodegen) {
  if (!dir.exp) {
    context.onError(
      createCompilerError(31, dir.loc)
    );
    return;
  }
  const parseResult = dir.forParseResult;
  if (!parseResult) {
    context.onError(
      createCompilerError(32, dir.loc)
    );
    return;
  }
  finalizeForParseResult(parseResult, context);
  const { addIdentifiers, removeIdentifiers, scopes } = context;
  const { source, value, key, index } = parseResult;
  const forNode = {
    type: 11,
    loc: dir.loc,
    source,
    valueAlias: value,
    keyAlias: key,
    objectIndexAlias: index,
    parseResult,
    children: isTemplateNode(node) ? node.children : [node]
  };
  context.replaceNode(forNode);
  scopes.vFor++;
  const onExit = processCodegen && processCodegen(forNode);
  return () => {
    scopes.vFor--;
    if (onExit)
      onExit();
  };
}
function finalizeForParseResult(result, context) {
  if (result.finalized)
    return;
  if (false) {}
  result.finalized = true;
}
function createForLoopParams({ value, key, index }, memoArgs = []) {
  return createParamsList([value, key, index, ...memoArgs]);
}
function createParamsList(args) {
  let i = args.length;
  while (i--) {
    if (args[i])
      break;
  }
  return args.slice(0, i + 1).map((arg, i2) => arg || createSimpleExpression(`_`.repeat(i2 + 1), false));
}

const defaultFallback = createSimpleExpression(`undefined`, false);
const trackSlotScopes = (node, context) => {
  if (node.type === 1 && (node.tagType === 1 || node.tagType === 3)) {
    const vSlot = findDir(node, "slot");
    if (vSlot) {
      vSlot.exp;
      context.scopes.vSlot++;
      return () => {
        context.scopes.vSlot--;
      };
    }
  }
};
const buildClientSlotFn = (props, _vForExp, children, loc) => createFunctionExpression(
  props,
  children,
  false,
  true,
  children.length ? children[0].loc : loc
);
function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {
  context.helper(WITH_CTX);
  const { children, loc } = node;
  const slotsProperties = [];
  const dynamicSlots = [];
  let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
  const onComponentSlot = findDir(node, "slot", true);
  if (onComponentSlot) {
    const { arg, exp } = onComponentSlot;
    if (arg && !isStaticExp(arg)) {
      hasDynamicSlots = true;
    }
    slotsProperties.push(
      createObjectProperty(
        arg || createSimpleExpression("default", true),
        buildSlotFn(exp, void 0, children, loc)
      )
    );
  }
  let hasTemplateSlots = false;
  let hasNamedDefaultSlot = false;
  const implicitDefaultChildren = [];
  const seenSlotNames = /* @__PURE__ */ new Set();
  let conditionalBranchIndex = 0;
  for (let i = 0; i < children.length; i++) {
    const slotElement = children[i];
    let slotDir;
    if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, "slot", true))) {
      if (slotElement.type !== 3) {
        implicitDefaultChildren.push(slotElement);
      }
      continue;
    }
    if (onComponentSlot) {
      context.onError(
        createCompilerError(37, slotDir.loc)
      );
      break;
    }
    hasTemplateSlots = true;
    const { children: slotChildren, loc: slotLoc } = slotElement;
    const {
      arg: slotName = createSimpleExpression(`default`, true),
      exp: slotProps,
      loc: dirLoc
    } = slotDir;
    let staticSlotName;
    if (isStaticExp(slotName)) {
      staticSlotName = slotName ? slotName.content : `default`;
    } else {
      hasDynamicSlots = true;
    }
    const vFor = findDir(slotElement, "for");
    const slotFunction = buildSlotFn(slotProps, vFor, slotChildren, slotLoc);
    let vIf;
    let vElse;
    if (vIf = findDir(slotElement, "if")) {
      hasDynamicSlots = true;
      dynamicSlots.push(
        createConditionalExpression(
          vIf.exp,
          buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++),
          defaultFallback
        )
      );
    } else if (vElse = findDir(
      slotElement,
      /^else(-if)?$/,
      true
      /* allowEmpty */
    )) {
      let j = i;
      let prev;
      while (j--) {
        prev = children[j];
        if (prev.type !== 3) {
          break;
        }
      }
      if (prev && isTemplateNode(prev) && findDir(prev, "if")) {
        children.splice(i, 1);
        i--;
        let conditional = dynamicSlots[dynamicSlots.length - 1];
        while (conditional.alternate.type === 19) {
          conditional = conditional.alternate;
        }
        conditional.alternate = vElse.exp ? createConditionalExpression(
          vElse.exp,
          buildDynamicSlot(
            slotName,
            slotFunction,
            conditionalBranchIndex++
          ),
          defaultFallback
        ) : buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++);
      } else {
        context.onError(
          createCompilerError(30, vElse.loc)
        );
      }
    } else if (vFor) {
      hasDynamicSlots = true;
      const parseResult = vFor.forParseResult;
      if (parseResult) {
        finalizeForParseResult(parseResult, context);
        dynamicSlots.push(
          createCallExpression(context.helper(RENDER_LIST), [
            parseResult.source,
            createFunctionExpression(
              createForLoopParams(parseResult),
              buildDynamicSlot(slotName, slotFunction),
              true
            )
          ])
        );
      } else {
        context.onError(
          createCompilerError(
            32,
            vFor.loc
          )
        );
      }
    } else {
      if (staticSlotName) {
        if (seenSlotNames.has(staticSlotName)) {
          context.onError(
            createCompilerError(
              38,
              dirLoc
            )
          );
          continue;
        }
        seenSlotNames.add(staticSlotName);
        if (staticSlotName === "default") {
          hasNamedDefaultSlot = true;
        }
      }
      slotsProperties.push(createObjectProperty(slotName, slotFunction));
    }
  }
  if (!onComponentSlot) {
    const buildDefaultSlotProperty = (props, children2) => {
      const fn = buildSlotFn(props, void 0, children2, loc);
      if (context.compatConfig) {
        fn.isNonScopedSlot = true;
      }
      return createObjectProperty(`default`, fn);
    };
    if (!hasTemplateSlots) {
      slotsProperties.push(buildDefaultSlotProperty(void 0, children));
    } else if (implicitDefaultChildren.length && // #3766
    // with whitespace: 'preserve', whitespaces between slots will end up in
    // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
    implicitDefaultChildren.some((node2) => isNonWhitespaceContent(node2))) {
      if (hasNamedDefaultSlot) {
        context.onError(
          createCompilerError(
            39,
            implicitDefaultChildren[0].loc
          )
        );
      } else {
        slotsProperties.push(
          buildDefaultSlotProperty(void 0, implicitDefaultChildren)
        );
      }
    }
  }
  const slotFlag = hasDynamicSlots ? 2 : hasForwardedSlots(node.children) ? 3 : 1;
  let slots = createObjectExpression(
    slotsProperties.concat(
      createObjectProperty(
        `_`,
        // 2 = compiled but dynamic = can skip normalization, but must run diff
        // 1 = compiled and static = can skip normalization AND diff as optimized
        createSimpleExpression(
          slotFlag + ( false ? 0 : ``),
          false
        )
      )
    ),
    loc
  );
  if (dynamicSlots.length) {
    slots = createCallExpression(context.helper(CREATE_SLOTS), [
      slots,
      createArrayExpression(dynamicSlots)
    ]);
  }
  return {
    slots,
    hasDynamicSlots
  };
}
function buildDynamicSlot(name, fn, index) {
  const props = [
    createObjectProperty(`name`, name),
    createObjectProperty(`fn`, fn)
  ];
  if (index != null) {
    props.push(
      createObjectProperty(`key`, createSimpleExpression(String(index), true))
    );
  }
  return createObjectExpression(props);
}
function hasForwardedSlots(children) {
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    switch (child.type) {
      case 1:
        if (child.tagType === 2 || hasForwardedSlots(child.children)) {
          return true;
        }
        break;
      case 9:
        if (hasForwardedSlots(child.branches))
          return true;
        break;
      case 10:
      case 11:
        if (hasForwardedSlots(child.children))
          return true;
        break;
    }
  }
  return false;
}
function isNonWhitespaceContent(node) {
  if (node.type !== 2 && node.type !== 12)
    return true;
  return node.type === 2 ? !!node.content.trim() : isNonWhitespaceContent(node.content);
}

const directiveImportMap = /* @__PURE__ */ new WeakMap();
const transformElement = (node, context) => {
  return function postTransformElement() {
    node = context.currentNode;
    if (!(node.type === 1 && (node.tagType === 0 || node.tagType === 1))) {
      return;
    }
    const { tag, props } = node;
    const isComponent = node.tagType === 1;
    let vnodeTag = isComponent ? resolveComponentType(node, context) : `"${tag}"`;
    const isDynamicComponent = isObject(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
    let vnodeProps;
    let vnodeChildren;
    let vnodePatchFlag;
    let patchFlag = 0;
    let vnodeDynamicProps;
    let dynamicPropNames;
    let vnodeDirectives;
    let shouldUseBlock = (
      // dynamic component may resolve to plain elements
      isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent && // <svg> and <foreignObject> must be forced into blocks so that block
      // updates inside get proper isSVG flag at runtime. (#639, #643)
      // This is technically web-specific, but splitting the logic out of core
      // leads to too much unnecessary complexity.
      (tag === "svg" || tag === "foreignObject")
    );
    if (props.length > 0) {
      const propsBuildResult = buildProps(
        node,
        context,
        void 0,
        isComponent,
        isDynamicComponent
      );
      vnodeProps = propsBuildResult.props;
      patchFlag = propsBuildResult.patchFlag;
      dynamicPropNames = propsBuildResult.dynamicPropNames;
      const directives = propsBuildResult.directives;
      vnodeDirectives = directives && directives.length ? createArrayExpression(
        directives.map((dir) => buildDirectiveArgs(dir, context))
      ) : void 0;
      if (propsBuildResult.shouldUseBlock) {
        shouldUseBlock = true;
      }
    }
    if (node.children.length > 0) {
      if (vnodeTag === KEEP_ALIVE) {
        shouldUseBlock = true;
        patchFlag |= 1024;
        if (false) {}
      }
      const shouldBuildAsSlots = isComponent && // Teleport is not a real component and has dedicated runtime handling
      vnodeTag !== TELEPORT && // explained above.
      vnodeTag !== KEEP_ALIVE;
      if (shouldBuildAsSlots) {
        const { slots, hasDynamicSlots } = buildSlots(node, context);
        vnodeChildren = slots;
        if (hasDynamicSlots) {
          patchFlag |= 1024;
        }
      } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
        const child = node.children[0];
        const type = child.type;
        const hasDynamicTextChild = type === 5 || type === 8;
        if (hasDynamicTextChild && getConstantType(child, context) === 0) {
          patchFlag |= 1;
        }
        if (hasDynamicTextChild || type === 2) {
          vnodeChildren = child;
        } else {
          vnodeChildren = node.children;
        }
      } else {
        vnodeChildren = node.children;
      }
    }
    if (patchFlag !== 0) {
      if (false) {} else {
        vnodePatchFlag = String(patchFlag);
      }
      if (dynamicPropNames && dynamicPropNames.length) {
        vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
      }
    }
    node.codegenNode = createVNodeCall(
      context,
      vnodeTag,
      vnodeProps,
      vnodeChildren,
      vnodePatchFlag,
      vnodeDynamicProps,
      vnodeDirectives,
      !!shouldUseBlock,
      false,
      isComponent,
      node.loc
    );
  };
};
function resolveComponentType(node, context, ssr = false) {
  let { tag } = node;
  const isExplicitDynamic = isComponentTag(tag);
  const isProp = findProp(node, "is");
  if (isProp) {
    if (isExplicitDynamic || isCompatEnabled(
      "COMPILER_IS_ON_ELEMENT",
      context
    )) {
      const exp = isProp.type === 6 ? isProp.value && createSimpleExpression(isProp.value.content, true) : isProp.exp;
      if (exp) {
        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
          exp
        ]);
      }
    } else if (isProp.type === 6 && isProp.value.content.startsWith("vue:")) {
      tag = isProp.value.content.slice(4);
    }
  }
  const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
  if (builtIn) {
    if (!ssr)
      context.helper(builtIn);
    return builtIn;
  }
  context.helper(RESOLVE_COMPONENT);
  context.components.add(tag);
  return toValidAssetId(tag, `component`);
}
function buildProps(node, context, props = node.props, isComponent, isDynamicComponent, ssr = false) {
  const { tag, loc: elementLoc, children } = node;
  let properties = [];
  const mergeArgs = [];
  const runtimeDirectives = [];
  const hasChildren = children.length > 0;
  let shouldUseBlock = false;
  let patchFlag = 0;
  let hasRef = false;
  let hasClassBinding = false;
  let hasStyleBinding = false;
  let hasHydrationEventBinding = false;
  let hasDynamicKeys = false;
  let hasVnodeHook = false;
  const dynamicPropNames = [];
  const pushMergeArg = (arg) => {
    if (properties.length) {
      mergeArgs.push(
        createObjectExpression(dedupeProperties(properties), elementLoc)
      );
      properties = [];
    }
    if (arg)
      mergeArgs.push(arg);
  };
  const analyzePatchFlag = ({ key, value }) => {
    if (isStaticExp(key)) {
      const name = key.content;
      const isEventHandler = isOn(name);
      if (isEventHandler && (!isComponent || isDynamicComponent) && // omit the flag for click handlers because hydration gives click
      // dedicated fast path.
      name.toLowerCase() !== "onclick" && // omit v-model handlers
      name !== "onUpdate:modelValue" && // omit onVnodeXXX hooks
      !isReservedProp(name)) {
        hasHydrationEventBinding = true;
      }
      if (isEventHandler && isReservedProp(name)) {
        hasVnodeHook = true;
      }
      if (isEventHandler && value.type === 14) {
        value = value.arguments[0];
      }
      if (value.type === 20 || (value.type === 4 || value.type === 8) && getConstantType(value, context) > 0) {
        return;
      }
      if (name === "ref") {
        hasRef = true;
      } else if (name === "class") {
        hasClassBinding = true;
      } else if (name === "style") {
        hasStyleBinding = true;
      } else if (name !== "key" && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      }
      if (isComponent && (name === "class" || name === "style") && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      }
    } else {
      hasDynamicKeys = true;
    }
  };
  for (let i = 0; i < props.length; i++) {
    const prop = props[i];
    if (prop.type === 6) {
      const { loc, name, nameLoc, value } = prop;
      let isStatic = true;
      if (name === "ref") {
        hasRef = true;
        if (context.scopes.vFor > 0) {
          properties.push(
            createObjectProperty(
              createSimpleExpression("ref_for", true),
              createSimpleExpression("true")
            )
          );
        }
      }
      if (name === "is" && (isComponentTag(tag) || value && value.content.startsWith("vue:") || isCompatEnabled(
        "COMPILER_IS_ON_ELEMENT",
        context
      ))) {
        continue;
      }
      properties.push(
        createObjectProperty(
          createSimpleExpression(name, true, nameLoc),
          createSimpleExpression(
            value ? value.content : "",
            isStatic,
            value ? value.loc : loc
          )
        )
      );
    } else {
      const { name, arg, exp, loc, modifiers } = prop;
      const isVBind = name === "bind";
      const isVOn = name === "on";
      if (name === "slot") {
        if (!isComponent) {
          context.onError(
            createCompilerError(40, loc)
          );
        }
        continue;
      }
      if (name === "once" || name === "memo") {
        continue;
      }
      if (name === "is" || isVBind && isStaticArgOf(arg, "is") && (isComponentTag(tag) || isCompatEnabled(
        "COMPILER_IS_ON_ELEMENT",
        context
      ))) {
        continue;
      }
      if (isVOn && ssr) {
        continue;
      }
      if (
        // #938: elements with dynamic keys should be forced into blocks
        isVBind && isStaticArgOf(arg, "key") || // inline before-update hooks need to force block so that it is invoked
        // before children
        isVOn && hasChildren && isStaticArgOf(arg, "vue:before-update")
      ) {
        shouldUseBlock = true;
      }
      if (isVBind && isStaticArgOf(arg, "ref") && context.scopes.vFor > 0) {
        properties.push(
          createObjectProperty(
            createSimpleExpression("ref_for", true),
            createSimpleExpression("true")
          )
        );
      }
      if (!arg && (isVBind || isVOn)) {
        hasDynamicKeys = true;
        if (exp) {
          if (isVBind) {
            pushMergeArg();
            {
              if (false) {}
              if (isCompatEnabled(
                "COMPILER_V_BIND_OBJECT_ORDER",
                context
              )) {
                mergeArgs.unshift(exp);
                continue;
              }
            }
            mergeArgs.push(exp);
          } else {
            pushMergeArg({
              type: 14,
              loc,
              callee: context.helper(TO_HANDLERS),
              arguments: isComponent ? [exp] : [exp, `true`]
            });
          }
        } else {
          context.onError(
            createCompilerError(
              isVBind ? 34 : 35,
              loc
            )
          );
        }
        continue;
      }
      if (isVBind && modifiers.includes("prop")) {
        patchFlag |= 32;
      }
      const directiveTransform = context.directiveTransforms[name];
      if (directiveTransform) {
        const { props: props2, needRuntime } = directiveTransform(prop, node, context);
        !ssr && props2.forEach(analyzePatchFlag);
        if (isVOn && arg && !isStaticExp(arg)) {
          pushMergeArg(createObjectExpression(props2, elementLoc));
        } else {
          properties.push(...props2);
        }
        if (needRuntime) {
          runtimeDirectives.push(prop);
          if (isSymbol(needRuntime)) {
            directiveImportMap.set(prop, needRuntime);
          }
        }
      } else if (!isBuiltInDirective(name)) {
        runtimeDirectives.push(prop);
        if (hasChildren) {
          shouldUseBlock = true;
        }
      }
    }
  }
  let propsExpression = void 0;
  if (mergeArgs.length) {
    pushMergeArg();
    if (mergeArgs.length > 1) {
      propsExpression = createCallExpression(
        context.helper(MERGE_PROPS),
        mergeArgs,
        elementLoc
      );
    } else {
      propsExpression = mergeArgs[0];
    }
  } else if (properties.length) {
    propsExpression = createObjectExpression(
      dedupeProperties(properties),
      elementLoc
    );
  }
  if (hasDynamicKeys) {
    patchFlag |= 16;
  } else {
    if (hasClassBinding && !isComponent) {
      patchFlag |= 2;
    }
    if (hasStyleBinding && !isComponent) {
      patchFlag |= 4;
    }
    if (dynamicPropNames.length) {
      patchFlag |= 8;
    }
    if (hasHydrationEventBinding) {
      patchFlag |= 32;
    }
  }
  if (!shouldUseBlock && (patchFlag === 0 || patchFlag === 32) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
    patchFlag |= 512;
  }
  if (!context.inSSR && propsExpression) {
    switch (propsExpression.type) {
      case 15:
        let classKeyIndex = -1;
        let styleKeyIndex = -1;
        let hasDynamicKey = false;
        for (let i = 0; i < propsExpression.properties.length; i++) {
          const key = propsExpression.properties[i].key;
          if (isStaticExp(key)) {
            if (key.content === "class") {
              classKeyIndex = i;
            } else if (key.content === "style") {
              styleKeyIndex = i;
            }
          } else if (!key.isHandlerKey) {
            hasDynamicKey = true;
          }
        }
        const classProp = propsExpression.properties[classKeyIndex];
        const styleProp = propsExpression.properties[styleKeyIndex];
        if (!hasDynamicKey) {
          if (classProp && !isStaticExp(classProp.value)) {
            classProp.value = createCallExpression(
              context.helper(NORMALIZE_CLASS),
              [classProp.value]
            );
          }
          if (styleProp && // the static style is compiled into an object,
          // so use `hasStyleBinding` to ensure that it is a dynamic style binding
          (hasStyleBinding || styleProp.value.type === 4 && styleProp.value.content.trim()[0] === `[` || // v-bind:style and style both exist,
          // v-bind:style with static literal object
          styleProp.value.type === 17)) {
            styleProp.value = createCallExpression(
              context.helper(NORMALIZE_STYLE),
              [styleProp.value]
            );
          }
        } else {
          propsExpression = createCallExpression(
            context.helper(NORMALIZE_PROPS),
            [propsExpression]
          );
        }
        break;
      case 14:
        break;
      default:
        propsExpression = createCallExpression(
          context.helper(NORMALIZE_PROPS),
          [
            createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [
              propsExpression
            ])
          ]
        );
        break;
    }
  }
  return {
    props: propsExpression,
    directives: runtimeDirectives,
    patchFlag,
    dynamicPropNames,
    shouldUseBlock
  };
}
function dedupeProperties(properties) {
  const knownProps = /* @__PURE__ */ new Map();
  const deduped = [];
  for (let i = 0; i < properties.length; i++) {
    const prop = properties[i];
    if (prop.key.type === 8 || !prop.key.isStatic) {
      deduped.push(prop);
      continue;
    }
    const name = prop.key.content;
    const existing = knownProps.get(name);
    if (existing) {
      if (name === "style" || name === "class" || isOn(name)) {
        mergeAsArray(existing, prop);
      }
    } else {
      knownProps.set(name, prop);
      deduped.push(prop);
    }
  }
  return deduped;
}
function mergeAsArray(existing, incoming) {
  if (existing.value.type === 17) {
    existing.value.elements.push(incoming.value);
  } else {
    existing.value = createArrayExpression(
      [existing.value, incoming.value],
      existing.loc
    );
  }
}
function buildDirectiveArgs(dir, context) {
  const dirArgs = [];
  const runtime = directiveImportMap.get(dir);
  if (runtime) {
    dirArgs.push(context.helperString(runtime));
  } else {
    {
      context.helper(RESOLVE_DIRECTIVE);
      context.directives.add(dir.name);
      dirArgs.push(toValidAssetId(dir.name, `directive`));
    }
  }
  const { loc } = dir;
  if (dir.exp)
    dirArgs.push(dir.exp);
  if (dir.arg) {
    if (!dir.exp) {
      dirArgs.push(`void 0`);
    }
    dirArgs.push(dir.arg);
  }
  if (Object.keys(dir.modifiers).length) {
    if (!dir.arg) {
      if (!dir.exp) {
        dirArgs.push(`void 0`);
      }
      dirArgs.push(`void 0`);
    }
    const trueExpression = createSimpleExpression(`true`, false, loc);
    dirArgs.push(
      createObjectExpression(
        dir.modifiers.map(
          (modifier) => createObjectProperty(modifier, trueExpression)
        ),
        loc
      )
    );
  }
  return createArrayExpression(dirArgs, dir.loc);
}
function stringifyDynamicPropNames(props) {
  let propsNamesString = `[`;
  for (let i = 0, l = props.length; i < l; i++) {
    propsNamesString += JSON.stringify(props[i]);
    if (i < l - 1)
      propsNamesString += ", ";
  }
  return propsNamesString + `]`;
}
function isComponentTag(tag) {
  return tag === "component" || tag === "Component";
}

const transformSlotOutlet = (node, context) => {
  if (isSlotOutlet(node)) {
    const { children, loc } = node;
    const { slotName, slotProps } = processSlotOutlet(node, context);
    const slotArgs = [
      context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
      slotName,
      "{}",
      "undefined",
      "true"
    ];
    let expectedLen = 2;
    if (slotProps) {
      slotArgs[2] = slotProps;
      expectedLen = 3;
    }
    if (children.length) {
      slotArgs[3] = createFunctionExpression([], children, false, false, loc);
      expectedLen = 4;
    }
    if (context.scopeId && !context.slotted) {
      expectedLen = 5;
    }
    slotArgs.splice(expectedLen);
    node.codegenNode = createCallExpression(
      context.helper(RENDER_SLOT),
      slotArgs,
      loc
    );
  }
};
function processSlotOutlet(node, context) {
  let slotName = `"default"`;
  let slotProps = void 0;
  const nonNameProps = [];
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 6) {
      if (p.value) {
        if (p.name === "name") {
          slotName = JSON.stringify(p.value.content);
        } else {
          p.name = camelize(p.name);
          nonNameProps.push(p);
        }
      }
    } else {
      if (p.name === "bind" && isStaticArgOf(p.arg, "name")) {
        if (p.exp) {
          slotName = p.exp;
        } else if (p.arg && p.arg.type === 4) {
          const name = camelize(p.arg.content);
          slotName = p.exp = createSimpleExpression(name, false, p.arg.loc);
        }
      } else {
        if (p.name === "bind" && p.arg && isStaticExp(p.arg)) {
          p.arg.content = camelize(p.arg.content);
        }
        nonNameProps.push(p);
      }
    }
  }
  if (nonNameProps.length > 0) {
    const { props, directives } = buildProps(
      node,
      context,
      nonNameProps,
      false,
      false
    );
    slotProps = props;
    if (directives.length) {
      context.onError(
        createCompilerError(
          36,
          directives[0].loc
        )
      );
    }
  }
  return {
    slotName,
    slotProps
  };
}

const fnExpRE = /^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;
const transformOn$1 = (dir, node, context, augmentor) => {
  const { loc, modifiers, arg } = dir;
  if (!dir.exp && !modifiers.length) {
    context.onError(createCompilerError(35, loc));
  }
  let eventName;
  if (arg.type === 4) {
    if (arg.isStatic) {
      let rawName = arg.content;
      if (false) {}
      if (rawName.startsWith("vue:")) {
        rawName = `vnode-${rawName.slice(4)}`;
      }
      const eventString = node.tagType !== 0 || rawName.startsWith("vnode") || !/[A-Z]/.test(rawName) ? (
        // for non-element and vnode lifecycle event listeners, auto convert
        // it to camelCase. See issue #2249
        toHandlerKey(camelize(rawName))
      ) : (
        // preserve case for plain element listeners that have uppercase
        // letters, as these may be custom elements' custom events
        `on:${rawName}`
      );
      eventName = createSimpleExpression(eventString, true, arg.loc);
    } else {
      eventName = createCompoundExpression([
        `${context.helperString(TO_HANDLER_KEY)}(`,
        arg,
        `)`
      ]);
    }
  } else {
    eventName = arg;
    eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);
    eventName.children.push(`)`);
  }
  let exp = dir.exp;
  if (exp && !exp.content.trim()) {
    exp = void 0;
  }
  let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;
  if (exp) {
    const isMemberExp = isMemberExpression(exp.content);
    const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));
    const hasMultipleStatements = exp.content.includes(`;`);
    if (false) {}
    if (isInlineStatement || shouldCache && isMemberExp) {
      exp = createCompoundExpression([
        `${isInlineStatement ? `$event` : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
        exp,
        hasMultipleStatements ? `}` : `)`
      ]);
    }
  }
  let ret = {
    props: [
      createObjectProperty(
        eventName,
        exp || createSimpleExpression(`() => {}`, false, loc)
      )
    ]
  };
  if (augmentor) {
    ret = augmentor(ret);
  }
  if (shouldCache) {
    ret.props[0].value = context.cache(ret.props[0].value);
  }
  ret.props.forEach((p) => p.key.isHandlerKey = true);
  return ret;
};

const transformBind = (dir, _node, context) => {
  const { modifiers, loc } = dir;
  const arg = dir.arg;
  let { exp } = dir;
  if (exp && exp.type === 4 && !exp.content.trim()) {
    {
      exp = void 0;
    }
  }
  if (!exp) {
    if (arg.type !== 4 || !arg.isStatic) {
      context.onError(
        createCompilerError(
          52,
          arg.loc
        )
      );
      return {
        props: [
          createObjectProperty(arg, createSimpleExpression("", true, loc))
        ]
      };
    }
    const propName = camelize(arg.content);
    exp = dir.exp = createSimpleExpression(propName, false, arg.loc);
  }
  if (arg.type !== 4) {
    arg.children.unshift(`(`);
    arg.children.push(`) || ""`);
  } else if (!arg.isStatic) {
    arg.content = `${arg.content} || ""`;
  }
  if (modifiers.includes("camel")) {
    if (arg.type === 4) {
      if (arg.isStatic) {
        arg.content = camelize(arg.content);
      } else {
        arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
      }
    } else {
      arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
      arg.children.push(`)`);
    }
  }
  if (!context.inSSR) {
    if (modifiers.includes("prop")) {
      injectPrefix(arg, ".");
    }
    if (modifiers.includes("attr")) {
      injectPrefix(arg, "^");
    }
  }
  return {
    props: [createObjectProperty(arg, exp)]
  };
};
const injectPrefix = (arg, prefix) => {
  if (arg.type === 4) {
    if (arg.isStatic) {
      arg.content = prefix + arg.content;
    } else {
      arg.content = `\`${prefix}\${${arg.content}}\``;
    }
  } else {
    arg.children.unshift(`'${prefix}' + (`);
    arg.children.push(`)`);
  }
};

const transformText = (node, context) => {
  if (node.type === 0 || node.type === 1 || node.type === 11 || node.type === 10) {
    return () => {
      const children = node.children;
      let currentContainer = void 0;
      let hasText = false;
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (isText$1(child)) {
          hasText = true;
          for (let j = i + 1; j < children.length; j++) {
            const next = children[j];
            if (isText$1(next)) {
              if (!currentContainer) {
                currentContainer = children[i] = createCompoundExpression(
                  [child],
                  child.loc
                );
              }
              currentContainer.children.push(` + `, next);
              children.splice(j, 1);
              j--;
            } else {
              currentContainer = void 0;
              break;
            }
          }
        }
      }
      if (!hasText || // if this is a plain element with a single text child, leave it
      // as-is since the runtime has dedicated fast path for this by directly
      // setting textContent of the element.
      // for component root it's always normalized anyway.
      children.length === 1 && (node.type === 0 || node.type === 1 && node.tagType === 0 && // #3756
      // custom directives can potentially add DOM elements arbitrarily,
      // we need to avoid setting textContent of the element at runtime
      // to avoid accidentally overwriting the DOM elements added
      // by the user through custom directives.
      !node.props.find(
        (p) => p.type === 7 && !context.directiveTransforms[p.name]
      ) && // in compat mode, <template> tags with no special directives
      // will be rendered as a fragment so its children must be
      // converted into vnodes.
      !(node.tag === "template"))) {
        return;
      }
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (isText$1(child) || child.type === 8) {
          const callArgs = [];
          if (child.type !== 2 || child.content !== " ") {
            callArgs.push(child);
          }
          if (!context.ssr && getConstantType(child, context) === 0) {
            callArgs.push(
              1 + ( false ? 0 : ``)
            );
          }
          children[i] = {
            type: 12,
            content: child,
            loc: child.loc,
            codegenNode: createCallExpression(
              context.helper(CREATE_TEXT),
              callArgs
            )
          };
        }
      }
    };
  }
};

const seen$1 = /* @__PURE__ */ new WeakSet();
const transformOnce = (node, context) => {
  if (node.type === 1 && findDir(node, "once", true)) {
    if (seen$1.has(node) || context.inVOnce || context.inSSR) {
      return;
    }
    seen$1.add(node);
    context.inVOnce = true;
    context.helper(SET_BLOCK_TRACKING);
    return () => {
      context.inVOnce = false;
      const cur = context.currentNode;
      if (cur.codegenNode) {
        cur.codegenNode = context.cache(
          cur.codegenNode,
          true
          /* isVNode */
        );
      }
    };
  }
};

const transformModel$1 = (dir, node, context) => {
  const { exp, arg } = dir;
  if (!exp) {
    context.onError(
      createCompilerError(41, dir.loc)
    );
    return createTransformProps();
  }
  const rawExp = exp.loc.source;
  const expString = exp.type === 4 ? exp.content : rawExp;
  const bindingType = context.bindingMetadata[rawExp];
  if (bindingType === "props" || bindingType === "props-aliased") {
    context.onError(createCompilerError(44, exp.loc));
    return createTransformProps();
  }
  const maybeRef = false;
  if (!expString.trim() || !isMemberExpression(expString) && !maybeRef) {
    context.onError(
      createCompilerError(42, exp.loc)
    );
    return createTransformProps();
  }
  const propName = arg ? arg : createSimpleExpression("modelValue", true);
  const eventName = arg ? isStaticExp(arg) ? `onUpdate:${camelize(arg.content)}` : createCompoundExpression(['"onUpdate:" + ', arg]) : `onUpdate:modelValue`;
  let assignmentExp;
  const eventArg = context.isTS ? `($event: any)` : `$event`;
  {
    assignmentExp = createCompoundExpression([
      `${eventArg} => ((`,
      exp,
      `) = $event)`
    ]);
  }
  const props = [
    // modelValue: foo
    createObjectProperty(propName, dir.exp),
    // "onUpdate:modelValue": $event => (foo = $event)
    createObjectProperty(eventName, assignmentExp)
  ];
  if (dir.modifiers.length && node.tagType === 1) {
    const modifiers = dir.modifiers.map((m) => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`).join(`, `);
    const modifiersKey = arg ? isStaticExp(arg) ? `${arg.content}Modifiers` : createCompoundExpression([arg, ' + "Modifiers"']) : `modelModifiers`;
    props.push(
      createObjectProperty(
        modifiersKey,
        createSimpleExpression(
          `{ ${modifiers} }`,
          false,
          dir.loc,
          2
        )
      )
    );
  }
  return createTransformProps(props);
};
function createTransformProps(props = []) {
  return { props };
}

const validDivisionCharRE = /[\w).+\-_$\]]/;
const transformFilter = (node, context) => {
  if (!isCompatEnabled("COMPILER_FILTERS", context)) {
    return;
  }
  if (node.type === 5) {
    rewriteFilter(node.content, context);
  }
  if (node.type === 1) {
    node.props.forEach((prop) => {
      if (prop.type === 7 && prop.name !== "for" && prop.exp) {
        rewriteFilter(prop.exp, context);
      }
    });
  }
};
function rewriteFilter(node, context) {
  if (node.type === 4) {
    parseFilter(node, context);
  } else {
    for (let i = 0; i < node.children.length; i++) {
      const child = node.children[i];
      if (typeof child !== "object")
        continue;
      if (child.type === 4) {
        parseFilter(child, context);
      } else if (child.type === 8) {
        rewriteFilter(node, context);
      } else if (child.type === 5) {
        rewriteFilter(child.content, context);
      }
    }
  }
}
function parseFilter(node, context) {
  const exp = node.content;
  let inSingle = false;
  let inDouble = false;
  let inTemplateString = false;
  let inRegex = false;
  let curly = 0;
  let square = 0;
  let paren = 0;
  let lastFilterIndex = 0;
  let c, prev, i, expression, filters = [];
  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);
    if (inSingle) {
      if (c === 39 && prev !== 92)
        inSingle = false;
    } else if (inDouble) {
      if (c === 34 && prev !== 92)
        inDouble = false;
    } else if (inTemplateString) {
      if (c === 96 && prev !== 92)
        inTemplateString = false;
    } else if (inRegex) {
      if (c === 47 && prev !== 92)
        inRegex = false;
    } else if (c === 124 && // pipe
    exp.charCodeAt(i + 1) !== 124 && exp.charCodeAt(i - 1) !== 124 && !curly && !square && !paren) {
      if (expression === void 0) {
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 34:
          inDouble = true;
          break;
        case 39:
          inSingle = true;
          break;
        case 96:
          inTemplateString = true;
          break;
        case 40:
          paren++;
          break;
        case 41:
          paren--;
          break;
        case 91:
          square++;
          break;
        case 93:
          square--;
          break;
        case 123:
          curly++;
          break;
        case 125:
          curly--;
          break;
      }
      if (c === 47) {
        let j = i - 1;
        let p;
        for (; j >= 0; j--) {
          p = exp.charAt(j);
          if (p !== " ")
            break;
        }
        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }
  if (expression === void 0) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }
  function pushFilter() {
    filters.push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }
  if (filters.length) {
     false && 0;
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i], context);
    }
    node.content = expression;
  }
}
function wrapFilter(exp, filter, context) {
  context.helper(RESOLVE_FILTER);
  const i = filter.indexOf("(");
  if (i < 0) {
    context.filters.add(filter);
    return `${toValidAssetId(filter, "filter")}(${exp})`;
  } else {
    const name = filter.slice(0, i);
    const args = filter.slice(i + 1);
    context.filters.add(name);
    return `${toValidAssetId(name, "filter")}(${exp}${args !== ")" ? "," + args : args}`;
  }
}

const seen = /* @__PURE__ */ new WeakSet();
const transformMemo = (node, context) => {
  if (node.type === 1) {
    const dir = findDir(node, "memo");
    if (!dir || seen.has(node)) {
      return;
    }
    seen.add(node);
    return () => {
      const codegenNode = node.codegenNode || context.currentNode.codegenNode;
      if (codegenNode && codegenNode.type === 13) {
        if (node.tagType !== 1) {
          convertToBlock(codegenNode, context);
        }
        node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [
          dir.exp,
          createFunctionExpression(void 0, codegenNode),
          `_cache`,
          String(context.cached++)
        ]);
      }
    };
  }
};

function getBaseTransformPreset(prefixIdentifiers) {
  return [
    [
      transformOnce,
      transformIf,
      transformMemo,
      transformFor,
      ...[transformFilter] ,
      ... false ? 0 : [],
      transformSlotOutlet,
      transformElement,
      trackSlotScopes,
      transformText
    ],
    {
      on: transformOn$1,
      bind: transformBind,
      model: transformModel$1
    }
  ];
}
function baseCompile(source, options = {}) {
  const onError = options.onError || defaultOnError;
  const isModuleMode = options.mode === "module";
  {
    if (options.prefixIdentifiers === true) {
      onError(createCompilerError(47));
    } else if (isModuleMode) {
      onError(createCompilerError(48));
    }
  }
  const prefixIdentifiers = false;
  if (options.cacheHandlers) {
    onError(createCompilerError(49));
  }
  if (options.scopeId && !isModuleMode) {
    onError(createCompilerError(50));
  }
  const resolvedOptions = extend({}, options, {
    prefixIdentifiers
  });
  const ast = isString(source) ? baseParse(source, resolvedOptions) : source;
  const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();
  transform(
    ast,
    extend({}, resolvedOptions, {
      nodeTransforms: [
        ...nodeTransforms,
        ...options.nodeTransforms || []
        // user transforms
      ],
      directiveTransforms: extend(
        {},
        directiveTransforms,
        options.directiveTransforms || {}
        // user transforms
      )
    })
  );
  return generate(ast, resolvedOptions);
}

const noopDirectiveTransform = () => ({ props: [] });

const V_MODEL_RADIO = Symbol( false ? 0 : ``);
const V_MODEL_CHECKBOX = Symbol( false ? 0 : ``);
const V_MODEL_TEXT = Symbol( false ? 0 : ``);
const V_MODEL_SELECT = Symbol( false ? 0 : ``);
const V_MODEL_DYNAMIC = Symbol( false ? 0 : ``);
const V_ON_WITH_MODIFIERS = Symbol( false ? 0 : ``);
const V_ON_WITH_KEYS = Symbol( false ? 0 : ``);
const V_SHOW = Symbol( false ? 0 : ``);
const TRANSITION = Symbol( false ? 0 : ``);
const TRANSITION_GROUP = Symbol( false ? 0 : ``);
registerRuntimeHelpers({
  [V_MODEL_RADIO]: `vModelRadio`,
  [V_MODEL_CHECKBOX]: `vModelCheckbox`,
  [V_MODEL_TEXT]: `vModelText`,
  [V_MODEL_SELECT]: `vModelSelect`,
  [V_MODEL_DYNAMIC]: `vModelDynamic`,
  [V_ON_WITH_MODIFIERS]: `withModifiers`,
  [V_ON_WITH_KEYS]: `withKeys`,
  [V_SHOW]: `vShow`,
  [TRANSITION]: `Transition`,
  [TRANSITION_GROUP]: `TransitionGroup`
});

let decoder;
function decodeHtmlBrowser(raw, asAttr = false) {
  if (!decoder) {
    decoder = document.createElement("div");
  }
  if (asAttr) {
    decoder.innerHTML = `<div foo="${raw.replace(/"/g, "&quot;")}">`;
    return decoder.children[0].getAttribute("foo");
  } else {
    decoder.innerHTML = raw;
    return decoder.textContent;
  }
}

const parserOptions = {
  parseMode: "html",
  isVoidTag,
  isNativeTag: (tag) => isHTMLTag(tag) || isSVGTag(tag) || isMathMLTag(tag),
  isPreTag: (tag) => tag === "pre",
  decodeEntities: decodeHtmlBrowser ,
  isBuiltInComponent: (tag) => {
    if (tag === "Transition" || tag === "transition") {
      return TRANSITION;
    } else if (tag === "TransitionGroup" || tag === "transition-group") {
      return TRANSITION_GROUP;
    }
  },
  // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
  getNamespace(tag, parent, rootNamespace) {
    let ns = parent ? parent.ns : rootNamespace;
    if (parent && ns === 2) {
      if (parent.tag === "annotation-xml") {
        if (tag === "svg") {
          return 1;
        }
        if (parent.props.some(
          (a) => a.type === 6 && a.name === "encoding" && a.value != null && (a.value.content === "text/html" || a.value.content === "application/xhtml+xml")
        )) {
          ns = 0;
        }
      } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== "mglyph" && tag !== "malignmark") {
        ns = 0;
      }
    } else if (parent && ns === 1) {
      if (parent.tag === "foreignObject" || parent.tag === "desc" || parent.tag === "title") {
        ns = 0;
      }
    }
    if (ns === 0) {
      if (tag === "svg") {
        return 1;
      }
      if (tag === "math") {
        return 2;
      }
    }
    return ns;
  }
};

const transformStyle = (node) => {
  if (node.type === 1) {
    node.props.forEach((p, i) => {
      if (p.type === 6 && p.name === "style" && p.value) {
        node.props[i] = {
          type: 7,
          name: `bind`,
          arg: createSimpleExpression(`style`, true, p.loc),
          exp: parseInlineCSS(p.value.content, p.loc),
          modifiers: [],
          loc: p.loc
        };
      }
    });
  }
};
const parseInlineCSS = (cssText, loc) => {
  const normalized = parseStringStyle(cssText);
  return createSimpleExpression(
    JSON.stringify(normalized),
    false,
    loc,
    3
  );
};

function createDOMCompilerError(code, loc) {
  return createCompilerError(
    code,
    loc,
     false ? 0 : void 0
  );
}
const DOMErrorMessages = {
  [53]: `v-html is missing expression.`,
  [54]: `v-html will override element children.`,
  [55]: `v-text is missing expression.`,
  [56]: `v-text will override element children.`,
  [57]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
  [58]: `v-model argument is not supported on plain elements.`,
  [59]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
  [60]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
  [61]: `v-show is missing expression.`,
  [62]: `<Transition> expects exactly one child element or component.`,
  [63]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
};

const transformVHtml = (dir, node, context) => {
  const { exp, loc } = dir;
  if (!exp) {
    context.onError(
      createDOMCompilerError(53, loc)
    );
  }
  if (node.children.length) {
    context.onError(
      createDOMCompilerError(54, loc)
    );
    node.children.length = 0;
  }
  return {
    props: [
      createObjectProperty(
        createSimpleExpression(`innerHTML`, true, loc),
        exp || createSimpleExpression("", true)
      )
    ]
  };
};

const transformVText = (dir, node, context) => {
  const { exp, loc } = dir;
  if (!exp) {
    context.onError(
      createDOMCompilerError(55, loc)
    );
  }
  if (node.children.length) {
    context.onError(
      createDOMCompilerError(56, loc)
    );
    node.children.length = 0;
  }
  return {
    props: [
      createObjectProperty(
        createSimpleExpression(`textContent`, true),
        exp ? getConstantType(exp, context) > 0 ? exp : createCallExpression(
          context.helperString(TO_DISPLAY_STRING),
          [exp],
          loc
        ) : createSimpleExpression("", true)
      )
    ]
  };
};

const transformModel = (dir, node, context) => {
  const baseResult = transformModel$1(dir, node, context);
  if (!baseResult.props.length || node.tagType === 1) {
    return baseResult;
  }
  if (dir.arg) {
    context.onError(
      createDOMCompilerError(
        58,
        dir.arg.loc
      )
    );
  }
  function checkDuplicatedValue() {
    const value = findDir(node, "bind");
    if (value && isStaticArgOf(value.arg, "value")) {
      context.onError(
        createDOMCompilerError(
          60,
          value.loc
        )
      );
    }
  }
  const { tag } = node;
  const isCustomElement = context.isCustomElement(tag);
  if (tag === "input" || tag === "textarea" || tag === "select" || isCustomElement) {
    let directiveToUse = V_MODEL_TEXT;
    let isInvalidType = false;
    if (tag === "input" || isCustomElement) {
      const type = findProp(node, `type`);
      if (type) {
        if (type.type === 7) {
          directiveToUse = V_MODEL_DYNAMIC;
        } else if (type.value) {
          switch (type.value.content) {
            case "radio":
              directiveToUse = V_MODEL_RADIO;
              break;
            case "checkbox":
              directiveToUse = V_MODEL_CHECKBOX;
              break;
            case "file":
              isInvalidType = true;
              context.onError(
                createDOMCompilerError(
                  59,
                  dir.loc
                )
              );
              break;
            default:
               false && 0;
              break;
          }
        }
      } else if (hasDynamicKeyVBind(node)) {
        directiveToUse = V_MODEL_DYNAMIC;
      } else {
         false && 0;
      }
    } else if (tag === "select") {
      directiveToUse = V_MODEL_SELECT;
    } else {
       false && 0;
    }
    if (!isInvalidType) {
      baseResult.needRuntime = context.helper(directiveToUse);
    }
  } else {
    context.onError(
      createDOMCompilerError(
        57,
        dir.loc
      )
    );
  }
  baseResult.props = baseResult.props.filter(
    (p) => !(p.key.type === 4 && p.key.content === "modelValue")
  );
  return baseResult;
};

const isEventOptionModifier = /* @__PURE__ */ makeMap(`passive,once,capture`);
const isNonKeyModifier = /* @__PURE__ */ makeMap(
  // event propagation management
  `stop,prevent,self,ctrl,shift,alt,meta,exact,middle`
);
const maybeKeyModifier = /* @__PURE__ */ makeMap("left,right");
const isKeyboardEvent = /* @__PURE__ */ makeMap(
  `onkeyup,onkeydown,onkeypress`,
  true
);
const resolveModifiers = (key, modifiers, context, loc) => {
  const keyModifiers = [];
  const nonKeyModifiers = [];
  const eventOptionModifiers = [];
  for (let i = 0; i < modifiers.length; i++) {
    const modifier = modifiers[i];
    if (modifier === "native" && checkCompatEnabled(
      "COMPILER_V_ON_NATIVE",
      context,
      loc
    )) {
      eventOptionModifiers.push(modifier);
    } else if (isEventOptionModifier(modifier)) {
      eventOptionModifiers.push(modifier);
    } else {
      if (maybeKeyModifier(modifier)) {
        if (isStaticExp(key)) {
          if (isKeyboardEvent(key.content)) {
            keyModifiers.push(modifier);
          } else {
            nonKeyModifiers.push(modifier);
          }
        } else {
          keyModifiers.push(modifier);
          nonKeyModifiers.push(modifier);
        }
      } else {
        if (isNonKeyModifier(modifier)) {
          nonKeyModifiers.push(modifier);
        } else {
          keyModifiers.push(modifier);
        }
      }
    }
  }
  return {
    keyModifiers,
    nonKeyModifiers,
    eventOptionModifiers
  };
};
const transformClick = (key, event) => {
  const isStaticClick = isStaticExp(key) && key.content.toLowerCase() === "onclick";
  return isStaticClick ? createSimpleExpression(event, true) : key.type !== 4 ? createCompoundExpression([
    `(`,
    key,
    `) === "onClick" ? "${event}" : (`,
    key,
    `)`
  ]) : key;
};
const transformOn = (dir, node, context) => {
  return transformOn$1(dir, node, context, (baseResult) => {
    const { modifiers } = dir;
    if (!modifiers.length)
      return baseResult;
    let { key, value: handlerExp } = baseResult.props[0];
    const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context, dir.loc);
    if (nonKeyModifiers.includes("right")) {
      key = transformClick(key, `onContextmenu`);
    }
    if (nonKeyModifiers.includes("middle")) {
      key = transformClick(key, `onMouseup`);
    }
    if (nonKeyModifiers.length) {
      handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [
        handlerExp,
        JSON.stringify(nonKeyModifiers)
      ]);
    }
    if (keyModifiers.length && // if event name is dynamic, always wrap with keys guard
    (!isStaticExp(key) || isKeyboardEvent(key.content))) {
      handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [
        handlerExp,
        JSON.stringify(keyModifiers)
      ]);
    }
    if (eventOptionModifiers.length) {
      const modifierPostfix = eventOptionModifiers.map(capitalize).join("");
      key = isStaticExp(key) ? createSimpleExpression(`${key.content}${modifierPostfix}`, true) : createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`]);
    }
    return {
      props: [createObjectProperty(key, handlerExp)]
    };
  });
};

const transformShow = (dir, node, context) => {
  const { exp, loc } = dir;
  if (!exp) {
    context.onError(
      createDOMCompilerError(61, loc)
    );
  }
  return {
    props: [],
    needRuntime: context.helper(V_SHOW)
  };
};

const transformTransition = (node, context) => {
  if (node.type === 1 && node.tagType === 1) {
    const component = context.isBuiltInComponent(node.tag);
    if (component === TRANSITION) {
      return () => {
        if (!node.children.length) {
          return;
        }
        if (hasMultipleChildren(node)) {
          context.onError(
            createDOMCompilerError(
              62,
              {
                start: node.children[0].loc.start,
                end: node.children[node.children.length - 1].loc.end,
                source: ""
              }
            )
          );
        }
        const child = node.children[0];
        if (child.type === 1) {
          for (const p of child.props) {
            if (p.type === 7 && p.name === "show") {
              node.props.push({
                type: 6,
                name: "persisted",
                nameLoc: node.loc,
                value: void 0,
                loc: node.loc
              });
            }
          }
        }
      };
    }
  }
};
function hasMultipleChildren(node) {
  const children = node.children = node.children.filter(
    (c) => c.type !== 3 && !(c.type === 2 && !c.content.trim())
  );
  const child = children[0];
  return children.length !== 1 || child.type === 11 || child.type === 9 && child.branches.some(hasMultipleChildren);
}

const ignoreSideEffectTags = (node, context) => {
  if (node.type === 1 && node.tagType === 0 && (node.tag === "script" || node.tag === "style")) {
     false && 0;
    context.removeNode();
  }
};

const DOMNodeTransforms = [
  transformStyle,
  ... false ? 0 : []
];
const DOMDirectiveTransforms = {
  cloak: noopDirectiveTransform,
  html: transformVHtml,
  text: transformVText,
  model: transformModel,
  // override compiler-core
  on: transformOn,
  // override compiler-core
  show: transformShow
};
function compile(src, options = {}) {
  return baseCompile(
    src,
    extend({}, parserOptions, options, {
      nodeTransforms: [
        // ignore <script> and <tag>
        // this is not put inside DOMNodeTransforms because that list is used
        // by compiler-ssr to generate vnode fallback branches
        ignoreSideEffectTags,
        ...DOMNodeTransforms,
        ...options.nodeTransforms || []
      ],
      directiveTransforms: extend(
        {},
        DOMDirectiveTransforms,
        options.directiveTransforms || {}
      ),
      transformHoist: null 
    })
  );
}

const compileCache = /* @__PURE__ */ Object.create(null);
function compileToFunction(template, options) {
  if (!isString(template)) {
    if (template.nodeType) {
      template = template.innerHTML;
    } else {
       false && 0;
      return NOOP;
    }
  }
  const key = template;
  const cached = compileCache[key];
  if (cached) {
    return cached;
  }
  if (template[0] === "#") {
    const el = document.querySelector(template);
    if (false) {}
    template = el ? el.innerHTML : ``;
  }
  if (false) {}
  const { code } = compile(
    template,
    extend(
      {
        hoistStatic: true,
        whitespace: "preserve",
        onError:  false ? 0 : void 0,
        onWarn:  false ? 0 : NOOP
      },
      options
    )
  );
  function onError(err, asWarning = false) {
    const message = asWarning ? err.message : `Template compilation error: ${err.message}`;
    const codeFrame = err.loc && generateCodeFrame(
      template,
      err.loc.start.offset,
      err.loc.end.offset
    );
    warn(codeFrame ? `${message}
${codeFrame}` : message);
  }
  const render = new Function("Vue", code)(runtimeDom);
  render._rc = true;
  return compileCache[key] = render;
}
registerRuntimeCompiler(compileToFunction);
const Vue = createCompatVue();
Vue.compile = compileToFunction;
var Vue$1 = Vue;

const { configureCompat } = Vue$1;




/***/ }),

/***/ 416:
/***/ (function() {

(function(self) {

var irrelevant = (function (exports) {

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob:
      'FileReader' in self &&
      'Blob' in self &&
      (function() {
        try {
          new Blob();
          return true
        } catch (e) {
          return false
        }
      })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  };

  function isDataView(obj) {
    return obj && DataView.prototype.isPrototypeOf(obj)
  }

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ];

    var isArrayBufferView =
      ArrayBuffer.isView ||
      function(obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
      };
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift();
        return {done: value === undefined, value: value}
      }
    };

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      };
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue + ', ' + value : value;
  };

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null
  };

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  };

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this);
      }
    }
  };

  Headers.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push(name);
    });
    return iteratorFor(items)
  };

  Headers.prototype.values = function() {
    var items = [];
    this.forEach(function(value) {
      items.push(value);
    });
    return iteratorFor(items)
  };

  Headers.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push([name, value]);
    });
    return iteratorFor(items)
  };

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result);
      };
      reader.onerror = function() {
        reject(reader.error);
      };
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsText(blob);
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i]);
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false;

    this._initBody = function(body) {
      this._bodyInit = body;
      if (!body) {
        this._bodyText = '';
      } else if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        this._bodyText = body = Object.prototype.toString.call(body);
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8');
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
      }
    };

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      };

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      };
    }

    this.text = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    };

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      };
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    };

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return methods.indexOf(upcased) > -1 ? upcased : method
  }

  function Request(input, options) {
    options = options || {};
    var body = options.body;

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      this.signal = input.signal;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }

    this.credentials = options.credentials || this.credentials || 'same-origin';
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.signal = options.signal || this.signal;
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body);
  }

  Request.prototype.clone = function() {
    return new Request(this, {body: this._bodyInit})
  };

  function decode(body) {
    var form = new FormData();
    body
      .trim()
      .split('&')
      .forEach(function(bytes) {
        if (bytes) {
          var split = bytes.split('=');
          var name = split.shift().replace(/\+/g, ' ');
          var value = split.join('=').replace(/\+/g, ' ');
          form.append(decodeURIComponent(name), decodeURIComponent(value));
        }
      });
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers();
    // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
    // https://tools.ietf.org/html/rfc7230#section-3.2
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
    preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':');
      var key = parts.shift().trim();
      if (key) {
        var value = parts.join(':').trim();
        headers.append(key, value);
      }
    });
    return headers
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!options) {
      options = {};
    }

    this.type = 'default';
    this.status = options.status === undefined ? 200 : options.status;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = 'statusText' in options ? options.statusText : 'OK';
    this.headers = new Headers(options.headers);
    this.url = options.url || '';
    this._initBody(bodyInit);
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  };

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''});
    response.type = 'error';
    return response
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  };

  exports.DOMException = self.DOMException;
  try {
    new exports.DOMException();
  } catch (err) {
    exports.DOMException = function(message, name) {
      this.message = message;
      this.name = name;
      var error = Error(message);
      this.stack = error.stack;
    };
    exports.DOMException.prototype = Object.create(Error.prototype);
    exports.DOMException.prototype.constructor = exports.DOMException;
  }

  function fetch(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init);

      if (request.signal && request.signal.aborted) {
        return reject(new exports.DOMException('Aborted', 'AbortError'))
      }

      var xhr = new XMLHttpRequest();

      function abortXhr() {
        xhr.abort();
      }

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        };
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options));
      };

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.onabort = function() {
        reject(new exports.DOMException('Aborted', 'AbortError'));
      };

      xhr.open(request.method, request.url, true);

      if (request.credentials === 'include') {
        xhr.withCredentials = true;
      } else if (request.credentials === 'omit') {
        xhr.withCredentials = false;
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob';
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });

      if (request.signal) {
        request.signal.addEventListener('abort', abortXhr);

        xhr.onreadystatechange = function() {
          // DONE (success or failure)
          if (xhr.readyState === 4) {
            request.signal.removeEventListener('abort', abortXhr);
          }
        };
      }

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    })
  }

  fetch.polyfill = true;

  if (!self.fetch) {
    self.fetch = fetch;
    self.Headers = Headers;
    self.Request = Request;
    self.Response = Response;
  }

  exports.Headers = Headers;
  exports.Request = Request;
  exports.Response = Response;
  exports.fetch = fetch;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

})({});
})(typeof self !== 'undefined' ? self : this);


/***/ }),

/***/ 376:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var root = __webpack_require__(764);

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),

/***/ 165:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var Symbol = __webpack_require__(376),
    getRawTag = __webpack_require__(916),
    objectToString = __webpack_require__(480);

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),

/***/ 233:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var trimmedEndIndex = __webpack_require__(947);

/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string
    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
    : string;
}

module.exports = baseTrim;


/***/ }),

/***/ 557:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

module.exports = freeGlobal;


/***/ }),

/***/ 916:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var Symbol = __webpack_require__(376);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),

/***/ 480:
/***/ (function(module) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),

/***/ 764:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var freeGlobal = __webpack_require__(557);

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),

/***/ 947:
/***/ (function(module) {

/** Used to match a single whitespace character. */
var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}

module.exports = trimmedEndIndex;


/***/ }),

/***/ 730:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isObject = __webpack_require__(378),
    now = __webpack_require__(961),
    toNumber = __webpack_require__(493);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;

    return maxing
      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

module.exports = debounce;


/***/ }),

/***/ 378:
/***/ (function(module) {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),

/***/ 997:
/***/ (function(module) {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),

/***/ 885:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseGetTag = __webpack_require__(165),
    isObjectLike = __webpack_require__(997);

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;


/***/ }),

/***/ 961:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var root = __webpack_require__(764);

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

module.exports = now;


/***/ }),

/***/ 493:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseTrim = __webpack_require__(233),
    isObject = __webpack_require__(378),
    isSymbol = __webpack_require__(885);

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;


/***/ }),

/***/ 779:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

(function (global, factory) {
   true ? factory(exports) :
  0;
})(this, (function (exports) { 'use strict';

  // Type definitions for meilisearch
  // Project: https://github.com/meilisearch/meilisearch-js
  // Definitions by: qdequele <quentin@meilisearch.com> <https://github.com/meilisearch>
  // Definitions: https://github.com/meilisearch/meilisearch-js
  // TypeScript Version: ^3.8.3
  /*
   * SEARCH PARAMETERS
   */
  var MatchingStrategies = {
    ALL: 'all',
    LAST: 'last'
  };
  var ContentTypeEnum = {
    JSON: 'application/json',
    CSV: 'text/csv',
    NDJSON: 'application/x-ndjson'
  };
  /*
   ** TASKS
   */
  var TaskStatus = {
    TASK_SUCCEEDED: 'succeeded',
    TASK_PROCESSING: 'processing',
    TASK_FAILED: 'failed',
    TASK_ENQUEUED: 'enqueued',
    TASK_CANCELED: 'canceled'
  };
  var TaskTypes = {
    DOCUMENTS_ADDITION_OR_UPDATE: 'documentAdditionOrUpdate',
    DOCUMENT_DELETION: 'documentDeletion',
    DUMP_CREATION: 'dumpCreation',
    INDEX_CREATION: 'indexCreation',
    INDEX_DELETION: 'indexDeletion',
    INDEXES_SWAP: 'indexSwap',
    INDEX_UPDATE: 'indexUpdate',
    SETTINGS_UPDATE: 'settingsUpdate',
    SNAPSHOT_CREATION: 'snapshotCreation',
    TASK_CANCELATION: 'taskCancelation',
    TASK_DELETION: 'taskDeletion'
  };
  var ErrorStatusCode = {
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#index_creation_failed */
    INDEX_CREATION_FAILED: 'index_creation_failed',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_index_uid */
    MISSING_INDEX_UID: 'missing_index_uid',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#index_already_exists */
    INDEX_ALREADY_EXISTS: 'index_already_exists',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#index_not_found */
    INDEX_NOT_FOUND: 'index_not_found',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_index_uid */
    INVALID_INDEX_UID: 'invalid_index_uid',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#index_not_accessible */
    INDEX_NOT_ACCESSIBLE: 'index_not_accessible',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_index_offset */
    INVALID_INDEX_OFFSET: 'invalid_index_offset',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_index_limit */
    INVALID_INDEX_LIMIT: 'invalid_index_limit',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_state */
    INVALID_STATE: 'invalid_state',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#primary_key_inference_failed */
    PRIMARY_KEY_INFERENCE_FAILED: 'primary_key_inference_failed',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#index_primary_key_already_exists */
    INDEX_PRIMARY_KEY_ALREADY_EXISTS: 'index_primary_key_already_exists',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_index_primary_key */
    INVALID_INDEX_PRIMARY_KEY: 'invalid_index_primary_key',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#max_fields_limit_exceeded */
    DOCUMENTS_FIELDS_LIMIT_REACHED: 'document_fields_limit_reached',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_document_id */
    MISSING_DOCUMENT_ID: 'missing_document_id',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_document_id */
    INVALID_DOCUMENT_ID: 'invalid_document_id',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_content_type */
    INVALID_CONTENT_TYPE: 'invalid_content_type',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_content_type */
    MISSING_CONTENT_TYPE: 'missing_content_type',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_document_fields */
    INVALID_DOCUMENT_FIELDS: 'invalid_document_fields',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_document_limit */
    INVALID_DOCUMENT_LIMIT: 'invalid_document_limit',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_document_offset */
    INVALID_DOCUMENT_OFFSET: 'invalid_document_offset',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_document_filter */
    INVALID_DOCUMENT_FILTER: 'invalid_document_filter',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_document_filter */
    MISSING_DOCUMENT_FILTER: 'missing_document_filter',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_document_vectors_field */
    INVALID_DOCUMENT_VECTORS_FIELD: 'invalid_document_vectors_field',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#payload_too_large */
    PAYLOAD_TOO_LARGE: 'payload_too_large',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_payload */
    MISSING_PAYLOAD: 'missing_payload',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#malformed_payload */
    MALFORMED_PAYLOAD: 'malformed_payload',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#no_space_left_on_device */
    NO_SPACE_LEFT_ON_DEVICE: 'no_space_left_on_device',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_store_file */
    INVALID_STORE_FILE: 'invalid_store_file',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_ranking_rules */
    INVALID_RANKING_RULES: 'missing_document_id',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_request */
    INVALID_REQUEST: 'invalid_request',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_document_geo_field */
    INVALID_DOCUMENT_GEO_FIELD: 'invalid_document_geo_field',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_q */
    INVALID_SEARCH_Q: 'invalid_search_q',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_offset */
    INVALID_SEARCH_OFFSET: 'invalid_search_offset',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_limit */
    INVALID_SEARCH_LIMIT: 'invalid_search_limit',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_page */
    INVALID_SEARCH_PAGE: 'invalid_search_page',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_hits_per_page */
    INVALID_SEARCH_HITS_PER_PAGE: 'invalid_search_hits_per_page',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_attributes_to_retrieve */
    INVALID_SEARCH_ATTRIBUTES_TO_RETRIEVE: 'invalid_search_attributes_to_retrieve',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_attributes_to_crop */
    INVALID_SEARCH_ATTRIBUTES_TO_CROP: 'invalid_search_attributes_to_crop',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_crop_length */
    INVALID_SEARCH_CROP_LENGTH: 'invalid_search_crop_length',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_attributes_to_highlight */
    INVALID_SEARCH_ATTRIBUTES_TO_HIGHLIGHT: 'invalid_search_attributes_to_highlight',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_show_matches_position */
    INVALID_SEARCH_SHOW_MATCHES_POSITION: 'invalid_search_show_matches_position',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_filter */
    INVALID_SEARCH_FILTER: 'invalid_search_filter',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_sort */
    INVALID_SEARCH_SORT: 'invalid_search_sort',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_facets */
    INVALID_SEARCH_FACETS: 'invalid_search_facets',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_highlight_pre_tag */
    INVALID_SEARCH_HIGHLIGHT_PRE_TAG: 'invalid_search_highlight_pre_tag',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_highlight_post_tag */
    INVALID_SEARCH_HIGHLIGHT_POST_TAG: 'invalid_search_highlight_post_tag',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_crop_marker */
    INVALID_SEARCH_CROP_MARKER: 'invalid_search_crop_marker',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_matching_strategy */
    INVALID_SEARCH_MATCHING_STRATEGY: 'invalid_search_matching_strategy',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_vector */
    INVALID_SEARCH_VECTOR: 'invalid_search_vector',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_attributes_to_search_on */
    INVALID_SEARCH_ATTRIBUTES_TO_SEARCH_ON: 'invalid_search_attributes_to_search_on',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#bad_request */
    BAD_REQUEST: 'bad_request',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#document_not_found */
    DOCUMENT_NOT_FOUND: 'document_not_found',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#internal */
    INTERNAL: 'internal',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_api_key */
    INVALID_API_KEY: 'invalid_api_key',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_api_key_description */
    INVALID_API_KEY_DESCRIPTION: 'invalid_api_key_description',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_api_key_actions */
    INVALID_API_KEY_ACTIONS: 'invalid_api_key_actions',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_api_key_indexes */
    INVALID_API_KEY_INDEXES: 'invalid_api_key_indexes',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_api_key_expires_at */
    INVALID_API_KEY_EXPIRES_AT: 'invalid_api_key_expires_at',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#api_key_not_found */
    API_KEY_NOT_FOUND: 'api_key_not_found',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#immutable_api_key_uid */
    IMMUTABLE_API_KEY_UID: 'immutable_api_key_uid',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#immutable_api_key_actions */
    IMMUTABLE_API_KEY_ACTIONS: 'immutable_api_key_actions',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#immutable_api_key_indexes */
    IMMUTABLE_API_KEY_INDEXES: 'immutable_api_key_indexes',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#immutable_api_key_expires_at */
    IMMUTABLE_API_KEY_EXPIRES_AT: 'immutable_api_key_expires_at',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#immutable_api_key_created_at */
    IMMUTABLE_API_KEY_CREATED_AT: 'immutable_api_key_created_at',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#immutable_api_key_updated_at */
    IMMUTABLE_API_KEY_UPDATED_AT: 'immutable_api_key_updated_at',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_authorization_header */
    MISSING_AUTHORIZATION_HEADER: 'missing_authorization_header',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#unretrievable_document */
    UNRETRIEVABLE_DOCUMENT: 'unretrievable_document',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#database_size_limit_reached */
    MAX_DATABASE_SIZE_LIMIT_REACHED: 'database_size_limit_reached',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#task_not_found */
    TASK_NOT_FOUND: 'task_not_found',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#dump_process_failed */
    DUMP_PROCESS_FAILED: 'dump_process_failed',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#dump_not_found */
    DUMP_NOT_FOUND: 'dump_not_found',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_swap_duplicate_index_found */
    INVALID_SWAP_DUPLICATE_INDEX_FOUND: 'invalid_swap_duplicate_index_found',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_swap_indexes */
    INVALID_SWAP_INDEXES: 'invalid_swap_indexes',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_swap_indexes */
    MISSING_SWAP_INDEXES: 'missing_swap_indexes',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_master_key */
    MISSING_MASTER_KEY: 'missing_master_key',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_types */
    INVALID_TASK_TYPES: 'invalid_task_types',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_uids */
    INVALID_TASK_UIDS: 'invalid_task_uids',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_statuses */
    INVALID_TASK_STATUSES: 'invalid_task_statuses',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_limit */
    INVALID_TASK_LIMIT: 'invalid_task_limit',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_from */
    INVALID_TASK_FROM: 'invalid_task_from',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_canceled_by */
    INVALID_TASK_CANCELED_BY: 'invalid_task_canceled_by',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_task_filters */
    MISSING_TASK_FILTERS: 'missing_task_filters',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#too_many_open_files */
    TOO_MANY_OPEN_FILES: 'too_many_open_files',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#io_error */
    IO_ERROR: 'io_error',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_index_uids */
    INVALID_TASK_INDEX_UIDS: 'invalid_task_index_uids',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#immutable_index_uid */
    IMMUTABLE_INDEX_UID: 'immutable_index_uid',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#immutable_index_created_at */
    IMMUTABLE_INDEX_CREATED_AT: 'immutable_index_created_at',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#immutable_index_updated_at */
    IMMUTABLE_INDEX_UPDATED_AT: 'immutable_index_updated_at',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_displayed_attributes */
    INVALID_SETTINGS_DISPLAYED_ATTRIBUTES: 'invalid_settings_displayed_attributes',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_searchable_attributes */
    INVALID_SETTINGS_SEARCHABLE_ATTRIBUTES: 'invalid_settings_searchable_attributes',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_filterable_attributes */
    INVALID_SETTINGS_FILTERABLE_ATTRIBUTES: 'invalid_settings_filterable_attributes',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_sortable_attributes */
    INVALID_SETTINGS_SORTABLE_ATTRIBUTES: 'invalid_settings_sortable_attributes',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_ranking_rules */
    INVALID_SETTINGS_RANKING_RULES: 'invalid_settings_ranking_rules',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_stop_words */
    INVALID_SETTINGS_STOP_WORDS: 'invalid_settings_stop_words',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_synonyms */
    INVALID_SETTINGS_SYNONYMS: 'invalid_settings_synonyms',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_distinct_attribute */
    INVALID_SETTINGS_DISTINCT_ATTRIBUTE: 'invalid_settings_distinct_attribute',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_typo_tolerance */
    INVALID_SETTINGS_TYPO_TOLERANCE: 'invalid_settings_typo_tolerance',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_faceting */
    INVALID_SETTINGS_FACETING: 'invalid_settings_faceting',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_pagination */
    INVALID_SETTINGS_PAGINATION: 'invalid_settings_pagination',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_before_enqueued_at */
    INVALID_TASK_BEFORE_ENQUEUED_AT: 'invalid_task_before_enqueued_at',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_after_enqueued_at */
    INVALID_TASK_AFTER_ENQUEUED_AT: 'invalid_task_after_enqueued_at',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_before_started_at */
    INVALID_TASK_BEFORE_STARTED_AT: 'invalid_task_before_started_at',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_after_started_at */
    INVALID_TASK_AFTER_STARTED_AT: 'invalid_task_after_started_at',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_before_finished_at */
    INVALID_TASK_BEFORE_FINISHED_AT: 'invalid_task_before_finished_at',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_after_finished_at */
    INVALID_TASK_AFTER_FINISHED_AT: 'invalid_task_after_finished_at',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_api_key_actions */
    MISSING_API_KEY_ACTIONS: 'missing_api_key_actions',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_api_key_indexes */
    MISSING_API_KEY_INDEXES: 'missing_api_key_indexes',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_api_key_expires_at */
    MISSING_API_KEY_EXPIRES_AT: 'missing_api_key_expires_at',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_api_key_limit */
    INVALID_API_KEY_LIMIT: 'invalid_api_key_limit',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_api_key_offset */
    INVALID_API_KEY_OFFSET: 'invalid_api_key_offset',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_facet_search_facet_name */
    INVALID_FACET_SEARCH_FACET_NAME: 'invalid_facet_search_facet_name',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_facet_search_facet_name */
    MISSING_FACET_SEARCH_FACET_NAME: 'missing_facet_search_facet_name',
    /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_facet_search_facet_query */
    INVALID_FACET_SEARCH_FACET_QUERY: 'invalid_facet_search_facet_query'
  };

  function _iterableToArrayLimit(r, l) {
    var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (null != t) {
      var e,
        n,
        i,
        u,
        a = [],
        f = !0,
        o = !1;
      try {
        if (i = (t = t.call(r)).next, 0 === l) {
          if (Object(t) !== t) return;
          f = !1;
        } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
      } catch (r) {
        o = !0, n = r;
      } finally {
        try {
          if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
        } finally {
          if (o) throw n;
        }
      }
      return a;
    }
  }
  function _regeneratorRuntime() {
    _regeneratorRuntime = function () {
      return e;
    };
    var t,
      e = {},
      r = Object.prototype,
      n = r.hasOwnProperty,
      o = Object.defineProperty || function (t, e, r) {
        t[e] = r.value;
      },
      i = "function" == typeof Symbol ? Symbol : {},
      a = i.iterator || "@@iterator",
      c = i.asyncIterator || "@@asyncIterator",
      u = i.toStringTag || "@@toStringTag";
    function define(t, e, r) {
      return Object.defineProperty(t, e, {
        value: r,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }), t[e];
    }
    try {
      define({}, "");
    } catch (t) {
      define = function (t, e, r) {
        return t[e] = r;
      };
    }
    function wrap(t, e, r, n) {
      var i = e && e.prototype instanceof Generator ? e : Generator,
        a = Object.create(i.prototype),
        c = new Context(n || []);
      return o(a, "_invoke", {
        value: makeInvokeMethod(t, r, c)
      }), a;
    }
    function tryCatch(t, e, r) {
      try {
        return {
          type: "normal",
          arg: t.call(e, r)
        };
      } catch (t) {
        return {
          type: "throw",
          arg: t
        };
      }
    }
    e.wrap = wrap;
    var h = "suspendedStart",
      l = "suspendedYield",
      f = "executing",
      s = "completed",
      y = {};
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}
    var p = {};
    define(p, a, function () {
      return this;
    });
    var d = Object.getPrototypeOf,
      v = d && d(d(values([])));
    v && v !== r && n.call(v, a) && (p = v);
    var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
    function defineIteratorMethods(t) {
      ["next", "throw", "return"].forEach(function (e) {
        define(t, e, function (t) {
          return this._invoke(e, t);
        });
      });
    }
    function AsyncIterator(t, e) {
      function invoke(r, o, i, a) {
        var c = tryCatch(t[r], t, o);
        if ("throw" !== c.type) {
          var u = c.arg,
            h = u.value;
          return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
            invoke("next", t, i, a);
          }, function (t) {
            invoke("throw", t, i, a);
          }) : e.resolve(h).then(function (t) {
            u.value = t, i(u);
          }, function (t) {
            return invoke("throw", t, i, a);
          });
        }
        a(c.arg);
      }
      var r;
      o(this, "_invoke", {
        value: function (t, n) {
          function callInvokeWithMethodAndArg() {
            return new e(function (e, r) {
              invoke(t, n, e, r);
            });
          }
          return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
      });
    }
    function makeInvokeMethod(e, r, n) {
      var o = h;
      return function (i, a) {
        if (o === f) throw new Error("Generator is already running");
        if (o === s) {
          if ("throw" === i) throw a;
          return {
            value: t,
            done: !0
          };
        }
        for (n.method = i, n.arg = a;;) {
          var c = n.delegate;
          if (c) {
            var u = maybeInvokeDelegate(c, n);
            if (u) {
              if (u === y) continue;
              return u;
            }
          }
          if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
            if (o === h) throw o = s, n.arg;
            n.dispatchException(n.arg);
          } else "return" === n.method && n.abrupt("return", n.arg);
          o = f;
          var p = tryCatch(e, r, n);
          if ("normal" === p.type) {
            if (o = n.done ? s : l, p.arg === y) continue;
            return {
              value: p.arg,
              done: n.done
            };
          }
          "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
        }
      };
    }
    function maybeInvokeDelegate(e, r) {
      var n = r.method,
        o = e.iterator[n];
      if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
      var i = tryCatch(o, e.iterator, r.arg);
      if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
      var a = i.arg;
      return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
    }
    function pushTryEntry(t) {
      var e = {
        tryLoc: t[0]
      };
      1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
    }
    function resetTryEntry(t) {
      var e = t.completion || {};
      e.type = "normal", delete e.arg, t.completion = e;
    }
    function Context(t) {
      this.tryEntries = [{
        tryLoc: "root"
      }], t.forEach(pushTryEntry, this), this.reset(!0);
    }
    function values(e) {
      if (e || "" === e) {
        var r = e[a];
        if (r) return r.call(e);
        if ("function" == typeof e.next) return e;
        if (!isNaN(e.length)) {
          var o = -1,
            i = function next() {
              for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
              return next.value = t, next.done = !0, next;
            };
          return i.next = i;
        }
      }
      throw new TypeError(typeof e + " is not iterable");
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
      value: GeneratorFunctionPrototype,
      configurable: !0
    }), o(GeneratorFunctionPrototype, "constructor", {
      value: GeneratorFunction,
      configurable: !0
    }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
      var e = "function" == typeof t && t.constructor;
      return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
    }, e.mark = function (t) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
    }, e.awrap = function (t) {
      return {
        __await: t
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
      return this;
    }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
      void 0 === i && (i = Promise);
      var a = new AsyncIterator(wrap(t, r, n, o), i);
      return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
        return t.done ? t.value : a.next();
      });
    }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
      return this;
    }), define(g, "toString", function () {
      return "[object Generator]";
    }), e.keys = function (t) {
      var e = Object(t),
        r = [];
      for (var n in e) r.push(n);
      return r.reverse(), function next() {
        for (; r.length;) {
          var t = r.pop();
          if (t in e) return next.value = t, next.done = !1, next;
        }
        return next.done = !0, next;
      };
    }, e.values = values, Context.prototype = {
      constructor: Context,
      reset: function (e) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
      },
      stop: function () {
        this.done = !0;
        var t = this.tryEntries[0].completion;
        if ("throw" === t.type) throw t.arg;
        return this.rval;
      },
      dispatchException: function (e) {
        if (this.done) throw e;
        var r = this;
        function handle(n, o) {
          return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
        }
        for (var o = this.tryEntries.length - 1; o >= 0; --o) {
          var i = this.tryEntries[o],
            a = i.completion;
          if ("root" === i.tryLoc) return handle("end");
          if (i.tryLoc <= this.prev) {
            var c = n.call(i, "catchLoc"),
              u = n.call(i, "finallyLoc");
            if (c && u) {
              if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
              if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
            } else if (c) {
              if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            } else {
              if (!u) throw new Error("try statement without catch or finally");
              if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
            }
          }
        }
      },
      abrupt: function (t, e) {
        for (var r = this.tryEntries.length - 1; r >= 0; --r) {
          var o = this.tryEntries[r];
          if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
            var i = o;
            break;
          }
        }
        i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
        var a = i ? i.completion : {};
        return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
      },
      complete: function (t, e) {
        if ("throw" === t.type) throw t.arg;
        return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
      },
      finish: function (t) {
        for (var e = this.tryEntries.length - 1; e >= 0; --e) {
          var r = this.tryEntries[e];
          if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
        }
      },
      catch: function (t) {
        for (var e = this.tryEntries.length - 1; e >= 0; --e) {
          var r = this.tryEntries[e];
          if (r.tryLoc === t) {
            var n = r.completion;
            if ("throw" === n.type) {
              var o = n.arg;
              resetTryEntry(r);
            }
            return o;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function (e, r, n) {
        return this.delegate = {
          iterator: values(e),
          resultName: r,
          nextLoc: n
        }, "next" === this.method && (this.arg = t), y;
      }
    }, e;
  }
  function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : String(i);
  }
  function _typeof(o) {
    "@babel/helpers - typeof";

    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
      return typeof o;
    } : function (o) {
      return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", {
      writable: false
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }
  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }
  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct.bind();
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }
    return _construct.apply(null, arguments);
  }
  function _isNativeFunction(fn) {
    try {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    } catch (e) {
      return typeof fn === "function";
    }
  }
  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;
    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;
      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }
      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);
        _cache.set(Class, Wrapper);
      }
      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }
      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };
    return _wrapNativeSuper(Class);
  }
  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
  }
  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }
    return _assertThisInitialized(self);
  }
  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        var F = function () {};
        return {
          s: F,
          n: function () {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          },
          e: function (e) {
            throw e;
          },
          f: F
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true,
      didErr = false,
      err;
    return {
      s: function () {
        it = it.call(o);
      },
      n: function () {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function (e) {
        didErr = true;
        err = e;
      },
      f: function () {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }

  /******************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */

  function __awaiter(thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  }

  var MeiliSearchError = /*#__PURE__*/function (_Error) {
    _inherits(MeiliSearchError, _Error);
    var _super = _createSuper(MeiliSearchError);
    function MeiliSearchError(message) {
      var _this;
      _classCallCheck(this, MeiliSearchError);
      _this = _super.call(this, message);
      // Make errors comparison possible. ex: error instanceof MeiliSearchError.
      Object.setPrototypeOf(_assertThisInitialized(_this), MeiliSearchError.prototype);
      _this.name = 'MeiliSearchError';
      if (Error.captureStackTrace) {
        Error.captureStackTrace(_assertThisInitialized(_this), MeiliSearchError);
      }
      return _this;
    }
    return _createClass(MeiliSearchError);
  }( /*#__PURE__*/_wrapNativeSuper(Error));

  var MeiliSearchCommunicationError = /*#__PURE__*/function (_MeiliSearchError) {
    _inherits(MeiliSearchCommunicationError, _MeiliSearchError);
    var _super = _createSuper(MeiliSearchCommunicationError);
    function MeiliSearchCommunicationError(message, body, url, stack) {
      var _this;
      _classCallCheck(this, MeiliSearchCommunicationError);
      var _a, _b, _c;
      _this = _super.call(this, message);
      // Make errors comparison possible. ex: error instanceof MeiliSearchCommunicationError.
      Object.setPrototypeOf(_assertThisInitialized(_this), MeiliSearchCommunicationError.prototype);
      _this.name = 'MeiliSearchCommunicationError';
      if (body instanceof Response) {
        _this.message = body.statusText;
        _this.statusCode = body.status;
      }
      if (body instanceof Error) {
        _this.errno = body.errno;
        _this.code = body.code;
      }
      if (stack) {
        _this.stack = stack;
        _this.stack = (_a = _this.stack) === null || _a === void 0 ? void 0 : _a.replace(/(TypeError|FetchError)/, _this.name);
        _this.stack = (_b = _this.stack) === null || _b === void 0 ? void 0 : _b.replace('Failed to fetch', "request to ".concat(url, " failed, reason: connect ECONNREFUSED"));
        _this.stack = (_c = _this.stack) === null || _c === void 0 ? void 0 : _c.replace('Not Found', "Not Found: ".concat(url));
      } else {
        if (Error.captureStackTrace) {
          Error.captureStackTrace(_assertThisInitialized(_this), MeiliSearchCommunicationError);
        }
      }
      return _this;
    }
    return _createClass(MeiliSearchCommunicationError);
  }(MeiliSearchError);

  var MeiliSearchApiError = /*#__PURE__*/function (_MeiliSearchError) {
    _inherits(MeiliSearchApiError, _MeiliSearchError);
    var _super = _createSuper(MeiliSearchApiError);
    function MeiliSearchApiError(error, status) {
      var _this;
      _classCallCheck(this, MeiliSearchApiError);
      _this = _super.call(this, error.message);
      // Make errors comparison possible. ex: error instanceof MeiliSearchApiError.
      Object.setPrototypeOf(_assertThisInitialized(_this), MeiliSearchApiError.prototype);
      _this.name = 'MeiliSearchApiError';
      _this.code = error.code;
      _this.type = error.type;
      _this.link = error.link;
      _this.message = error.message;
      _this.httpStatus = status;
      if (Error.captureStackTrace) {
        Error.captureStackTrace(_assertThisInitialized(_this), MeiliSearchApiError);
      }
      return _this;
    }
    return _createClass(MeiliSearchApiError);
  }(MeiliSearchError);

  function httpResponseErrorHandler(response) {
    return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var responseBody;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            if (response.ok) {
              _context.next = 11;
              break;
            }
            _context.prev = 1;
            _context.next = 4;
            return response.json();
          case 4:
            responseBody = _context.sent;
            _context.next = 10;
            break;
          case 7:
            _context.prev = 7;
            _context.t0 = _context["catch"](1);
            throw new MeiliSearchCommunicationError(response.statusText, response, response.url);
          case 10:
            throw new MeiliSearchApiError(responseBody, response.status);
          case 11:
            return _context.abrupt("return", response);
          case 12:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[1, 7]]);
    }));
  }
  function httpErrorHandler(response, stack, url) {
    if (response.name !== 'MeiliSearchApiError') {
      throw new MeiliSearchCommunicationError(response.message, response, url, stack);
    }
    throw response;
  }

  var MeiliSearchTimeOutError = /*#__PURE__*/function (_MeiliSearchError) {
    _inherits(MeiliSearchTimeOutError, _MeiliSearchError);
    var _super = _createSuper(MeiliSearchTimeOutError);
    function MeiliSearchTimeOutError(message) {
      var _this;
      _classCallCheck(this, MeiliSearchTimeOutError);
      _this = _super.call(this, message);
      // Make errors comparison possible. ex: error instanceof MeiliSearchTimeOutError.
      Object.setPrototypeOf(_assertThisInitialized(_this), MeiliSearchTimeOutError.prototype);
      _this.name = 'MeiliSearchTimeOutError';
      if (Error.captureStackTrace) {
        Error.captureStackTrace(_assertThisInitialized(_this), MeiliSearchTimeOutError);
      }
      return _this;
    }
    return _createClass(MeiliSearchTimeOutError);
  }(MeiliSearchError);

  function versionErrorHintMessage(message, method) {
    return "".concat(message, "\nHint: It might not be working because maybe you're not up to date with the Meilisearch version that ").concat(method, " call requires.");
  }

  /** Removes undefined entries from object */
  function removeUndefinedFromObject(obj) {
    return Object.entries(obj).reduce(function (acc, curEntry) {
      var _curEntry = _slicedToArray(curEntry, 2),
        key = _curEntry[0],
        val = _curEntry[1];
      if (val !== undefined) acc[key] = val;
      return acc;
    }, {});
  }
  function sleep(ms) {
    return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return new Promise(function (resolve) {
              return setTimeout(resolve, ms);
            });
          case 2:
            return _context.abrupt("return", _context.sent);
          case 3:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
  }
  function addProtocolIfNotPresent(host) {
    if (!(host.startsWith('https://') || host.startsWith('http://'))) {
      return "http://".concat(host);
    }
    return host;
  }
  function addTrailingSlash(url) {
    if (!url.endsWith('/')) {
      url += '/';
    }
    return url;
  }

  var PACKAGE_VERSION = '0.38.0';

  function toQueryParams(parameters) {
    var params = Object.keys(parameters);
    var queryParams = params.reduce(function (acc, key) {
      var value = parameters[key];
      if (value === undefined) {
        return acc;
      } else if (Array.isArray(value)) {
        return Object.assign(Object.assign({}, acc), _defineProperty({}, key, value.join(',')));
      } else if (value instanceof Date) {
        return Object.assign(Object.assign({}, acc), _defineProperty({}, key, value.toISOString()));
      }
      return Object.assign(Object.assign({}, acc), _defineProperty({}, key, value));
    }, {});
    return queryParams;
  }
  function constructHostURL(host) {
    try {
      host = addProtocolIfNotPresent(host);
      host = addTrailingSlash(host);
      return host;
    } catch (e) {
      throw new MeiliSearchError('The provided host is not valid.');
    }
  }
  function cloneAndParseHeaders(headers) {
    if (Array.isArray(headers)) {
      return headers.reduce(function (acc, headerPair) {
        acc[headerPair[0]] = headerPair[1];
        return acc;
      }, {});
    } else if ('has' in headers) {
      var clonedHeaders = {};
      headers.forEach(function (value, key) {
        return clonedHeaders[key] = value;
      });
      return clonedHeaders;
    } else {
      return Object.assign({}, headers);
    }
  }
  function createHeaders(config) {
    var _a, _b;
    var agentHeader = 'X-Meilisearch-Client';
    var packageAgent = "Meilisearch JavaScript (v".concat(PACKAGE_VERSION, ")");
    var contentType = 'Content-Type';
    var authorization = 'Authorization';
    var headers = cloneAndParseHeaders((_b = (_a = config.requestConfig) === null || _a === void 0 ? void 0 : _a.headers) !== null && _b !== void 0 ? _b : {});
    // do not override if user provided the header
    if (config.apiKey && !headers[authorization]) {
      headers[authorization] = "Bearer ".concat(config.apiKey);
    }
    if (!headers[contentType]) {
      headers['Content-Type'] = 'application/json';
    }
    // Creates the custom user agent with information on the package used.
    if (config.clientAgents && Array.isArray(config.clientAgents)) {
      var clients = config.clientAgents.concat(packageAgent);
      headers[agentHeader] = clients.join(' ; ');
    } else if (config.clientAgents && !Array.isArray(config.clientAgents)) {
      // If the header is defined but not an array
      throw new MeiliSearchError("Meilisearch: The header \"".concat(agentHeader, "\" should be an array of string(s).\n"));
    } else {
      headers[agentHeader] = packageAgent;
    }
    return headers;
  }
  var HttpRequests = /*#__PURE__*/function () {
    function HttpRequests(config) {
      _classCallCheck(this, HttpRequests);
      this.headers = createHeaders(config);
      this.requestConfig = config.requestConfig;
      this.httpClient = config.httpClient;
      this.requestTimeout = config.timeout;
      try {
        var host = constructHostURL(config.host);
        this.url = new URL(host);
      } catch (e) {
        throw new MeiliSearchError('The provided host is not valid.');
      }
    }
    _createClass(HttpRequests, [{
      key: "request",
      value: function request(_ref) {
        var method = _ref.method,
          url = _ref.url,
          params = _ref.params,
          body = _ref.body,
          _ref$config = _ref.config,
          config = _ref$config === void 0 ? {} : _ref$config;
        var _a;
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
          var constructURL, queryParams, headers, result, response, parsedBody, stack;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                if (typeof fetch === 'undefined') {
                  __webpack_require__(416);
                }
                constructURL = new URL(url, this.url);
                if (params) {
                  queryParams = new URLSearchParams();
                  Object.keys(params).filter(function (x) {
                    return params[x] !== null;
                  }).map(function (x) {
                    return queryParams.set(x, params[x]);
                  });
                  constructURL.search = queryParams.toString();
                }
                // in case a custom content-type is provided
                // do not stringify body
                if (!((_a = config.headers) === null || _a === void 0 ? void 0 : _a['Content-Type'])) {
                  body = JSON.stringify(body);
                }
                headers = Object.assign(Object.assign({}, this.headers), config.headers);
                _context.prev = 5;
                result = this.fetchWithTimeout(constructURL.toString(), Object.assign(Object.assign(Object.assign({}, config), this.requestConfig), {
                  method: method,
                  body: body,
                  headers: headers
                }), this.requestTimeout); // When using a custom HTTP client, the response is returned to allow the user to parse/handle it as they see fit
                if (!this.httpClient) {
                  _context.next = 11;
                  break;
                }
                _context.next = 10;
                return result;
              case 10:
                return _context.abrupt("return", _context.sent);
              case 11:
                _context.next = 13;
                return result.then(function (res) {
                  return httpResponseErrorHandler(res);
                });
              case 13:
                response = _context.sent;
                _context.next = 16;
                return response.json().catch(function () {
                  return undefined;
                });
              case 16:
                parsedBody = _context.sent;
                return _context.abrupt("return", parsedBody);
              case 20:
                _context.prev = 20;
                _context.t0 = _context["catch"](5);
                stack = _context.t0.stack;
                httpErrorHandler(_context.t0, stack, constructURL.toString());
              case 24:
              case "end":
                return _context.stop();
            }
          }, _callee, this, [[5, 20]]);
        }));
      }
    }, {
      key: "fetchWithTimeout",
      value: function fetchWithTimeout(url, options, timeout) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
          var _this = this;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", new Promise(function (resolve, reject) {
                  var fetchFn = _this.httpClient ? _this.httpClient : fetch;
                  var fetchPromise = fetchFn(url, options);
                  var promises = [fetchPromise];
                  // TimeoutPromise will not run if undefined or zero
                  var timeoutId;
                  if (timeout) {
                    var timeoutPromise = new Promise(function (_, reject) {
                      timeoutId = setTimeout(function () {
                        reject(new Error('Error: Request Timed Out'));
                      }, timeout);
                    });
                    promises.push(timeoutPromise);
                  }
                  Promise.race(promises).then(resolve).catch(reject).finally(function () {
                    clearTimeout(timeoutId);
                  });
                }));
              case 1:
              case "end":
                return _context2.stop();
            }
          }, _callee2);
        }));
      }
    }, {
      key: "get",
      value: function get(url, params, config) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.request({
                  method: 'GET',
                  url: url,
                  params: params,
                  config: config
                });
              case 2:
                return _context3.abrupt("return", _context3.sent);
              case 3:
              case "end":
                return _context3.stop();
            }
          }, _callee3, this);
        }));
      }
    }, {
      key: "post",
      value: function post(url, data, params, config) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
          return _regeneratorRuntime().wrap(function _callee4$(_context4) {
            while (1) switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.request({
                  method: 'POST',
                  url: url,
                  body: data,
                  params: params,
                  config: config
                });
              case 2:
                return _context4.abrupt("return", _context4.sent);
              case 3:
              case "end":
                return _context4.stop();
            }
          }, _callee4, this);
        }));
      }
    }, {
      key: "put",
      value: function put(url, data, params, config) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
          return _regeneratorRuntime().wrap(function _callee5$(_context5) {
            while (1) switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.request({
                  method: 'PUT',
                  url: url,
                  body: data,
                  params: params,
                  config: config
                });
              case 2:
                return _context5.abrupt("return", _context5.sent);
              case 3:
              case "end":
                return _context5.stop();
            }
          }, _callee5, this);
        }));
      }
    }, {
      key: "patch",
      value: function patch(url, data, params, config) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
          return _regeneratorRuntime().wrap(function _callee6$(_context6) {
            while (1) switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.request({
                  method: 'PATCH',
                  url: url,
                  body: data,
                  params: params,
                  config: config
                });
              case 2:
                return _context6.abrupt("return", _context6.sent);
              case 3:
              case "end":
                return _context6.stop();
            }
          }, _callee6, this);
        }));
      }
    }, {
      key: "delete",
      value: function _delete(url, data, params, config) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
          return _regeneratorRuntime().wrap(function _callee7$(_context7) {
            while (1) switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this.request({
                  method: 'DELETE',
                  url: url,
                  body: data,
                  params: params,
                  config: config
                });
              case 2:
                return _context7.abrupt("return", _context7.sent);
              case 3:
              case "end":
                return _context7.stop();
            }
          }, _callee7, this);
        }));
      }
    }]);
    return HttpRequests;
  }();

  var EnqueuedTask = /*#__PURE__*/_createClass(function EnqueuedTask(task) {
    _classCallCheck(this, EnqueuedTask);
    this.taskUid = task.taskUid;
    this.indexUid = task.indexUid;
    this.status = task.status;
    this.type = task.type;
    this.enqueuedAt = new Date(task.enqueuedAt);
  });

  var Task = /*#__PURE__*/_createClass(function Task(task) {
    _classCallCheck(this, Task);
    this.indexUid = task.indexUid;
    this.status = task.status;
    this.type = task.type;
    this.uid = task.uid;
    this.details = task.details;
    this.canceledBy = task.canceledBy;
    this.error = task.error;
    this.duration = task.duration;
    this.startedAt = new Date(task.startedAt);
    this.enqueuedAt = new Date(task.enqueuedAt);
    this.finishedAt = new Date(task.finishedAt);
  });
  var TaskClient = /*#__PURE__*/function () {
    function TaskClient(config) {
      _classCallCheck(this, TaskClient);
      this.httpRequest = new HttpRequests(config);
    }
    /**
     * Get one task
     *
     * @param uid - Unique identifier of the task
     * @returns
     */
    _createClass(TaskClient, [{
      key: "getTask",
      value: function getTask(uid) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
          var url, taskItem;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                url = "tasks/".concat(uid);
                _context.next = 3;
                return this.httpRequest.get(url);
              case 3:
                taskItem = _context.sent;
                return _context.abrupt("return", new Task(taskItem));
              case 5:
              case "end":
                return _context.stop();
            }
          }, _callee, this);
        }));
      }
      /**
       * Get tasks
       *
       * @param parameters - Parameters to browse the tasks
       * @returns Promise containing all tasks
       */
    }, {
      key: "getTasks",
      value: function getTasks() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
          var url, tasks;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                url = "tasks";
                _context2.next = 3;
                return this.httpRequest.get(url, toQueryParams(parameters));
              case 3:
                tasks = _context2.sent;
                return _context2.abrupt("return", Object.assign(Object.assign({}, tasks), {
                  results: tasks.results.map(function (task) {
                    return new Task(task);
                  })
                }));
              case 5:
              case "end":
                return _context2.stop();
            }
          }, _callee2, this);
        }));
      }
      /**
       * Wait for a task to be processed.
       *
       * @param taskUid - Task identifier
       * @param options - Additional configuration options
       * @returns Promise returning a task after it has been processed
       */
    }, {
      key: "waitForTask",
      value: function waitForTask(taskUid) {
        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref$timeOutMs = _ref.timeOutMs,
          timeOutMs = _ref$timeOutMs === void 0 ? 5000 : _ref$timeOutMs,
          _ref$intervalMs = _ref.intervalMs,
          intervalMs = _ref$intervalMs === void 0 ? 50 : _ref$intervalMs;
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
          var startingTime, response;
          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) switch (_context3.prev = _context3.next) {
              case 0:
                startingTime = Date.now();
              case 1:
                if (!(Date.now() - startingTime < timeOutMs)) {
                  _context3.next = 11;
                  break;
                }
                _context3.next = 4;
                return this.getTask(taskUid);
              case 4:
                response = _context3.sent;
                if ([TaskStatus.TASK_ENQUEUED, TaskStatus.TASK_PROCESSING].includes(response.status)) {
                  _context3.next = 7;
                  break;
                }
                return _context3.abrupt("return", response);
              case 7:
                _context3.next = 9;
                return sleep(intervalMs);
              case 9:
                _context3.next = 1;
                break;
              case 11:
                throw new MeiliSearchTimeOutError("timeout of ".concat(timeOutMs, "ms has exceeded on process ").concat(taskUid, " when waiting a task to be resolved."));
              case 12:
              case "end":
                return _context3.stop();
            }
          }, _callee3, this);
        }));
      }
      /**
       * Waits for multiple tasks to be processed
       *
       * @param taskUids - Tasks identifier list
       * @param options - Wait options
       * @returns Promise returning a list of tasks after they have been processed
       */
    }, {
      key: "waitForTasks",
      value: function waitForTasks(taskUids) {
        var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$timeOutMs = _ref2.timeOutMs,
          timeOutMs = _ref2$timeOutMs === void 0 ? 5000 : _ref2$timeOutMs,
          _ref2$intervalMs = _ref2.intervalMs,
          intervalMs = _ref2$intervalMs === void 0 ? 50 : _ref2$intervalMs;
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
          var tasks, _iterator, _step, taskUid, task;
          return _regeneratorRuntime().wrap(function _callee4$(_context4) {
            while (1) switch (_context4.prev = _context4.next) {
              case 0:
                tasks = [];
                _iterator = _createForOfIteratorHelper(taskUids);
                _context4.prev = 2;
                _iterator.s();
              case 4:
                if ((_step = _iterator.n()).done) {
                  _context4.next = 12;
                  break;
                }
                taskUid = _step.value;
                _context4.next = 8;
                return this.waitForTask(taskUid, {
                  timeOutMs: timeOutMs,
                  intervalMs: intervalMs
                });
              case 8:
                task = _context4.sent;
                tasks.push(task);
              case 10:
                _context4.next = 4;
                break;
              case 12:
                _context4.next = 17;
                break;
              case 14:
                _context4.prev = 14;
                _context4.t0 = _context4["catch"](2);
                _iterator.e(_context4.t0);
              case 17:
                _context4.prev = 17;
                _iterator.f();
                return _context4.finish(17);
              case 20:
                return _context4.abrupt("return", tasks);
              case 21:
              case "end":
                return _context4.stop();
            }
          }, _callee4, this, [[2, 14, 17, 20]]);
        }));
      }
      /**
       * Cancel a list of enqueued or processing tasks.
       *
       * @param parameters - Parameters to filter the tasks.
       * @returns Promise containing an EnqueuedTask
       */
    }, {
      key: "cancelTasks",
      value: function cancelTasks() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee5$(_context5) {
            while (1) switch (_context5.prev = _context5.next) {
              case 0:
                url = "tasks/cancel";
                _context5.next = 3;
                return this.httpRequest.post(url, {}, toQueryParams(parameters));
              case 3:
                task = _context5.sent;
                return _context5.abrupt("return", new EnqueuedTask(task));
              case 5:
              case "end":
                return _context5.stop();
            }
          }, _callee5, this);
        }));
      }
      /**
       * Delete a list tasks.
       *
       * @param parameters - Parameters to filter the tasks.
       * @returns Promise containing an EnqueuedTask
       */
    }, {
      key: "deleteTasks",
      value: function deleteTasks() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee6$(_context6) {
            while (1) switch (_context6.prev = _context6.next) {
              case 0:
                url = "tasks";
                _context6.next = 3;
                return this.httpRequest.delete(url, {}, toQueryParams(parameters));
              case 3:
                task = _context6.sent;
                return _context6.abrupt("return", new EnqueuedTask(task));
              case 5:
              case "end":
                return _context6.stop();
            }
          }, _callee6, this);
        }));
      }
    }]);
    return TaskClient;
  }();

  /*
   * Bundle: MeiliSearch / Indexes
   * Project: MeiliSearch - Javascript API
   * Author: Quentin de Quelen <quentin@meilisearch.com>
   * Copyright: 2019, MeiliSearch
   */
  var Index = /*#__PURE__*/function () {
    /**
     * @param config - Request configuration options
     * @param uid - UID of the index
     * @param primaryKey - Primary Key of the index
     */
    function Index(config, uid, primaryKey) {
      _classCallCheck(this, Index);
      this.uid = uid;
      this.primaryKey = primaryKey;
      this.httpRequest = new HttpRequests(config);
      this.tasks = new TaskClient(config);
    }
    ///
    /// SEARCH
    ///
    /**
     * Search for documents into an index
     *
     * @param query - Query string
     * @param options - Search options
     * @param config - Additional request configuration options
     * @returns Promise containing the search response
     */
    _createClass(Index, [{
      key: "search",
      value: function search(query, options, config) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
          var url;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/search");
                _context.next = 3;
                return this.httpRequest.post(url, removeUndefinedFromObject(Object.assign({
                  q: query
                }, options)), undefined, config);
              case 3:
                return _context.abrupt("return", _context.sent);
              case 4:
              case "end":
                return _context.stop();
            }
          }, _callee, this);
        }));
      }
      /**
       * Search for documents into an index using the GET method
       *
       * @param query - Query string
       * @param options - Search options
       * @param config - Additional request configuration options
       * @returns Promise containing the search response
       */
    }, {
      key: "searchGet",
      value: function searchGet(query, options, config) {
        var _a, _b, _c, _d, _e, _f, _g;
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
          var url, parseFilter, getParams;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/search");
                parseFilter = function parseFilter(filter) {
                  if (typeof filter === 'string') return filter;else if (Array.isArray(filter)) throw new MeiliSearchError('The filter query parameter should be in string format when using searchGet');else return undefined;
                };
                getParams = Object.assign(Object.assign({
                  q: query
                }, options), {
                  filter: parseFilter(options === null || options === void 0 ? void 0 : options.filter),
                  sort: (_a = options === null || options === void 0 ? void 0 : options.sort) === null || _a === void 0 ? void 0 : _a.join(','),
                  facets: (_b = options === null || options === void 0 ? void 0 : options.facets) === null || _b === void 0 ? void 0 : _b.join(','),
                  attributesToRetrieve: (_c = options === null || options === void 0 ? void 0 : options.attributesToRetrieve) === null || _c === void 0 ? void 0 : _c.join(','),
                  attributesToCrop: (_d = options === null || options === void 0 ? void 0 : options.attributesToCrop) === null || _d === void 0 ? void 0 : _d.join(','),
                  attributesToHighlight: (_e = options === null || options === void 0 ? void 0 : options.attributesToHighlight) === null || _e === void 0 ? void 0 : _e.join(','),
                  vector: (_f = options === null || options === void 0 ? void 0 : options.vector) === null || _f === void 0 ? void 0 : _f.join(','),
                  attributesToSearchOn: (_g = options === null || options === void 0 ? void 0 : options.attributesToSearchOn) === null || _g === void 0 ? void 0 : _g.join(',')
                });
                _context2.next = 5;
                return this.httpRequest.get(url, removeUndefinedFromObject(getParams), config);
              case 5:
                return _context2.abrupt("return", _context2.sent);
              case 6:
              case "end":
                return _context2.stop();
            }
          }, _callee2, this);
        }));
      }
      /**
       * Search for facet values
       *
       * @param params - Parameters used to search on the facets
       * @param config - Additional request configuration options
       * @returns Promise containing the search response
       */
    }, {
      key: "searchForFacetValues",
      value: function searchForFacetValues(params, config) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
          var url;
          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) switch (_context3.prev = _context3.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/facet-search");
                _context3.next = 3;
                return this.httpRequest.post(url, removeUndefinedFromObject(params), undefined, config);
              case 3:
                return _context3.abrupt("return", _context3.sent);
              case 4:
              case "end":
                return _context3.stop();
            }
          }, _callee3, this);
        }));
      }
      ///
      /// INDEX
      ///
      /**
       * Get index information.
       *
       * @returns Promise containing index information
       */
    }, {
      key: "getRawInfo",
      value: function getRawInfo() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
          var url, res;
          return _regeneratorRuntime().wrap(function _callee4$(_context4) {
            while (1) switch (_context4.prev = _context4.next) {
              case 0:
                url = "indexes/".concat(this.uid);
                _context4.next = 3;
                return this.httpRequest.get(url);
              case 3:
                res = _context4.sent;
                this.primaryKey = res.primaryKey;
                this.updatedAt = new Date(res.updatedAt);
                this.createdAt = new Date(res.createdAt);
                return _context4.abrupt("return", res);
              case 8:
              case "end":
                return _context4.stop();
            }
          }, _callee4, this);
        }));
      }
      /**
       * Fetch and update Index information.
       *
       * @returns Promise to the current Index object with updated information
       */
    }, {
      key: "fetchInfo",
      value: function fetchInfo() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
          return _regeneratorRuntime().wrap(function _callee5$(_context5) {
            while (1) switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.getRawInfo();
              case 2:
                return _context5.abrupt("return", this);
              case 3:
              case "end":
                return _context5.stop();
            }
          }, _callee5, this);
        }));
      }
      /**
       * Get Primary Key.
       *
       * @returns Promise containing the Primary Key of the index
       */
    }, {
      key: "fetchPrimaryKey",
      value: function fetchPrimaryKey() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
          return _regeneratorRuntime().wrap(function _callee6$(_context6) {
            while (1) switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.getRawInfo();
              case 2:
                this.primaryKey = _context6.sent.primaryKey;
                return _context6.abrupt("return", this.primaryKey);
              case 4:
              case "end":
                return _context6.stop();
            }
          }, _callee6, this);
        }));
      }
      /**
       * Create an index.
       *
       * @param uid - Unique identifier of the Index
       * @param options - Index options
       * @param config - Request configuration options
       * @returns Newly created Index object
       */
    }, {
      key: "update",
      value:
      /**
       * Update an index.
       *
       * @param data - Data to update
       * @returns Promise to the current Index object with updated information
       */
      function update(data) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee7$(_context7) {
            while (1) switch (_context7.prev = _context7.next) {
              case 0:
                url = "indexes/".concat(this.uid);
                _context7.next = 3;
                return this.httpRequest.patch(url, data);
              case 3:
                task = _context7.sent;
                task.enqueuedAt = new Date(task.enqueuedAt);
                return _context7.abrupt("return", task);
              case 6:
              case "end":
                return _context7.stop();
            }
          }, _callee7, this);
        }));
      }
      /**
       * Delete an index.
       *
       * @returns Promise which resolves when index is deleted successfully
       */
    }, {
      key: "delete",
      value: function _delete() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee8$(_context8) {
            while (1) switch (_context8.prev = _context8.next) {
              case 0:
                url = "indexes/".concat(this.uid);
                _context8.next = 3;
                return this.httpRequest.delete(url);
              case 3:
                task = _context8.sent;
                return _context8.abrupt("return", new EnqueuedTask(task));
              case 5:
              case "end":
                return _context8.stop();
            }
          }, _callee8, this);
        }));
      }
      ///
      /// TASKS
      ///
      /**
       * Get the list of all the tasks of the index.
       *
       * @param parameters - Parameters to browse the tasks
       * @returns Promise containing all tasks
       */
    }, {
      key: "getTasks",
      value: function getTasks() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
          return _regeneratorRuntime().wrap(function _callee9$(_context9) {
            while (1) switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this.tasks.getTasks(Object.assign(Object.assign({}, parameters), {
                  indexUids: [this.uid]
                }));
              case 2:
                return _context9.abrupt("return", _context9.sent);
              case 3:
              case "end":
                return _context9.stop();
            }
          }, _callee9, this);
        }));
      }
      /**
       * Get one task of the index.
       *
       * @param taskUid - Task identifier
       * @returns Promise containing a task
       */
    }, {
      key: "getTask",
      value: function getTask(taskUid) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
          return _regeneratorRuntime().wrap(function _callee10$(_context10) {
            while (1) switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this.tasks.getTask(taskUid);
              case 2:
                return _context10.abrupt("return", _context10.sent);
              case 3:
              case "end":
                return _context10.stop();
            }
          }, _callee10, this);
        }));
      }
      /**
       * Wait for multiple tasks to be processed.
       *
       * @param taskUids - Tasks identifier
       * @param waitOptions - Options on timeout and interval
       * @returns Promise containing an array of tasks
       */
    }, {
      key: "waitForTasks",
      value: function waitForTasks(taskUids) {
        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref$timeOutMs = _ref.timeOutMs,
          timeOutMs = _ref$timeOutMs === void 0 ? 5000 : _ref$timeOutMs,
          _ref$intervalMs = _ref.intervalMs,
          intervalMs = _ref$intervalMs === void 0 ? 50 : _ref$intervalMs;
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
          return _regeneratorRuntime().wrap(function _callee11$(_context11) {
            while (1) switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return this.tasks.waitForTasks(taskUids, {
                  timeOutMs: timeOutMs,
                  intervalMs: intervalMs
                });
              case 2:
                return _context11.abrupt("return", _context11.sent);
              case 3:
              case "end":
                return _context11.stop();
            }
          }, _callee11, this);
        }));
      }
      /**
       * Wait for a task to be processed.
       *
       * @param taskUid - Task identifier
       * @param waitOptions - Options on timeout and interval
       * @returns Promise containing an array of tasks
       */
    }, {
      key: "waitForTask",
      value: function waitForTask(taskUid) {
        var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$timeOutMs = _ref2.timeOutMs,
          timeOutMs = _ref2$timeOutMs === void 0 ? 5000 : _ref2$timeOutMs,
          _ref2$intervalMs = _ref2.intervalMs,
          intervalMs = _ref2$intervalMs === void 0 ? 50 : _ref2$intervalMs;
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {
          return _regeneratorRuntime().wrap(function _callee12$(_context12) {
            while (1) switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return this.tasks.waitForTask(taskUid, {
                  timeOutMs: timeOutMs,
                  intervalMs: intervalMs
                });
              case 2:
                return _context12.abrupt("return", _context12.sent);
              case 3:
              case "end":
                return _context12.stop();
            }
          }, _callee12, this);
        }));
      }
      ///
      /// STATS
      ///
      /**
       * Get stats of an index
       *
       * @returns Promise containing object with stats of the index
       */
    }, {
      key: "getStats",
      value: function getStats() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {
          var url;
          return _regeneratorRuntime().wrap(function _callee13$(_context13) {
            while (1) switch (_context13.prev = _context13.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/stats");
                _context13.next = 3;
                return this.httpRequest.get(url);
              case 3:
                return _context13.abrupt("return", _context13.sent);
              case 4:
              case "end":
                return _context13.stop();
            }
          }, _callee13, this);
        }));
      }
      ///
      /// DOCUMENTS
      ///
      /**
       * Get documents of an index.
       *
       * @param parameters - Parameters to browse the documents. Parameters can
       *   contain the `filter` field only available in Meilisearch v1.2 and newer
       * @returns Promise containing the returned documents
       */
    }, {
      key: "getDocuments",
      value: function getDocuments() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var _a;
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {
          var url, _url, fields;
          return _regeneratorRuntime().wrap(function _callee14$(_context14) {
            while (1) switch (_context14.prev = _context14.next) {
              case 0:
                parameters = removeUndefinedFromObject(parameters);
                // In case `filter` is provided, use `POST /documents/fetch`
                if (!(parameters.filter !== undefined)) {
                  _context14.next = 15;
                  break;
                }
                _context14.prev = 2;
                url = "indexes/".concat(this.uid, "/documents/fetch");
                _context14.next = 6;
                return this.httpRequest.post(url, parameters);
              case 6:
                return _context14.abrupt("return", _context14.sent);
              case 9:
                _context14.prev = 9;
                _context14.t0 = _context14["catch"](2);
                if (_context14.t0 instanceof MeiliSearchCommunicationError) {
                  _context14.t0.message = versionErrorHintMessage(_context14.t0.message, 'getDocuments');
                } else if (_context14.t0 instanceof MeiliSearchApiError) {
                  _context14.t0.message = versionErrorHintMessage(_context14.t0.message, 'getDocuments');
                }
                throw _context14.t0;
              case 13:
                _context14.next = 20;
                break;
              case 15:
                _url = "indexes/".concat(this.uid, "/documents"); // Transform fields to query parameter string format
                fields = Array.isArray(parameters === null || parameters === void 0 ? void 0 : parameters.fields) ? {
                  fields: (_a = parameters === null || parameters === void 0 ? void 0 : parameters.fields) === null || _a === void 0 ? void 0 : _a.join(',')
                } : {};
                _context14.next = 19;
                return this.httpRequest.get(_url, Object.assign(Object.assign({}, parameters), fields));
              case 19:
                return _context14.abrupt("return", _context14.sent);
              case 20:
              case "end":
                return _context14.stop();
            }
          }, _callee14, this, [[2, 9]]);
        }));
      }
      /**
       * Get one document
       *
       * @param documentId - Document ID
       * @param parameters - Parameters applied on a document
       * @returns Promise containing Document response
       */
    }, {
      key: "getDocument",
      value: function getDocument(documentId, parameters) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {
          var url, fields;
          return _regeneratorRuntime().wrap(function _callee15$(_context15) {
            while (1) switch (_context15.prev = _context15.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/documents/").concat(documentId);
                fields = function () {
                  var _a;
                  if (Array.isArray(parameters === null || parameters === void 0 ? void 0 : parameters.fields)) {
                    return (_a = parameters === null || parameters === void 0 ? void 0 : parameters.fields) === null || _a === void 0 ? void 0 : _a.join(',');
                  }
                  return undefined;
                }();
                _context15.next = 4;
                return this.httpRequest.get(url, removeUndefinedFromObject(Object.assign(Object.assign({}, parameters), {
                  fields: fields
                })));
              case 4:
                return _context15.abrupt("return", _context15.sent);
              case 5:
              case "end":
                return _context15.stop();
            }
          }, _callee15, this);
        }));
      }
      /**
       * Add or replace multiples documents to an index
       *
       * @param documents - Array of Document objects to add/replace
       * @param options - Options on document addition
       * @returns Promise containing an EnqueuedTask
       */
    }, {
      key: "addDocuments",
      value: function addDocuments(documents, options) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee16$(_context16) {
            while (1) switch (_context16.prev = _context16.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/documents");
                _context16.next = 3;
                return this.httpRequest.post(url, documents, options);
              case 3:
                task = _context16.sent;
                return _context16.abrupt("return", new EnqueuedTask(task));
              case 5:
              case "end":
                return _context16.stop();
            }
          }, _callee16, this);
        }));
      }
      /**
       * Add or replace multiples documents in a string format to an index. It only
       * supports csv, ndjson and json formats.
       *
       * @param documents - Documents provided in a string to add/replace
       * @param contentType - Content type of your document:
       *   'text/csv'|'application/x-ndjson'|'application/json'
       * @param options - Options on document addition
       * @returns Promise containing an EnqueuedTask
       */
    }, {
      key: "addDocumentsFromString",
      value: function addDocumentsFromString(documents, contentType, queryParams) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee17$(_context17) {
            while (1) switch (_context17.prev = _context17.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/documents");
                _context17.next = 3;
                return this.httpRequest.post(url, documents, queryParams, {
                  headers: {
                    'Content-Type': contentType
                  }
                });
              case 3:
                task = _context17.sent;
                return _context17.abrupt("return", new EnqueuedTask(task));
              case 5:
              case "end":
                return _context17.stop();
            }
          }, _callee17, this);
        }));
      }
      /**
       * Add or replace multiples documents to an index in batches
       *
       * @param documents - Array of Document objects to add/replace
       * @param batchSize - Size of the batch
       * @param options - Options on document addition
       * @returns Promise containing array of enqueued task objects for each batch
       */
    }, {
      key: "addDocumentsInBatches",
      value: function addDocumentsInBatches(documents) {
        var batchSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;
        var options = arguments.length > 2 ? arguments[2] : undefined;
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee18() {
          var updates, i;
          return _regeneratorRuntime().wrap(function _callee18$(_context18) {
            while (1) switch (_context18.prev = _context18.next) {
              case 0:
                updates = [];
                i = 0;
              case 2:
                if (!(i < documents.length)) {
                  _context18.next = 11;
                  break;
                }
                _context18.t0 = updates;
                _context18.next = 6;
                return this.addDocuments(documents.slice(i, i + batchSize), options);
              case 6:
                _context18.t1 = _context18.sent;
                _context18.t0.push.call(_context18.t0, _context18.t1);
              case 8:
                i += batchSize;
                _context18.next = 2;
                break;
              case 11:
                return _context18.abrupt("return", updates);
              case 12:
              case "end":
                return _context18.stop();
            }
          }, _callee18, this);
        }));
      }
      /**
       * Add or update multiples documents to an index
       *
       * @param documents - Array of Document objects to add/update
       * @param options - Options on document update
       * @returns Promise containing an EnqueuedTask
       */
    }, {
      key: "updateDocuments",
      value: function updateDocuments(documents, options) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee19() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee19$(_context19) {
            while (1) switch (_context19.prev = _context19.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/documents");
                _context19.next = 3;
                return this.httpRequest.put(url, documents, options);
              case 3:
                task = _context19.sent;
                return _context19.abrupt("return", new EnqueuedTask(task));
              case 5:
              case "end":
                return _context19.stop();
            }
          }, _callee19, this);
        }));
      }
      /**
       * Add or update multiples documents to an index in batches
       *
       * @param documents - Array of Document objects to add/update
       * @param batchSize - Size of the batch
       * @param options - Options on document update
       * @returns Promise containing array of enqueued task objects for each batch
       */
    }, {
      key: "updateDocumentsInBatches",
      value: function updateDocumentsInBatches(documents) {
        var batchSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;
        var options = arguments.length > 2 ? arguments[2] : undefined;
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee20() {
          var updates, i;
          return _regeneratorRuntime().wrap(function _callee20$(_context20) {
            while (1) switch (_context20.prev = _context20.next) {
              case 0:
                updates = [];
                i = 0;
              case 2:
                if (!(i < documents.length)) {
                  _context20.next = 11;
                  break;
                }
                _context20.t0 = updates;
                _context20.next = 6;
                return this.updateDocuments(documents.slice(i, i + batchSize), options);
              case 6:
                _context20.t1 = _context20.sent;
                _context20.t0.push.call(_context20.t0, _context20.t1);
              case 8:
                i += batchSize;
                _context20.next = 2;
                break;
              case 11:
                return _context20.abrupt("return", updates);
              case 12:
              case "end":
                return _context20.stop();
            }
          }, _callee20, this);
        }));
      }
      /**
       * Add or update multiples documents in a string format to an index. It only
       * supports csv, ndjson and json formats.
       *
       * @param documents - Documents provided in a string to add/update
       * @param contentType - Content type of your document:
       *   'text/csv'|'application/x-ndjson'|'application/json'
       * @param queryParams - Options on raw document addition
       * @returns Promise containing an EnqueuedTask
       */
    }, {
      key: "updateDocumentsFromString",
      value: function updateDocumentsFromString(documents, contentType, queryParams) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee21() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee21$(_context21) {
            while (1) switch (_context21.prev = _context21.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/documents");
                _context21.next = 3;
                return this.httpRequest.put(url, documents, queryParams, {
                  headers: {
                    'Content-Type': contentType
                  }
                });
              case 3:
                task = _context21.sent;
                return _context21.abrupt("return", new EnqueuedTask(task));
              case 5:
              case "end":
                return _context21.stop();
            }
          }, _callee21, this);
        }));
      }
      /**
       * Delete one document
       *
       * @param documentId - Id of Document to delete
       * @returns Promise containing an EnqueuedTask
       */
    }, {
      key: "deleteDocument",
      value: function deleteDocument(documentId) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee22() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee22$(_context22) {
            while (1) switch (_context22.prev = _context22.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/documents/").concat(documentId);
                _context22.next = 3;
                return this.httpRequest.delete(url);
              case 3:
                task = _context22.sent;
                task.enqueuedAt = new Date(task.enqueuedAt);
                return _context22.abrupt("return", task);
              case 6:
              case "end":
                return _context22.stop();
            }
          }, _callee22, this);
        }));
      }
      /**
       * Delete multiples documents of an index.
       *
       * @param params - Params value can be:
       *
       *   - DocumentsDeletionQuery: An object containing the parameters to customize
       *       your document deletion. Only available in Meilisearch v1.2 and newer
       *   - DocumentsIds: An array of document ids to delete
       *
       * @returns Promise containing an EnqueuedTask
       */
    }, {
      key: "deleteDocuments",
      value: function deleteDocuments(params) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee23() {
          var isDocumentsDeletionQuery, endpoint, url, task;
          return _regeneratorRuntime().wrap(function _callee23$(_context23) {
            while (1) switch (_context23.prev = _context23.next) {
              case 0:
                // If params is of type DocumentsDeletionQuery
                isDocumentsDeletionQuery = !Array.isArray(params) && _typeof(params) === 'object';
                endpoint = isDocumentsDeletionQuery ? 'documents/delete' : 'documents/delete-batch';
                url = "indexes/".concat(this.uid, "/").concat(endpoint);
                _context23.prev = 3;
                _context23.next = 6;
                return this.httpRequest.post(url, params);
              case 6:
                task = _context23.sent;
                return _context23.abrupt("return", new EnqueuedTask(task));
              case 10:
                _context23.prev = 10;
                _context23.t0 = _context23["catch"](3);
                if (_context23.t0 instanceof MeiliSearchCommunicationError && isDocumentsDeletionQuery) {
                  _context23.t0.message = versionErrorHintMessage(_context23.t0.message, 'deleteDocuments');
                } else if (_context23.t0 instanceof MeiliSearchApiError) {
                  _context23.t0.message = versionErrorHintMessage(_context23.t0.message, 'deleteDocuments');
                }
                throw _context23.t0;
              case 14:
              case "end":
                return _context23.stop();
            }
          }, _callee23, this, [[3, 10]]);
        }));
      }
      /**
       * Delete all documents of an index
       *
       * @returns Promise containing an EnqueuedTask
       */
    }, {
      key: "deleteAllDocuments",
      value: function deleteAllDocuments() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee24() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee24$(_context24) {
            while (1) switch (_context24.prev = _context24.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/documents");
                _context24.next = 3;
                return this.httpRequest.delete(url);
              case 3:
                task = _context24.sent;
                task.enqueuedAt = new Date(task.enqueuedAt);
                return _context24.abrupt("return", task);
              case 6:
              case "end":
                return _context24.stop();
            }
          }, _callee24, this);
        }));
      }
      ///
      /// SETTINGS
      ///
      /**
       * Retrieve all settings
       *
       * @returns Promise containing Settings object
       */
    }, {
      key: "getSettings",
      value: function getSettings() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee25() {
          var url;
          return _regeneratorRuntime().wrap(function _callee25$(_context25) {
            while (1) switch (_context25.prev = _context25.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings");
                _context25.next = 3;
                return this.httpRequest.get(url);
              case 3:
                return _context25.abrupt("return", _context25.sent);
              case 4:
              case "end":
                return _context25.stop();
            }
          }, _callee25, this);
        }));
      }
      /**
       * Update all settings Any parameters not provided will be left unchanged.
       *
       * @param settings - Object containing parameters with their updated values
       * @returns Promise containing an EnqueuedTask
       */
    }, {
      key: "updateSettings",
      value: function updateSettings(settings) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee26() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee26$(_context26) {
            while (1) switch (_context26.prev = _context26.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings");
                _context26.next = 3;
                return this.httpRequest.patch(url, settings);
              case 3:
                task = _context26.sent;
                task.enqueued = new Date(task.enqueuedAt);
                return _context26.abrupt("return", task);
              case 6:
              case "end":
                return _context26.stop();
            }
          }, _callee26, this);
        }));
      }
      /**
       * Reset settings.
       *
       * @returns Promise containing an EnqueuedTask
       */
    }, {
      key: "resetSettings",
      value: function resetSettings() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee27() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee27$(_context27) {
            while (1) switch (_context27.prev = _context27.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings");
                _context27.next = 3;
                return this.httpRequest.delete(url);
              case 3:
                task = _context27.sent;
                task.enqueuedAt = new Date(task.enqueuedAt);
                return _context27.abrupt("return", task);
              case 6:
              case "end":
                return _context27.stop();
            }
          }, _callee27, this);
        }));
      }
      ///
      /// PAGINATION SETTINGS
      ///
      /**
       * Get the pagination settings.
       *
       * @returns Promise containing object of pagination settings
       */
    }, {
      key: "getPagination",
      value: function getPagination() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee28() {
          var url;
          return _regeneratorRuntime().wrap(function _callee28$(_context28) {
            while (1) switch (_context28.prev = _context28.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/pagination");
                _context28.next = 3;
                return this.httpRequest.get(url);
              case 3:
                return _context28.abrupt("return", _context28.sent);
              case 4:
              case "end":
                return _context28.stop();
            }
          }, _callee28, this);
        }));
      }
      /**
       * Update the pagination settings.
       *
       * @param pagination - Pagination object
       * @returns Promise containing an EnqueuedTask
       */
    }, {
      key: "updatePagination",
      value: function updatePagination(pagination) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee29() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee29$(_context29) {
            while (1) switch (_context29.prev = _context29.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/pagination");
                _context29.next = 3;
                return this.httpRequest.patch(url, pagination);
              case 3:
                task = _context29.sent;
                return _context29.abrupt("return", new EnqueuedTask(task));
              case 5:
              case "end":
                return _context29.stop();
            }
          }, _callee29, this);
        }));
      }
      /**
       * Reset the pagination settings.
       *
       * @returns Promise containing an EnqueuedTask
       */
    }, {
      key: "resetPagination",
      value: function resetPagination() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee30() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee30$(_context30) {
            while (1) switch (_context30.prev = _context30.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/pagination");
                _context30.next = 3;
                return this.httpRequest.delete(url);
              case 3:
                task = _context30.sent;
                return _context30.abrupt("return", new EnqueuedTask(task));
              case 5:
              case "end":
                return _context30.stop();
            }
          }, _callee30, this);
        }));
      }
      ///
      /// SYNONYMS
      ///
      /**
       * Get the list of all synonyms
       *
       * @returns Promise containing object of synonym mappings
       */
    }, {
      key: "getSynonyms",
      value: function getSynonyms() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee31() {
          var url;
          return _regeneratorRuntime().wrap(function _callee31$(_context31) {
            while (1) switch (_context31.prev = _context31.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/synonyms");
                _context31.next = 3;
                return this.httpRequest.get(url);
              case 3:
                return _context31.abrupt("return", _context31.sent);
              case 4:
              case "end":
                return _context31.stop();
            }
          }, _callee31, this);
        }));
      }
      /**
       * Update the list of synonyms. Overwrite the old list.
       *
       * @param synonyms - Mapping of synonyms with their associated words
       * @returns Promise containing an EnqueuedTask
       */
    }, {
      key: "updateSynonyms",
      value: function updateSynonyms(synonyms) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee32() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee32$(_context32) {
            while (1) switch (_context32.prev = _context32.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/synonyms");
                _context32.next = 3;
                return this.httpRequest.put(url, synonyms);
              case 3:
                task = _context32.sent;
                return _context32.abrupt("return", new EnqueuedTask(task));
              case 5:
              case "end":
                return _context32.stop();
            }
          }, _callee32, this);
        }));
      }
      /**
       * Reset the synonym list to be empty again
       *
       * @returns Promise containing an EnqueuedTask
       */
    }, {
      key: "resetSynonyms",
      value: function resetSynonyms() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee33() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee33$(_context33) {
            while (1) switch (_context33.prev = _context33.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/synonyms");
                _context33.next = 3;
                return this.httpRequest.delete(url);
              case 3:
                task = _context33.sent;
                task.enqueuedAt = new Date(task.enqueuedAt);
                return _context33.abrupt("return", task);
              case 6:
              case "end":
                return _context33.stop();
            }
          }, _callee33, this);
        }));
      }
      ///
      /// STOP WORDS
      ///
      /**
       * Get the list of all stop-words
       *
       * @returns Promise containing array of stop-words
       */
    }, {
      key: "getStopWords",
      value: function getStopWords() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee34() {
          var url;
          return _regeneratorRuntime().wrap(function _callee34$(_context34) {
            while (1) switch (_context34.prev = _context34.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/stop-words");
                _context34.next = 3;
                return this.httpRequest.get(url);
              case 3:
                return _context34.abrupt("return", _context34.sent);
              case 4:
              case "end":
                return _context34.stop();
            }
          }, _callee34, this);
        }));
      }
      /**
       * Update the list of stop-words. Overwrite the old list.
       *
       * @param stopWords - Array of strings that contains the stop-words.
       * @returns Promise containing an EnqueuedTask
       */
    }, {
      key: "updateStopWords",
      value: function updateStopWords(stopWords) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee35() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee35$(_context35) {
            while (1) switch (_context35.prev = _context35.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/stop-words");
                _context35.next = 3;
                return this.httpRequest.put(url, stopWords);
              case 3:
                task = _context35.sent;
                return _context35.abrupt("return", new EnqueuedTask(task));
              case 5:
              case "end":
                return _context35.stop();
            }
          }, _callee35, this);
        }));
      }
      /**
       * Reset the stop-words list to be empty again
       *
       * @returns Promise containing an EnqueuedTask
       */
    }, {
      key: "resetStopWords",
      value: function resetStopWords() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee36() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee36$(_context36) {
            while (1) switch (_context36.prev = _context36.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/stop-words");
                _context36.next = 3;
                return this.httpRequest.delete(url);
              case 3:
                task = _context36.sent;
                task.enqueuedAt = new Date(task.enqueuedAt);
                return _context36.abrupt("return", task);
              case 6:
              case "end":
                return _context36.stop();
            }
          }, _callee36, this);
        }));
      }
      ///
      /// RANKING RULES
      ///
      /**
       * Get the list of all ranking-rules
       *
       * @returns Promise containing array of ranking-rules
       */
    }, {
      key: "getRankingRules",
      value: function getRankingRules() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee37() {
          var url;
          return _regeneratorRuntime().wrap(function _callee37$(_context37) {
            while (1) switch (_context37.prev = _context37.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/ranking-rules");
                _context37.next = 3;
                return this.httpRequest.get(url);
              case 3:
                return _context37.abrupt("return", _context37.sent);
              case 4:
              case "end":
                return _context37.stop();
            }
          }, _callee37, this);
        }));
      }
      /**
       * Update the list of ranking-rules. Overwrite the old list.
       *
       * @param rankingRules - Array that contain ranking rules sorted by order of
       *   importance.
       * @returns Promise containing an EnqueuedTask
       */
    }, {
      key: "updateRankingRules",
      value: function updateRankingRules(rankingRules) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee38() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee38$(_context38) {
            while (1) switch (_context38.prev = _context38.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/ranking-rules");
                _context38.next = 3;
                return this.httpRequest.put(url, rankingRules);
              case 3:
                task = _context38.sent;
                return _context38.abrupt("return", new EnqueuedTask(task));
              case 5:
              case "end":
                return _context38.stop();
            }
          }, _callee38, this);
        }));
      }
      /**
       * Reset the ranking rules list to its default value
       *
       * @returns Promise containing an EnqueuedTask
       */
    }, {
      key: "resetRankingRules",
      value: function resetRankingRules() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee39() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee39$(_context39) {
            while (1) switch (_context39.prev = _context39.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/ranking-rules");
                _context39.next = 3;
                return this.httpRequest.delete(url);
              case 3:
                task = _context39.sent;
                task.enqueuedAt = new Date(task.enqueuedAt);
                return _context39.abrupt("return", task);
              case 6:
              case "end":
                return _context39.stop();
            }
          }, _callee39, this);
        }));
      }
      ///
      /// DISTINCT ATTRIBUTE
      ///
      /**
       * Get the distinct-attribute
       *
       * @returns Promise containing the distinct-attribute of the index
       */
    }, {
      key: "getDistinctAttribute",
      value: function getDistinctAttribute() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee40() {
          var url;
          return _regeneratorRuntime().wrap(function _callee40$(_context40) {
            while (1) switch (_context40.prev = _context40.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/distinct-attribute");
                _context40.next = 3;
                return this.httpRequest.get(url);
              case 3:
                return _context40.abrupt("return", _context40.sent);
              case 4:
              case "end":
                return _context40.stop();
            }
          }, _callee40, this);
        }));
      }
      /**
       * Update the distinct-attribute.
       *
       * @param distinctAttribute - Field name of the distinct-attribute
       * @returns Promise containing an EnqueuedTask
       */
    }, {
      key: "updateDistinctAttribute",
      value: function updateDistinctAttribute(distinctAttribute) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee41() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee41$(_context41) {
            while (1) switch (_context41.prev = _context41.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/distinct-attribute");
                _context41.next = 3;
                return this.httpRequest.put(url, distinctAttribute);
              case 3:
                task = _context41.sent;
                return _context41.abrupt("return", new EnqueuedTask(task));
              case 5:
              case "end":
                return _context41.stop();
            }
          }, _callee41, this);
        }));
      }
      /**
       * Reset the distinct-attribute.
       *
       * @returns Promise containing an EnqueuedTask
       */
    }, {
      key: "resetDistinctAttribute",
      value: function resetDistinctAttribute() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee42() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee42$(_context42) {
            while (1) switch (_context42.prev = _context42.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/distinct-attribute");
                _context42.next = 3;
                return this.httpRequest.delete(url);
              case 3:
                task = _context42.sent;
                task.enqueuedAt = new Date(task.enqueuedAt);
                return _context42.abrupt("return", task);
              case 6:
              case "end":
                return _context42.stop();
            }
          }, _callee42, this);
        }));
      }
      ///
      /// FILTERABLE ATTRIBUTES
      ///
      /**
       * Get the filterable-attributes
       *
       * @returns Promise containing an array of filterable-attributes
       */
    }, {
      key: "getFilterableAttributes",
      value: function getFilterableAttributes() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee43() {
          var url;
          return _regeneratorRuntime().wrap(function _callee43$(_context43) {
            while (1) switch (_context43.prev = _context43.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/filterable-attributes");
                _context43.next = 3;
                return this.httpRequest.get(url);
              case 3:
                return _context43.abrupt("return", _context43.sent);
              case 4:
              case "end":
                return _context43.stop();
            }
          }, _callee43, this);
        }));
      }
      /**
       * Update the filterable-attributes.
       *
       * @param filterableAttributes - Array of strings containing the attributes
       *   that can be used as filters at query time
       * @returns Promise containing an EnqueuedTask
       */
    }, {
      key: "updateFilterableAttributes",
      value: function updateFilterableAttributes(filterableAttributes) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee44() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee44$(_context44) {
            while (1) switch (_context44.prev = _context44.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/filterable-attributes");
                _context44.next = 3;
                return this.httpRequest.put(url, filterableAttributes);
              case 3:
                task = _context44.sent;
                return _context44.abrupt("return", new EnqueuedTask(task));
              case 5:
              case "end":
                return _context44.stop();
            }
          }, _callee44, this);
        }));
      }
      /**
       * Reset the filterable-attributes.
       *
       * @returns Promise containing an EnqueuedTask
       */
    }, {
      key: "resetFilterableAttributes",
      value: function resetFilterableAttributes() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee45() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee45$(_context45) {
            while (1) switch (_context45.prev = _context45.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/filterable-attributes");
                _context45.next = 3;
                return this.httpRequest.delete(url);
              case 3:
                task = _context45.sent;
                task.enqueuedAt = new Date(task.enqueuedAt);
                return _context45.abrupt("return", task);
              case 6:
              case "end":
                return _context45.stop();
            }
          }, _callee45, this);
        }));
      }
      ///
      /// SORTABLE ATTRIBUTES
      ///
      /**
       * Get the sortable-attributes
       *
       * @returns Promise containing array of sortable-attributes
       */
    }, {
      key: "getSortableAttributes",
      value: function getSortableAttributes() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee46() {
          var url;
          return _regeneratorRuntime().wrap(function _callee46$(_context46) {
            while (1) switch (_context46.prev = _context46.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/sortable-attributes");
                _context46.next = 3;
                return this.httpRequest.get(url);
              case 3:
                return _context46.abrupt("return", _context46.sent);
              case 4:
              case "end":
                return _context46.stop();
            }
          }, _callee46, this);
        }));
      }
      /**
       * Update the sortable-attributes.
       *
       * @param sortableAttributes - Array of strings containing the attributes that
       *   can be used to sort search results at query time
       * @returns Promise containing an EnqueuedTask
       */
    }, {
      key: "updateSortableAttributes",
      value: function updateSortableAttributes(sortableAttributes) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee47() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee47$(_context47) {
            while (1) switch (_context47.prev = _context47.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/sortable-attributes");
                _context47.next = 3;
                return this.httpRequest.put(url, sortableAttributes);
              case 3:
                task = _context47.sent;
                return _context47.abrupt("return", new EnqueuedTask(task));
              case 5:
              case "end":
                return _context47.stop();
            }
          }, _callee47, this);
        }));
      }
      /**
       * Reset the sortable-attributes.
       *
       * @returns Promise containing an EnqueuedTask
       */
    }, {
      key: "resetSortableAttributes",
      value: function resetSortableAttributes() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee48() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee48$(_context48) {
            while (1) switch (_context48.prev = _context48.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/sortable-attributes");
                _context48.next = 3;
                return this.httpRequest.delete(url);
              case 3:
                task = _context48.sent;
                task.enqueuedAt = new Date(task.enqueuedAt);
                return _context48.abrupt("return", task);
              case 6:
              case "end":
                return _context48.stop();
            }
          }, _callee48, this);
        }));
      }
      ///
      /// SEARCHABLE ATTRIBUTE
      ///
      /**
       * Get the searchable-attributes
       *
       * @returns Promise containing array of searchable-attributes
       */
    }, {
      key: "getSearchableAttributes",
      value: function getSearchableAttributes() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee49() {
          var url;
          return _regeneratorRuntime().wrap(function _callee49$(_context49) {
            while (1) switch (_context49.prev = _context49.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/searchable-attributes");
                _context49.next = 3;
                return this.httpRequest.get(url);
              case 3:
                return _context49.abrupt("return", _context49.sent);
              case 4:
              case "end":
                return _context49.stop();
            }
          }, _callee49, this);
        }));
      }
      /**
       * Update the searchable-attributes.
       *
       * @param searchableAttributes - Array of strings that contains searchable
       *   attributes sorted by order of importance(most to least important)
       * @returns Promise containing an EnqueuedTask
       */
    }, {
      key: "updateSearchableAttributes",
      value: function updateSearchableAttributes(searchableAttributes) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee50() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee50$(_context50) {
            while (1) switch (_context50.prev = _context50.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/searchable-attributes");
                _context50.next = 3;
                return this.httpRequest.put(url, searchableAttributes);
              case 3:
                task = _context50.sent;
                return _context50.abrupt("return", new EnqueuedTask(task));
              case 5:
              case "end":
                return _context50.stop();
            }
          }, _callee50, this);
        }));
      }
      /**
       * Reset the searchable-attributes.
       *
       * @returns Promise containing an EnqueuedTask
       */
    }, {
      key: "resetSearchableAttributes",
      value: function resetSearchableAttributes() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee51() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee51$(_context51) {
            while (1) switch (_context51.prev = _context51.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/searchable-attributes");
                _context51.next = 3;
                return this.httpRequest.delete(url);
              case 3:
                task = _context51.sent;
                task.enqueuedAt = new Date(task.enqueuedAt);
                return _context51.abrupt("return", task);
              case 6:
              case "end":
                return _context51.stop();
            }
          }, _callee51, this);
        }));
      }
      ///
      /// DISPLAYED ATTRIBUTE
      ///
      /**
       * Get the displayed-attributes
       *
       * @returns Promise containing array of displayed-attributes
       */
    }, {
      key: "getDisplayedAttributes",
      value: function getDisplayedAttributes() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee52() {
          var url;
          return _regeneratorRuntime().wrap(function _callee52$(_context52) {
            while (1) switch (_context52.prev = _context52.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/displayed-attributes");
                _context52.next = 3;
                return this.httpRequest.get(url);
              case 3:
                return _context52.abrupt("return", _context52.sent);
              case 4:
              case "end":
                return _context52.stop();
            }
          }, _callee52, this);
        }));
      }
      /**
       * Update the displayed-attributes.
       *
       * @param displayedAttributes - Array of strings that contains attributes of
       *   an index to display
       * @returns Promise containing an EnqueuedTask
       */
    }, {
      key: "updateDisplayedAttributes",
      value: function updateDisplayedAttributes(displayedAttributes) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee53() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee53$(_context53) {
            while (1) switch (_context53.prev = _context53.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/displayed-attributes");
                _context53.next = 3;
                return this.httpRequest.put(url, displayedAttributes);
              case 3:
                task = _context53.sent;
                return _context53.abrupt("return", new EnqueuedTask(task));
              case 5:
              case "end":
                return _context53.stop();
            }
          }, _callee53, this);
        }));
      }
      /**
       * Reset the displayed-attributes.
       *
       * @returns Promise containing an EnqueuedTask
       */
    }, {
      key: "resetDisplayedAttributes",
      value: function resetDisplayedAttributes() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee54() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee54$(_context54) {
            while (1) switch (_context54.prev = _context54.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/displayed-attributes");
                _context54.next = 3;
                return this.httpRequest.delete(url);
              case 3:
                task = _context54.sent;
                task.enqueuedAt = new Date(task.enqueuedAt);
                return _context54.abrupt("return", task);
              case 6:
              case "end":
                return _context54.stop();
            }
          }, _callee54, this);
        }));
      }
      ///
      /// TYPO TOLERANCE
      ///
      /**
       * Get the typo tolerance settings.
       *
       * @returns Promise containing the typo tolerance settings.
       */
    }, {
      key: "getTypoTolerance",
      value: function getTypoTolerance() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee55() {
          var url;
          return _regeneratorRuntime().wrap(function _callee55$(_context55) {
            while (1) switch (_context55.prev = _context55.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/typo-tolerance");
                _context55.next = 3;
                return this.httpRequest.get(url);
              case 3:
                return _context55.abrupt("return", _context55.sent);
              case 4:
              case "end":
                return _context55.stop();
            }
          }, _callee55, this);
        }));
      }
      /**
       * Update the typo tolerance settings.
       *
       * @param typoTolerance - Object containing the custom typo tolerance
       *   settings.
       * @returns Promise containing object of the enqueued update
       */
    }, {
      key: "updateTypoTolerance",
      value: function updateTypoTolerance(typoTolerance) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee56() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee56$(_context56) {
            while (1) switch (_context56.prev = _context56.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/typo-tolerance");
                _context56.next = 3;
                return this.httpRequest.patch(url, typoTolerance);
              case 3:
                task = _context56.sent;
                task.enqueuedAt = new Date(task.enqueuedAt);
                return _context56.abrupt("return", task);
              case 6:
              case "end":
                return _context56.stop();
            }
          }, _callee56, this);
        }));
      }
      /**
       * Reset the typo tolerance settings.
       *
       * @returns Promise containing object of the enqueued update
       */
    }, {
      key: "resetTypoTolerance",
      value: function resetTypoTolerance() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee57() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee57$(_context57) {
            while (1) switch (_context57.prev = _context57.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/typo-tolerance");
                _context57.next = 3;
                return this.httpRequest.delete(url);
              case 3:
                task = _context57.sent;
                task.enqueuedAt = new Date(task.enqueuedAt);
                return _context57.abrupt("return", task);
              case 6:
              case "end":
                return _context57.stop();
            }
          }, _callee57, this);
        }));
      }
      ///
      /// FACETING
      ///
      /**
       * Get the faceting settings.
       *
       * @returns Promise containing object of faceting index settings
       */
    }, {
      key: "getFaceting",
      value: function getFaceting() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee58() {
          var url;
          return _regeneratorRuntime().wrap(function _callee58$(_context58) {
            while (1) switch (_context58.prev = _context58.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/faceting");
                _context58.next = 3;
                return this.httpRequest.get(url);
              case 3:
                return _context58.abrupt("return", _context58.sent);
              case 4:
              case "end":
                return _context58.stop();
            }
          }, _callee58, this);
        }));
      }
      /**
       * Update the faceting settings.
       *
       * @param faceting - Faceting index settings object
       * @returns Promise containing an EnqueuedTask
       */
    }, {
      key: "updateFaceting",
      value: function updateFaceting(faceting) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee59() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee59$(_context59) {
            while (1) switch (_context59.prev = _context59.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/faceting");
                _context59.next = 3;
                return this.httpRequest.patch(url, faceting);
              case 3:
                task = _context59.sent;
                return _context59.abrupt("return", new EnqueuedTask(task));
              case 5:
              case "end":
                return _context59.stop();
            }
          }, _callee59, this);
        }));
      }
      /**
       * Reset the faceting settings.
       *
       * @returns Promise containing an EnqueuedTask
       */
    }, {
      key: "resetFaceting",
      value: function resetFaceting() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee60() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee60$(_context60) {
            while (1) switch (_context60.prev = _context60.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/faceting");
                _context60.next = 3;
                return this.httpRequest.delete(url);
              case 3:
                task = _context60.sent;
                return _context60.abrupt("return", new EnqueuedTask(task));
              case 5:
              case "end":
                return _context60.stop();
            }
          }, _callee60, this);
        }));
      }
      ///
      /// SEPARATOR TOKENS
      ///
      /**
       * Get the list of all separator tokens.
       *
       * @returns Promise containing array of separator tokens
       */
    }, {
      key: "getSeparatorTokens",
      value: function getSeparatorTokens() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee61() {
          var url;
          return _regeneratorRuntime().wrap(function _callee61$(_context61) {
            while (1) switch (_context61.prev = _context61.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/separator-tokens");
                _context61.next = 3;
                return this.httpRequest.get(url);
              case 3:
                return _context61.abrupt("return", _context61.sent);
              case 4:
              case "end":
                return _context61.stop();
            }
          }, _callee61, this);
        }));
      }
      /**
       * Update the list of separator tokens. Overwrite the old list.
       *
       * @param separatorTokens - Array that contains separator tokens.
       * @returns Promise containing an EnqueuedTask or null
       */
    }, {
      key: "updateSeparatorTokens",
      value: function updateSeparatorTokens(separatorTokens) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee62() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee62$(_context62) {
            while (1) switch (_context62.prev = _context62.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/separator-tokens");
                _context62.next = 3;
                return this.httpRequest.put(url, separatorTokens);
              case 3:
                task = _context62.sent;
                return _context62.abrupt("return", new EnqueuedTask(task));
              case 5:
              case "end":
                return _context62.stop();
            }
          }, _callee62, this);
        }));
      }
      /**
       * Reset the separator tokens list to its default value
       *
       * @returns Promise containing an EnqueuedTask
       */
    }, {
      key: "resetSeparatorTokens",
      value: function resetSeparatorTokens() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee63() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee63$(_context63) {
            while (1) switch (_context63.prev = _context63.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/separator-tokens");
                _context63.next = 3;
                return this.httpRequest.delete(url);
              case 3:
                task = _context63.sent;
                task.enqueuedAt = new Date(task.enqueuedAt);
                return _context63.abrupt("return", task);
              case 6:
              case "end":
                return _context63.stop();
            }
          }, _callee63, this);
        }));
      }
      ///
      /// NON-SEPARATOR TOKENS
      ///
      /**
       * Get the list of all non-separator tokens.
       *
       * @returns Promise containing array of non-separator tokens
       */
    }, {
      key: "getNonSeparatorTokens",
      value: function getNonSeparatorTokens() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee64() {
          var url;
          return _regeneratorRuntime().wrap(function _callee64$(_context64) {
            while (1) switch (_context64.prev = _context64.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/non-separator-tokens");
                _context64.next = 3;
                return this.httpRequest.get(url);
              case 3:
                return _context64.abrupt("return", _context64.sent);
              case 4:
              case "end":
                return _context64.stop();
            }
          }, _callee64, this);
        }));
      }
      /**
       * Update the list of non-separator tokens. Overwrite the old list.
       *
       * @param nonSeparatorTokens - Array that contains non-separator tokens.
       * @returns Promise containing an EnqueuedTask or null
       */
    }, {
      key: "updateNonSeparatorTokens",
      value: function updateNonSeparatorTokens(nonSeparatorTokens) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee65() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee65$(_context65) {
            while (1) switch (_context65.prev = _context65.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/non-separator-tokens");
                _context65.next = 3;
                return this.httpRequest.put(url, nonSeparatorTokens);
              case 3:
                task = _context65.sent;
                return _context65.abrupt("return", new EnqueuedTask(task));
              case 5:
              case "end":
                return _context65.stop();
            }
          }, _callee65, this);
        }));
      }
      /**
       * Reset the non-separator tokens list to its default value
       *
       * @returns Promise containing an EnqueuedTask
       */
    }, {
      key: "resetNonSeparatorTokens",
      value: function resetNonSeparatorTokens() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee66() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee66$(_context66) {
            while (1) switch (_context66.prev = _context66.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/non-separator-tokens");
                _context66.next = 3;
                return this.httpRequest.delete(url);
              case 3:
                task = _context66.sent;
                task.enqueuedAt = new Date(task.enqueuedAt);
                return _context66.abrupt("return", task);
              case 6:
              case "end":
                return _context66.stop();
            }
          }, _callee66, this);
        }));
      }
      ///
      /// DICTIONARY
      ///
      /**
       * Get the dictionary settings of a Meilisearch index.
       *
       * @returns Promise containing the dictionary settings
       */
    }, {
      key: "getDictionary",
      value: function getDictionary() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee67() {
          var url;
          return _regeneratorRuntime().wrap(function _callee67$(_context67) {
            while (1) switch (_context67.prev = _context67.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/dictionary");
                _context67.next = 3;
                return this.httpRequest.get(url);
              case 3:
                return _context67.abrupt("return", _context67.sent);
              case 4:
              case "end":
                return _context67.stop();
            }
          }, _callee67, this);
        }));
      }
      /**
       * Update the dictionary settings. Overwrite the old settings.
       *
       * @param dictionary - Array that contains the new dictionary settings.
       * @returns Promise containing an EnqueuedTask or null
       */
    }, {
      key: "updateDictionary",
      value: function updateDictionary(dictionary) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee68() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee68$(_context68) {
            while (1) switch (_context68.prev = _context68.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/dictionary");
                _context68.next = 3;
                return this.httpRequest.put(url, dictionary);
              case 3:
                task = _context68.sent;
                return _context68.abrupt("return", new EnqueuedTask(task));
              case 5:
              case "end":
                return _context68.stop();
            }
          }, _callee68, this);
        }));
      }
      /**
       * Reset the dictionary settings to its default value
       *
       * @returns Promise containing an EnqueuedTask
       */
    }, {
      key: "resetDictionary",
      value: function resetDictionary() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee69() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee69$(_context69) {
            while (1) switch (_context69.prev = _context69.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/dictionary");
                _context69.next = 3;
                return this.httpRequest.delete(url);
              case 3:
                task = _context69.sent;
                task.enqueuedAt = new Date(task.enqueuedAt);
                return _context69.abrupt("return", task);
              case 6:
              case "end":
                return _context69.stop();
            }
          }, _callee69, this);
        }));
      }
      ///
      /// PROXIMITY PRECISION
      ///
      /**
       * Get the proximity precision settings of a Meilisearch index.
       *
       * @returns Promise containing the proximity precision settings
       */
    }, {
      key: "getProximityPrecision",
      value: function getProximityPrecision() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee70() {
          var url;
          return _regeneratorRuntime().wrap(function _callee70$(_context70) {
            while (1) switch (_context70.prev = _context70.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/proximity-precision");
                _context70.next = 3;
                return this.httpRequest.get(url);
              case 3:
                return _context70.abrupt("return", _context70.sent);
              case 4:
              case "end":
                return _context70.stop();
            }
          }, _callee70, this);
        }));
      }
      /**
       * Update the proximity precision settings. Overwrite the old settings.
       *
       * @param proximityPrecision - String that contains the new proximity
       *   precision settings.
       * @returns Promise containing an EnqueuedTask or null
       */
    }, {
      key: "updateProximityPrecision",
      value: function updateProximityPrecision(proximityPrecision) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee71() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee71$(_context71) {
            while (1) switch (_context71.prev = _context71.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/proximity-precision");
                _context71.next = 3;
                return this.httpRequest.put(url, proximityPrecision);
              case 3:
                task = _context71.sent;
                return _context71.abrupt("return", new EnqueuedTask(task));
              case 5:
              case "end":
                return _context71.stop();
            }
          }, _callee71, this);
        }));
      }
      /**
       * Reset the proximity precision settings to its default value
       *
       * @returns Promise containing an EnqueuedTask
       */
    }, {
      key: "resetProximityPrecision",
      value: function resetProximityPrecision() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee72() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee72$(_context72) {
            while (1) switch (_context72.prev = _context72.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/proximity-precision");
                _context72.next = 3;
                return this.httpRequest.delete(url);
              case 3:
                task = _context72.sent;
                task.enqueuedAt = new Date(task.enqueuedAt);
                return _context72.abrupt("return", task);
              case 6:
              case "end":
                return _context72.stop();
            }
          }, _callee72, this);
        }));
      }
      ///
      /// EMBEDDERS
      ///
      /**
       * Get the embedders settings of a Meilisearch index.
       *
       * @returns Promise containing the embedders settings
       */
    }, {
      key: "getEmbedders",
      value: function getEmbedders() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee73() {
          var url;
          return _regeneratorRuntime().wrap(function _callee73$(_context73) {
            while (1) switch (_context73.prev = _context73.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/embedders");
                _context73.next = 3;
                return this.httpRequest.get(url);
              case 3:
                return _context73.abrupt("return", _context73.sent);
              case 4:
              case "end":
                return _context73.stop();
            }
          }, _callee73, this);
        }));
      }
      /**
       * Update the embedders settings. Overwrite the old settings.
       *
       * @param embedders - Object that contains the new embedders settings.
       * @returns Promise containing an EnqueuedTask or null
       */
    }, {
      key: "updateEmbedders",
      value: function updateEmbedders(embedders) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee74() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee74$(_context74) {
            while (1) switch (_context74.prev = _context74.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/embedders");
                _context74.next = 3;
                return this.httpRequest.patch(url, embedders);
              case 3:
                task = _context74.sent;
                return _context74.abrupt("return", new EnqueuedTask(task));
              case 5:
              case "end":
                return _context74.stop();
            }
          }, _callee74, this);
        }));
      }
      /**
       * Reset the embedders settings to its default value
       *
       * @returns Promise containing an EnqueuedTask
       */
    }, {
      key: "resetEmbedders",
      value: function resetEmbedders() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee75() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee75$(_context75) {
            while (1) switch (_context75.prev = _context75.next) {
              case 0:
                url = "indexes/".concat(this.uid, "/settings/embedders");
                _context75.next = 3;
                return this.httpRequest.delete(url);
              case 3:
                task = _context75.sent;
                task.enqueuedAt = new Date(task.enqueuedAt);
                return _context75.abrupt("return", task);
              case 6:
              case "end":
                return _context75.stop();
            }
          }, _callee75, this);
        }));
      }
    }], [{
      key: "create",
      value: function create(uid) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var config = arguments.length > 2 ? arguments[2] : undefined;
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee76() {
          var url, req, task;
          return _regeneratorRuntime().wrap(function _callee76$(_context76) {
            while (1) switch (_context76.prev = _context76.next) {
              case 0:
                url = "indexes";
                req = new HttpRequests(config);
                _context76.next = 4;
                return req.post(url, Object.assign(Object.assign({}, options), {
                  uid: uid
                }));
              case 4:
                task = _context76.sent;
                return _context76.abrupt("return", new EnqueuedTask(task));
              case 6:
              case "end":
                return _context76.stop();
            }
          }, _callee76);
        }));
      }
    }]);
    return Index;
  }();

  /*
   * Bundle: MeiliSearch
   * Project: MeiliSearch - Javascript API
   * Author: Quentin de Quelen <quentin@meilisearch.com>
   * Copyright: 2019, MeiliSearch
   */
  var Client = /*#__PURE__*/function () {
    /**
     * Creates new MeiliSearch instance
     *
     * @param config - Configuration object
     */
    function Client(config) {
      _classCallCheck(this, Client);
      this.config = config;
      this.httpRequest = new HttpRequests(config);
      this.tasks = new TaskClient(config);
    }
    /**
     * Return an Index instance
     *
     * @param indexUid - The index UID
     * @returns Instance of Index
     */
    _createClass(Client, [{
      key: "index",
      value: function index(indexUid) {
        return new Index(this.config, indexUid);
      }
      /**
       * Gather information about an index by calling MeiliSearch and return an
       * Index instance with the gathered information
       *
       * @param indexUid - The index UID
       * @returns Promise returning Index instance
       */
    }, {
      key: "getIndex",
      value: function getIndex(indexUid) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", new Index(this.config, indexUid).fetchInfo());
              case 1:
              case "end":
                return _context.stop();
            }
          }, _callee, this);
        }));
      }
      /**
       * Gather information about an index by calling MeiliSearch and return the raw
       * JSON response
       *
       * @param indexUid - The index UID
       * @returns Promise returning index information
       */
    }, {
      key: "getRawIndex",
      value: function getRawIndex(indexUid) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", new Index(this.config, indexUid).getRawInfo());
              case 1:
              case "end":
                return _context2.stop();
            }
          }, _callee2, this);
        }));
      }
      /**
       * Get all the indexes as Index instances.
       *
       * @param parameters - Parameters to browse the indexes
       * @returns Promise returning array of raw index information
       */
    }, {
      key: "getIndexes",
      value: function getIndexes() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
          var _this = this;
          var rawIndexes, indexes;
          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.getRawIndexes(parameters);
              case 2:
                rawIndexes = _context3.sent;
                indexes = rawIndexes.results.map(function (index) {
                  return new Index(_this.config, index.uid, index.primaryKey);
                });
                return _context3.abrupt("return", Object.assign(Object.assign({}, rawIndexes), {
                  results: indexes
                }));
              case 5:
              case "end":
                return _context3.stop();
            }
          }, _callee3, this);
        }));
      }
      /**
       * Get all the indexes in their raw value (no Index instances).
       *
       * @param parameters - Parameters to browse the indexes
       * @returns Promise returning array of raw index information
       */
    }, {
      key: "getRawIndexes",
      value: function getRawIndexes() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
          var url;
          return _regeneratorRuntime().wrap(function _callee4$(_context4) {
            while (1) switch (_context4.prev = _context4.next) {
              case 0:
                url = "indexes";
                _context4.next = 3;
                return this.httpRequest.get(url, parameters);
              case 3:
                return _context4.abrupt("return", _context4.sent);
              case 4:
              case "end":
                return _context4.stop();
            }
          }, _callee4, this);
        }));
      }
      /**
       * Create a new index
       *
       * @param uid - The index UID
       * @param options - Index options
       * @returns Promise returning Index instance
       */
    }, {
      key: "createIndex",
      value: function createIndex(uid) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
          return _regeneratorRuntime().wrap(function _callee5$(_context5) {
            while (1) switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return Index.create(uid, options, this.config);
              case 2:
                return _context5.abrupt("return", _context5.sent);
              case 3:
              case "end":
                return _context5.stop();
            }
          }, _callee5, this);
        }));
      }
      /**
       * Update an index
       *
       * @param uid - The index UID
       * @param options - Index options to update
       * @returns Promise returning Index instance after updating
       */
    }, {
      key: "updateIndex",
      value: function updateIndex(uid) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
          return _regeneratorRuntime().wrap(function _callee6$(_context6) {
            while (1) switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return new Index(this.config, uid).update(options);
              case 2:
                return _context6.abrupt("return", _context6.sent);
              case 3:
              case "end":
                return _context6.stop();
            }
          }, _callee6, this);
        }));
      }
      /**
       * Delete an index
       *
       * @param uid - The index UID
       * @returns Promise which resolves when index is deleted successfully
       */
    }, {
      key: "deleteIndex",
      value: function deleteIndex(uid) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
          return _regeneratorRuntime().wrap(function _callee7$(_context7) {
            while (1) switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return new Index(this.config, uid).delete();
              case 2:
                return _context7.abrupt("return", _context7.sent);
              case 3:
              case "end":
                return _context7.stop();
            }
          }, _callee7, this);
        }));
      }
      /**
       * Deletes an index if it already exists.
       *
       * @param uid - The index UID
       * @returns Promise which resolves to true when index exists and is deleted
       *   successfully, otherwise false if it does not exist
       */
    }, {
      key: "deleteIndexIfExists",
      value: function deleteIndexIfExists(uid) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
          return _regeneratorRuntime().wrap(function _callee8$(_context8) {
            while (1) switch (_context8.prev = _context8.next) {
              case 0:
                _context8.prev = 0;
                _context8.next = 3;
                return this.deleteIndex(uid);
              case 3:
                return _context8.abrupt("return", true);
              case 6:
                _context8.prev = 6;
                _context8.t0 = _context8["catch"](0);
                if (!(_context8.t0.code === ErrorStatusCode.INDEX_NOT_FOUND)) {
                  _context8.next = 10;
                  break;
                }
                return _context8.abrupt("return", false);
              case 10:
                throw _context8.t0;
              case 11:
              case "end":
                return _context8.stop();
            }
          }, _callee8, this, [[0, 6]]);
        }));
      }
      /**
       * Swaps a list of index tuples.
       *
       * @param params - List of indexes tuples to swap.
       * @returns Promise returning object of the enqueued task
       */
    }, {
      key: "swapIndexes",
      value: function swapIndexes(params) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
          var url;
          return _regeneratorRuntime().wrap(function _callee9$(_context9) {
            while (1) switch (_context9.prev = _context9.next) {
              case 0:
                url = '/swap-indexes';
                _context9.next = 3;
                return this.httpRequest.post(url, params);
              case 3:
                return _context9.abrupt("return", _context9.sent);
              case 4:
              case "end":
                return _context9.stop();
            }
          }, _callee9, this);
        }));
      }
      ///
      /// Multi Search
      ///
      /**
       * Perform multiple search queries.
       *
       * It is possible to make multiple search queries on the same index or on
       * different ones
       *
       * @example
       *
       * ```ts
       * client.multiSearch({
       *   queries: [
       *     { indexUid: 'movies', q: 'wonder' },
       *     { indexUid: 'books', q: 'flower' },
       *   ],
       * })
       * ```
       *
       * @param queries - Search queries
       * @param config - Additional request configuration options
       * @returns Promise containing the search responses
       */
    }, {
      key: "multiSearch",
      value: function multiSearch(queries, config) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
          var url;
          return _regeneratorRuntime().wrap(function _callee10$(_context10) {
            while (1) switch (_context10.prev = _context10.next) {
              case 0:
                url = "multi-search";
                _context10.next = 3;
                return this.httpRequest.post(url, queries, undefined, config);
              case 3:
                return _context10.abrupt("return", _context10.sent);
              case 4:
              case "end":
                return _context10.stop();
            }
          }, _callee10, this);
        }));
      }
      ///
      /// TASKS
      ///
      /**
       * Get the list of all client tasks
       *
       * @param parameters - Parameters to browse the tasks
       * @returns Promise returning all tasks
       */
    }, {
      key: "getTasks",
      value: function getTasks() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
          return _regeneratorRuntime().wrap(function _callee11$(_context11) {
            while (1) switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return this.tasks.getTasks(parameters);
              case 2:
                return _context11.abrupt("return", _context11.sent);
              case 3:
              case "end":
                return _context11.stop();
            }
          }, _callee11, this);
        }));
      }
      /**
       * Get one task on the client scope
       *
       * @param taskUid - Task identifier
       * @returns Promise returning a task
       */
    }, {
      key: "getTask",
      value: function getTask(taskUid) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {
          return _regeneratorRuntime().wrap(function _callee12$(_context12) {
            while (1) switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return this.tasks.getTask(taskUid);
              case 2:
                return _context12.abrupt("return", _context12.sent);
              case 3:
              case "end":
                return _context12.stop();
            }
          }, _callee12, this);
        }));
      }
      /**
       * Wait for multiple tasks to be finished.
       *
       * @param taskUids - Tasks identifier
       * @param waitOptions - Options on timeout and interval
       * @returns Promise returning an array of tasks
       */
    }, {
      key: "waitForTasks",
      value: function waitForTasks(taskUids) {
        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref$timeOutMs = _ref.timeOutMs,
          timeOutMs = _ref$timeOutMs === void 0 ? 5000 : _ref$timeOutMs,
          _ref$intervalMs = _ref.intervalMs,
          intervalMs = _ref$intervalMs === void 0 ? 50 : _ref$intervalMs;
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {
          return _regeneratorRuntime().wrap(function _callee13$(_context13) {
            while (1) switch (_context13.prev = _context13.next) {
              case 0:
                _context13.next = 2;
                return this.tasks.waitForTasks(taskUids, {
                  timeOutMs: timeOutMs,
                  intervalMs: intervalMs
                });
              case 2:
                return _context13.abrupt("return", _context13.sent);
              case 3:
              case "end":
                return _context13.stop();
            }
          }, _callee13, this);
        }));
      }
      /**
       * Wait for a task to be finished.
       *
       * @param taskUid - Task identifier
       * @param waitOptions - Options on timeout and interval
       * @returns Promise returning an array of tasks
       */
    }, {
      key: "waitForTask",
      value: function waitForTask(taskUid) {
        var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$timeOutMs = _ref2.timeOutMs,
          timeOutMs = _ref2$timeOutMs === void 0 ? 5000 : _ref2$timeOutMs,
          _ref2$intervalMs = _ref2.intervalMs,
          intervalMs = _ref2$intervalMs === void 0 ? 50 : _ref2$intervalMs;
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {
          return _regeneratorRuntime().wrap(function _callee14$(_context14) {
            while (1) switch (_context14.prev = _context14.next) {
              case 0:
                _context14.next = 2;
                return this.tasks.waitForTask(taskUid, {
                  timeOutMs: timeOutMs,
                  intervalMs: intervalMs
                });
              case 2:
                return _context14.abrupt("return", _context14.sent);
              case 3:
              case "end":
                return _context14.stop();
            }
          }, _callee14, this);
        }));
      }
      /**
       * Cancel a list of enqueued or processing tasks.
       *
       * @param parameters - Parameters to filter the tasks.
       * @returns Promise containing an EnqueuedTask
       */
    }, {
      key: "cancelTasks",
      value: function cancelTasks(parameters) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {
          return _regeneratorRuntime().wrap(function _callee15$(_context15) {
            while (1) switch (_context15.prev = _context15.next) {
              case 0:
                _context15.next = 2;
                return this.tasks.cancelTasks(parameters);
              case 2:
                return _context15.abrupt("return", _context15.sent);
              case 3:
              case "end":
                return _context15.stop();
            }
          }, _callee15, this);
        }));
      }
      /**
       * Delete a list of tasks.
       *
       * @param parameters - Parameters to filter the tasks.
       * @returns Promise containing an EnqueuedTask
       */
    }, {
      key: "deleteTasks",
      value: function deleteTasks() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {
          return _regeneratorRuntime().wrap(function _callee16$(_context16) {
            while (1) switch (_context16.prev = _context16.next) {
              case 0:
                _context16.next = 2;
                return this.tasks.deleteTasks(parameters);
              case 2:
                return _context16.abrupt("return", _context16.sent);
              case 3:
              case "end":
                return _context16.stop();
            }
          }, _callee16, this);
        }));
      }
      ///
      /// KEYS
      ///
      /**
       * Get all API keys
       *
       * @param parameters - Parameters to browse the indexes
       * @returns Promise returning an object with keys
       */
    }, {
      key: "getKeys",
      value: function getKeys() {
        var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {
          var url, keys;
          return _regeneratorRuntime().wrap(function _callee17$(_context17) {
            while (1) switch (_context17.prev = _context17.next) {
              case 0:
                url = "keys";
                _context17.next = 3;
                return this.httpRequest.get(url, parameters);
              case 3:
                keys = _context17.sent;
                keys.results = keys.results.map(function (key) {
                  return Object.assign(Object.assign({}, key), {
                    createdAt: new Date(key.createdAt),
                    updatedAt: new Date(key.updatedAt)
                  });
                });
                return _context17.abrupt("return", keys);
              case 6:
              case "end":
                return _context17.stop();
            }
          }, _callee17, this);
        }));
      }
      /**
       * Get one API key
       *
       * @param keyOrUid - Key or uid of the API key
       * @returns Promise returning a key
       */
    }, {
      key: "getKey",
      value: function getKey(keyOrUid) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee18() {
          var url;
          return _regeneratorRuntime().wrap(function _callee18$(_context18) {
            while (1) switch (_context18.prev = _context18.next) {
              case 0:
                url = "keys/".concat(keyOrUid);
                _context18.next = 3;
                return this.httpRequest.get(url);
              case 3:
                return _context18.abrupt("return", _context18.sent);
              case 4:
              case "end":
                return _context18.stop();
            }
          }, _callee18, this);
        }));
      }
      /**
       * Create one API key
       *
       * @param options - Key options
       * @returns Promise returning a key
       */
    }, {
      key: "createKey",
      value: function createKey(options) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee19() {
          var url;
          return _regeneratorRuntime().wrap(function _callee19$(_context19) {
            while (1) switch (_context19.prev = _context19.next) {
              case 0:
                url = "keys";
                _context19.next = 3;
                return this.httpRequest.post(url, options);
              case 3:
                return _context19.abrupt("return", _context19.sent);
              case 4:
              case "end":
                return _context19.stop();
            }
          }, _callee19, this);
        }));
      }
      /**
       * Update one API key
       *
       * @param keyOrUid - Key
       * @param options - Key options
       * @returns Promise returning a key
       */
    }, {
      key: "updateKey",
      value: function updateKey(keyOrUid, options) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee20() {
          var url;
          return _regeneratorRuntime().wrap(function _callee20$(_context20) {
            while (1) switch (_context20.prev = _context20.next) {
              case 0:
                url = "keys/".concat(keyOrUid);
                _context20.next = 3;
                return this.httpRequest.patch(url, options);
              case 3:
                return _context20.abrupt("return", _context20.sent);
              case 4:
              case "end":
                return _context20.stop();
            }
          }, _callee20, this);
        }));
      }
      /**
       * Delete one API key
       *
       * @param keyOrUid - Key
       * @returns
       */
    }, {
      key: "deleteKey",
      value: function deleteKey(keyOrUid) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee21() {
          var url;
          return _regeneratorRuntime().wrap(function _callee21$(_context21) {
            while (1) switch (_context21.prev = _context21.next) {
              case 0:
                url = "keys/".concat(keyOrUid);
                _context21.next = 3;
                return this.httpRequest.delete(url);
              case 3:
                return _context21.abrupt("return", _context21.sent);
              case 4:
              case "end":
                return _context21.stop();
            }
          }, _callee21, this);
        }));
      }
      ///
      /// HEALTH
      ///
      /**
       * Checks if the server is healthy, otherwise an error will be thrown.
       *
       * @returns Promise returning an object with health details
       */
    }, {
      key: "health",
      value: function health() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee22() {
          var url;
          return _regeneratorRuntime().wrap(function _callee22$(_context22) {
            while (1) switch (_context22.prev = _context22.next) {
              case 0:
                url = "health";
                _context22.next = 3;
                return this.httpRequest.get(url);
              case 3:
                return _context22.abrupt("return", _context22.sent);
              case 4:
              case "end":
                return _context22.stop();
            }
          }, _callee22, this);
        }));
      }
      /**
       * Checks if the server is healthy, return true or false.
       *
       * @returns Promise returning a boolean
       */
    }, {
      key: "isHealthy",
      value: function isHealthy() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee23() {
          var url;
          return _regeneratorRuntime().wrap(function _callee23$(_context23) {
            while (1) switch (_context23.prev = _context23.next) {
              case 0:
                _context23.prev = 0;
                url = "health";
                _context23.next = 4;
                return this.httpRequest.get(url);
              case 4:
                return _context23.abrupt("return", true);
              case 7:
                _context23.prev = 7;
                _context23.t0 = _context23["catch"](0);
                return _context23.abrupt("return", false);
              case 10:
              case "end":
                return _context23.stop();
            }
          }, _callee23, this, [[0, 7]]);
        }));
      }
      ///
      /// STATS
      ///
      /**
       * Get the stats of all the database
       *
       * @returns Promise returning object of all the stats
       */
    }, {
      key: "getStats",
      value: function getStats() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee24() {
          var url;
          return _regeneratorRuntime().wrap(function _callee24$(_context24) {
            while (1) switch (_context24.prev = _context24.next) {
              case 0:
                url = "stats";
                _context24.next = 3;
                return this.httpRequest.get(url);
              case 3:
                return _context24.abrupt("return", _context24.sent);
              case 4:
              case "end":
                return _context24.stop();
            }
          }, _callee24, this);
        }));
      }
      ///
      /// VERSION
      ///
      /**
       * Get the version of MeiliSearch
       *
       * @returns Promise returning object with version details
       */
    }, {
      key: "getVersion",
      value: function getVersion() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee25() {
          var url;
          return _regeneratorRuntime().wrap(function _callee25$(_context25) {
            while (1) switch (_context25.prev = _context25.next) {
              case 0:
                url = "version";
                _context25.next = 3;
                return this.httpRequest.get(url);
              case 3:
                return _context25.abrupt("return", _context25.sent);
              case 4:
              case "end":
                return _context25.stop();
            }
          }, _callee25, this);
        }));
      }
      ///
      /// DUMPS
      ///
      /**
       * Creates a dump
       *
       * @returns Promise returning object of the enqueued task
       */
    }, {
      key: "createDump",
      value: function createDump() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee26() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee26$(_context26) {
            while (1) switch (_context26.prev = _context26.next) {
              case 0:
                url = "dumps";
                _context26.next = 3;
                return this.httpRequest.post(url);
              case 3:
                task = _context26.sent;
                return _context26.abrupt("return", new EnqueuedTask(task));
              case 5:
              case "end":
                return _context26.stop();
            }
          }, _callee26, this);
        }));
      }
      ///
      /// SNAPSHOTS
      ///
      /**
       * Creates a snapshot
       *
       * @returns Promise returning object of the enqueued task
       */
    }, {
      key: "createSnapshot",
      value: function createSnapshot() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee27() {
          var url, task;
          return _regeneratorRuntime().wrap(function _callee27$(_context27) {
            while (1) switch (_context27.prev = _context27.next) {
              case 0:
                url = "snapshots";
                _context27.next = 3;
                return this.httpRequest.post(url);
              case 3:
                task = _context27.sent;
                return _context27.abrupt("return", new EnqueuedTask(task));
              case 5:
              case "end":
                return _context27.stop();
            }
          }, _callee27, this);
        }));
      }
      ///
      /// TOKENS
      ///
      /**
       * Generate a tenant token
       *
       * @param apiKeyUid - The uid of the api key used as issuer of the token.
       * @param searchRules - Search rules that are applied to every search.
       * @param options - Token options to customize some aspect of the token.
       * @returns The token in JWT format.
       */
    }, {
      key: "generateTenantToken",
      value: function generateTenantToken(_apiKeyUid, _searchRules, _options) {
        var error = new Error();
        throw new Error("Meilisearch: failed to generate a tenant token. Generation of a token only works in a node environment \n ".concat(error.stack, "."));
      }
    }]);
    return Client;
  }();

  var MeiliSearch = /*#__PURE__*/function (_Client) {
    _inherits(MeiliSearch, _Client);
    var _super = _createSuper(MeiliSearch);
    function MeiliSearch(config) {
      _classCallCheck(this, MeiliSearch);
      return _super.call(this, config);
    }
    return _createClass(MeiliSearch);
  }(Client);

  exports.ContentTypeEnum = ContentTypeEnum;
  exports.ErrorStatusCode = ErrorStatusCode;
  exports.Index = Index;
  exports.MatchingStrategies = MatchingStrategies;
  exports.MeiliSearch = MeiliSearch;
  exports.MeiliSearchApiError = MeiliSearchApiError;
  exports.MeiliSearchCommunicationError = MeiliSearchCommunicationError;
  exports.MeiliSearchError = MeiliSearchError;
  exports.MeiliSearchTimeOutError = MeiliSearchTimeOutError;
  exports.Meilisearch = MeiliSearch;
  exports.TaskStatus = TaskStatus;
  exports.TaskTypes = TaskTypes;
  exports["default"] = MeiliSearch;
  exports.httpErrorHandler = httpErrorHandler;
  exports.httpResponseErrorHandler = httpResponseErrorHandler;
  exports.versionErrorHintMessage = versionErrorHintMessage;

  Object.defineProperty(exports, '__esModule', { value: true });

}));


/***/ }),

/***/ 310:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

(function(t,e){ true?module.exports=e(__webpack_require__(878)):0})("undefined"!==typeof self?self:this,(function(t){return function(t){var e={};function r(n){if(e[n])return e[n].exports;var a=e[n]={i:n,l:!1,exports:{}};return t[n].call(a.exports,a,a.exports,r),a.l=!0,a.exports}return r.m=t,r.c=e,r.d=function(t,e,n){r.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:n})},r.r=function(t){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},r.t=function(t,e){if(1&e&&(t=r(t)),8&e)return t;if(4&e&&"object"===typeof t&&t&&t.__esModule)return t;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var a in t)r.d(n,a,function(e){return t[e]}.bind(null,a));return n},r.n=function(t){var e=t&&t.__esModule?function(){return t["default"]}:function(){return t};return r.d(e,"a",e),e},r.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},r.p="",r(r.s="fb15")}({"00ee":function(t,e,r){"use strict";var n=r("b622"),a=n("toStringTag"),o={};o[a]="z",t.exports="[object z]"===String(o)},"00fd":function(t,e,r){var n=r("9e69"),a=Object.prototype,o=a.hasOwnProperty,i=a.toString,s=n?n.toStringTag:void 0;function c(t){var e=o.call(t,s),r=t[s];try{t[s]=void 0;var n=!0}catch(c){}var a=i.call(t);return n&&(e?t[s]=r:delete t[s]),a}t.exports=c},"03dd":function(t,e,r){var n=r("eac5"),a=r("57a5"),o=Object.prototype,i=o.hasOwnProperty;function s(t){if(!n(t))return a(t);var e=[];for(var r in Object(t))i.call(t,r)&&"constructor"!=r&&e.push(r);return e}t.exports=s},"0459":function(t,e,r){"use strict";r("643d")},"04f8":function(t,e,r){"use strict";var n=r("2d00"),a=r("d039"),o=r("da84"),i=o.String;t.exports=!!Object.getOwnPropertySymbols&&!a((function(){var t=Symbol("symbol detection");return!i(t)||!(Object(t)instanceof Symbol)||!Symbol.sham&&n&&n<41}))},"0621":function(t,e,r){var n=r("9e69"),a=r("d370"),o=r("6747"),i=n?n.isConcatSpreadable:void 0;function s(t){return o(t)||a(t)||!!(i&&t&&t[i])}t.exports=s},"06cf":function(t,e,r){"use strict";var n=r("83ab"),a=r("c65b"),o=r("d1e7"),i=r("5c6c"),s=r("fc6a"),c=r("a04b"),u=r("1a2d"),l=r("0cfb"),d=Object.getOwnPropertyDescriptor;e.f=n?d:function(t,e){if(t=s(t),e=c(e),l)try{return d(t,e)}catch(r){}if(u(t,e))return i(!a(o.f,t,e),t[e])}},"0733":function(t,e,r){"use strict";r.d(e,"a",(function(){return o}));var n=r("2fa3"),a=r("9404");const o=function(t,e,{maxSwipeTime:r,minHorizontalSwipeDistance:o,maxVerticalSwipeDistance:i}){if(!t||!t.addEventListener||!Object(a["k"])(e))return null;let s=0,c=0,u=null,l=!1;function d(t){const e=t.changedTouches[0];s=e.screenX,c=e.screenY,u=(new Date).getTime(),l=!0}function f(t){if(!l)return;l=!1;const n=t.changedTouches[0],a=n.screenX-s,d=n.screenY-c,f=(new Date).getTime()-u;if(f<r&&Math.abs(a)>=o&&Math.abs(d)<=i){const t={toLeft:!1,toRight:!1};a<0?t.toLeft=!0:t.toRight=!0,e(t)}}return Object(n["k"])(t,"touchstart",d,{passive:!0}),Object(n["k"])(t,"touchend",f,{passive:!0}),function(){Object(n["j"])(t,"touchstart",d),Object(n["j"])(t,"touchend",f)}}},"07c7":function(t,e){function r(){return!1}t.exports=r},"07fa":function(t,e,r){"use strict";var n=r("50c4");t.exports=function(t){return n(t.length)}},"083a":function(t,e,r){"use strict";var n=r("0d51"),a=TypeError;t.exports=function(t,e){if(!delete t[e])throw new a("Cannot delete property "+n(e)+" of "+n(t))}},"0840":function(t,e,r){var n=r("24fb");e=n(!1),e.push([t.i,".vc-svg-icon[data-v-63f7b5ec]{display:inline-block;stroke:currentColor;stroke-width:0}.vc-svg-icon path[data-v-63f7b5ec]{fill:currentColor}",""]),t.exports=e},"087d":function(t,e){function r(t,e){var r=-1,n=e.length,a=t.length;while(++r<n)t[a+r]=e[r];return t}t.exports=r},"08cc":function(t,e,r){var n=r("1a8c");function a(t){return t===t&&!n(t)}t.exports=a},"0b07":function(t,e,r){var n=r("34ac"),a=r("3698");function o(t,e){var r=a(t,e);return n(r)?r:void 0}t.exports=o},"0cfb":function(t,e,r){"use strict";var n=r("83ab"),a=r("d039"),o=r("cc12");t.exports=!n&&!a((function(){return 7!==Object.defineProperty(o("div"),"a",{get:function(){return 7}}).a}))},"0d24":function(t,e,r){(function(t){var n=r("2b3e"),a=r("07c7"),o=e&&!e.nodeType&&e,i=o&&"object"==typeof t&&t&&!t.nodeType&&t,s=i&&i.exports===o,c=s?n.Buffer:void 0,u=c?c.isBuffer:void 0,l=u||a;t.exports=l}).call(this,r("62e4")(t))},"0d26":function(t,e,r){"use strict";var n=r("e330"),a=Error,o=n("".replace),i=function(t){return String(new a(t).stack)}("zxcasd"),s=/\n\s*at [^:]*:[^\n]*/,c=s.test(i);t.exports=function(t,e){if(c&&"string"==typeof t&&!a.prepareStackTrace)while(e--)t=o(t,s,"");return t}},"0d51":function(t,e,r){"use strict";var n=String;t.exports=function(t){try{return n(t)}catch(e){return"Object"}}},"0f0f":function(t,e,r){var n=r("8eeb"),a=r("9934");function o(t,e){return t&&n(e,a(e),t)}t.exports=o},"0f5c":function(t,e,r){var n=r("159a");function a(t,e,r){return null==t?t:n(t,e,r)}t.exports=a},"0f62":function(t,e,r){var n=r("24fb");e=n(!1),e.push([t.i,".vc-pane-container{width:100%;position:relative}.vc-pane-container.in-transition{overflow:hidden}.vc-pane-layout{display:grid}.vc-arrow{display:flex;justify-content:center;align-items:center;cursor:pointer;-webkit-user-select:none;user-select:none;pointer-events:auto;color:var(--gray-600);border-width:2px;border-style:solid;border-radius:var(--rounded);border-color:transparent}.vc-arrow:hover{background:var(--gray-200)}.vc-arrow:focus{border-color:var(--gray-300)}.vc-arrow.is-disabled{opacity:.25;pointer-events:none;cursor:not-allowed}.vc-day-popover-container{color:var(--white);background-color:var(--gray-800);border:1px solid;border-color:var(--gray-700);border-radius:var(--rounded);font-size:var(--text-xs);font-weight:var(--font-medium);padding:4px 8px;box-shadow:var(--shadow)}.vc-day-popover-header{font-size:var(--text-xs);color:var(--gray-300);font-weight:var(--font-semibold);text-align:center}.vc-arrows-container{width:100%;position:absolute;top:0;display:flex;justify-content:space-between;padding:8px 10px;pointer-events:none}.vc-arrows-container.title-left{justify-content:flex-end}.vc-arrows-container.title-right{justify-content:flex-start}.vc-is-dark .vc-arrow{color:var(--white)}.vc-is-dark .vc-arrow:hover{background:var(--gray-800)}.vc-is-dark .vc-arrow:focus{border-color:var(--gray-700)}.vc-is-dark .vc-day-popover-container{color:var(--gray-800);background-color:var(--white);border-color:var(--gray-100)}.vc-is-dark .vc-day-popover-header{color:var(--gray-700)}",""]),t.exports=e},"100e":function(t,e,r){var n=r("cd9d"),a=r("2286"),o=r("c1c9");function i(t,e){return o(a(t,e,n),t+"")}t.exports=i},1041:function(t,e,r){var n=r("8eeb"),a=r("a029");function o(t,e){return n(t,a(t),e)}t.exports=o},"116a":function(t,e,r){var n=r("24fb");e=n(!1),e.push([t.i,".none-enter-active[data-v-5be4b00c],.none-leave-active[data-v-5be4b00c]{transition-duration:0s}.fade-enter-active[data-v-5be4b00c],.fade-leave-active[data-v-5be4b00c],.slide-down-enter-active[data-v-5be4b00c],.slide-down-leave-active[data-v-5be4b00c],.slide-left-enter-active[data-v-5be4b00c],.slide-left-leave-active[data-v-5be4b00c],.slide-right-enter-active[data-v-5be4b00c],.slide-right-leave-active[data-v-5be4b00c],.slide-up-enter-active[data-v-5be4b00c],.slide-up-leave-active[data-v-5be4b00c]{transition:transform var(--slide-duration) var(--slide-timing),opacity var(--slide-duration) var(--slide-timing);backface-visibility:hidden}.fade-leave-active[data-v-5be4b00c],.none-leave-active[data-v-5be4b00c],.slide-down-leave-active[data-v-5be4b00c],.slide-left-leave-active[data-v-5be4b00c],.slide-right-leave-active[data-v-5be4b00c],.slide-up-leave-active[data-v-5be4b00c]{position:absolute;width:100%}.fade-enter[data-v-5be4b00c],.fade-leave-to[data-v-5be4b00c],.none-enter[data-v-5be4b00c],.none-leave-to[data-v-5be4b00c],.slide-down-enter[data-v-5be4b00c],.slide-down-leave-to[data-v-5be4b00c],.slide-left-enter[data-v-5be4b00c],.slide-left-leave-to[data-v-5be4b00c],.slide-right-enter[data-v-5be4b00c],.slide-right-leave-to[data-v-5be4b00c],.slide-up-enter[data-v-5be4b00c],.slide-up-leave-to[data-v-5be4b00c]{opacity:0}.slide-left-enter[data-v-5be4b00c],.slide-right-leave-to[data-v-5be4b00c]{transform:translateX(var(--slide-translate))}.slide-left-leave-to[data-v-5be4b00c],.slide-right-enter[data-v-5be4b00c]{transform:translateX(calc(var(--slide-translate)*-1))}.slide-down-leave-to[data-v-5be4b00c],.slide-up-enter[data-v-5be4b00c]{transform:translateY(var(--slide-translate))}.slide-down-enter[data-v-5be4b00c],.slide-up-leave-to[data-v-5be4b00c]{transform:translateY(calc(var(--slide-translate)*-1))}",""]),t.exports=e},1205:function(t,e,r){var n=r("b7f0");n.__esModule&&(n=n.default),"string"===typeof n&&(n=[[t.i,n,""]]),n.locals&&(t.exports=n.locals);var a=r("499e").default;a("181b238b",n,!0,{sourceMap:!1,shadowMode:!1})},1290:function(t,e){function r(t){var e=typeof t;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==t:null===t}t.exports=r},1310:function(t,e){function r(t){return null!=t&&"object"==typeof t}t.exports=r},1315:function(t,e,r){"use strict";r.d(e,"a",(function(){return d}));r("13d5");var n=r("8bbf"),a=r.n(n),o=r("9404");function i(t){return Object(o["n"])(t)&&(t={min:t}),Object(o["h"])(t)||(t=[t]),t.map((function(t){return Object(o["e"])(t,"raw")?t.raw:Object(o["q"])(t,(function(t,e){return e=Object(o["d"])({min:"min-width",max:"max-width"},e,e),`(${e}: ${t})`})).join(" and ")})).join(", ")}var s=r("85a9");let c=!1,u=!1,l=null;function d(t=s,e){l&&!e||c||(c=!0,u=!0,l=new a.a({data(){return{matches:[],queries:[]}},methods:{refreshQueries(){var e=this;window&&window.matchMedia&&(this.queries=Object(o["r"])(t,(function(t){const r=window.matchMedia(i(t));return Object(o["k"])(r.addEventListener)?r.addEventListener("change",e.refreshMatches):r.addListener(e.refreshMatches),r})),this.refreshMatches())},refreshMatches(){this.matches=Object(o["w"])(this.queries).filter((function(t){return t[1].matches})).map((function(t){return t[0]}))}}}),c=!1)}a.a.mixin({beforeCreate(){c||d()},mounted(){u&&l&&(l.refreshQueries(),u=!1)},computed:{$screens(){return function(t,e){return l.matches.reduce((function(e,r){return Object(o["e"])(t,r)?t[r]:e}),Object(o["o"])(e)?t.default:e)}}}})},1368:function(t,e,r){var n=r("da03"),a=function(){var t=/[^.]+$/.exec(n&&n.keys&&n.keys.IE_PROTO||"");return t?"Symbol(src)_1."+t:""}();function o(t){return!!a&&a in t}t.exports=o},"13d2":function(t,e,r){"use strict";var n=r("e330"),a=r("d039"),o=r("1626"),i=r("1a2d"),s=r("83ab"),c=r("5e77").CONFIGURABLE,u=r("8925"),l=r("69f3"),d=l.enforce,f=l.get,p=String,h=Object.defineProperty,v=n("".slice),b=n("".replace),m=n([].join),g=s&&!a((function(){return 8!==h((function(){}),"length",{value:8}).length})),y=String(String).split("String"),w=t.exports=function(t,e,r){"Symbol("===v(p(e),0,7)&&(e="["+b(p(e),/^Symbol\(([^)]*)\)/,"$1")+"]"),r&&r.getter&&(e="get "+e),r&&r.setter&&(e="set "+e),(!i(t,"name")||c&&t.name!==e)&&(s?h(t,"name",{value:e,configurable:!0}):t.name=e),g&&r&&i(r,"arity")&&t.length!==r.arity&&h(t,"length",{value:r.arity});try{r&&i(r,"constructor")&&r.constructor?s&&h(t,"prototype",{writable:!1}):t.prototype&&(t.prototype=void 0)}catch(a){}var n=d(t);return i(n,"source")||(n.source=m(y,"string"==typeof e?e:"")),t};Function.prototype.toString=w((function(){return o(this)&&f(this).source||u(this)}),"toString")},"13d5":function(t,e,r){"use strict";var n=r("23e7"),a=r("d58f").left,o=r("a640"),i=r("2d00"),s=r("605d"),c=!s&&i>79&&i<83,u=c||!o("reduce");n({target:"Array",proto:!0,forced:u},{reduce:function(t){var e=arguments.length;return a(this,t,e,e>1?arguments[1]:void 0)}})},"14d9":function(t,e,r){"use strict";var n=r("23e7"),a=r("7b0b"),o=r("07fa"),i=r("3a34"),s=r("3511"),c=r("d039"),u=c((function(){return 4294967297!==[].push.call({length:4294967296},1)})),l=function(){try{Object.defineProperty([],"length",{writable:!1}).push()}catch(t){return t instanceof TypeError}},d=u||!l();n({target:"Array",proto:!0,arity:1,forced:d},{push:function(t){var e=a(this),r=o(e),n=arguments.length;s(r+n);for(var c=0;c<n;c++)e[r]=arguments[c],r++;return i(e,r),r}})},"159a":function(t,e,r){var n=r("32b3"),a=r("e2e4"),o=r("c098"),i=r("1a8c"),s=r("f4d6");function c(t,e,r,c){if(!i(t))return t;e=a(e,t);var u=-1,l=e.length,d=l-1,f=t;while(null!=f&&++u<l){var p=s(e[u]),h=r;if("__proto__"===p||"constructor"===p||"prototype"===p)return t;if(u!=d){var v=f[p];h=c?c(v,p,f):void 0,void 0===h&&(h=i(v)?v:o(e[u+1])?[]:{})}n(f,p,h),f=f[p]}return t}t.exports=c},"15f3":function(t,e,r){var n=r("89d9"),a=r("8604");function o(t,e){return n(t,e,(function(e,r){return a(t,r)}))}t.exports=o},1626:function(t,e,r){"use strict";var n=r("8ea1"),a=n.all;t.exports=n.IS_HTMLDDA?function(t){return"function"==typeof t||t===a}:function(t){return"function"==typeof t}},1838:function(t,e,r){var n=r("c05f"),a=r("9b02"),o=r("8604"),i=r("f608"),s=r("08cc"),c=r("20ec"),u=r("f4d6"),l=1,d=2;function f(t,e){return i(t)&&s(e)?c(u(t),e):function(r){var i=a(r,t);return void 0===i&&i===e?o(r,t):n(e,i,l|d)}}t.exports=f},"18d8":function(t,e,r){var n=r("234d"),a=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,o=/\\(\\)?/g,i=n((function(t){var e=[];return 46===t.charCodeAt(0)&&e.push(""),t.replace(a,(function(t,r,n,a){e.push(n?a.replace(o,"$1"):r||t)})),e}));t.exports=i},"1a2d":function(t,e,r){"use strict";var n=r("e330"),a=r("7b0b"),o=n({}.hasOwnProperty);t.exports=Object.hasOwn||function(t,e){return o(a(t),e)}},"1a2d0":function(t,e,r){var n=r("42a2"),a=r("1310"),o="[object Map]";function i(t){return a(t)&&n(t)==o}t.exports=i},"1a8c":function(t,e){function r(t){var e=typeof t;return null!=t&&("object"==e||"function"==e)}t.exports=r},"1bac":function(t,e,r){var n=r("7d1f"),a=r("a029"),o=r("9934");function i(t){return n(t,o,a)}t.exports=i},"1c3c":function(t,e,r){var n=r("9e69"),a=r("2474"),o=r("9638"),i=r("a2be"),s=r("edfa"),c=r("ac41"),u=1,l=2,d="[object Boolean]",f="[object Date]",p="[object Error]",h="[object Map]",v="[object Number]",b="[object RegExp]",m="[object Set]",g="[object String]",y="[object Symbol]",w="[object ArrayBuffer]",x="[object DataView]",D=n?n.prototype:void 0,O=D?D.valueOf:void 0;function j(t,e,r,n,D,j,k){switch(r){case x:if(t.byteLength!=e.byteLength||t.byteOffset!=e.byteOffset)return!1;t=t.buffer,e=e.buffer;case w:return!(t.byteLength!=e.byteLength||!j(new a(t),new a(e)));case d:case f:case v:return o(+t,+e);case p:return t.name==e.name&&t.message==e.message;case b:case g:return t==e+"";case h:var M=s;case m:var P=n&u;if(M||(M=c),t.size!=e.size&&!P)return!1;var Y=k.get(t);if(Y)return Y==e;n|=l,k.set(t,e);var S=i(M(t),M(e),n,D,j,k);return k["delete"](t),S;case y:if(O)return O.call(t)==O.call(e)}return!1}t.exports=j},"1c6b":function(t,e,r){"use strict";r("7d87")},"1cec":function(t,e,r){var n=r("0b07"),a=r("2b3e"),o=n(a,"Promise");t.exports=o},"1d80":function(t,e,r){"use strict";var n=r("7234"),a=TypeError;t.exports=function(t){if(n(t))throw new a("Can't call method on "+t);return t}},"1efc":function(t,e){function r(t){var e=this.has(t)&&delete this.__data__[t];return this.size-=e?1:0,e}t.exports=r},"1fc8":function(t,e,r){var n=r("4245");function a(t,e){var r=n(this,t),a=r.size;return r.set(t,e),this.size+=r.size==a?0:1,this}t.exports=a},"20ec":function(t,e){function r(t,e){return function(r){return null!=r&&(r[t]===e&&(void 0!==e||t in Object(r)))}}t.exports=r},2286:function(t,e,r){var n=r("85e3"),a=Math.max;function o(t,e,r){return e=a(void 0===e?t.length-1:e,0),function(){var o=arguments,i=-1,s=a(o.length-e,0),c=Array(s);while(++i<s)c[i]=o[e+i];i=-1;var u=Array(e+1);while(++i<e)u[i]=o[i];return u[e]=r(c),n(t,this,u)}}t.exports=o},"22f3":function(t,e,r){"use strict";r.d(e,"a",(function(){return i}));r("14d9");var n=r("cfe5"),a=r("2fa3"),o=r("9404");class i{constructor({key:t,hashcode:e,highlight:r,content:i,dot:s,bar:c,popover:u,dates:l,excludeDates:d,excludeMode:f,customData:p,order:h,pinPage:v},b,m){this.key=Object(o["o"])(t)?Object(a["c"])():t,this.hashcode=e,this.customData=p,this.order=h||0,this.dateOpts={order:h,locale:m},this.pinPage=v,r&&(this.highlight=b.normalizeHighlight(r)),i&&(this.content=b.normalizeContent(i)),s&&(this.dot=b.normalizeDot(s)),c&&(this.bar=b.normalizeBar(c)),u&&(this.popover=u),this.dates=m.normalizeDates(l,this.dateOpts),this.hasDates=!!Object(a["b"])(this.dates),this.excludeDates=m.normalizeDates(d,this.dateOpts),this.hasExcludeDates=!!Object(a["b"])(this.excludeDates),this.excludeMode=f||"intersects",this.hasExcludeDates&&!this.hasDates&&(this.dates.push(new n["a"]({},this.dateOpts)),this.hasDates=!0),this.isComplex=Object(o["v"])(this.dates,(function(t){return t.isComplex}))}intersectsDate(t){return t=t instanceof n["a"]?t:new n["a"](t,this.dateOpts),!this.excludesDate(t)&&(this.dates.find((function(e){return e.intersectsDate(t)}))||!1)}includesDate(t){return t=t instanceof n["a"]?t:new n["a"](t,this.dateOpts),!this.excludesDate(t)&&(this.dates.find((function(e){return e.includesDate(t)}))||!1)}excludesDate(t){var e=this;return t=t instanceof n["a"]?t:new n["a"](t,this.dateOpts),this.hasExcludeDates&&this.excludeDates.find((function(r){return"intersects"===e.excludeMode&&r.intersectsDate(t)||"includes"===e.excludeMode&&r.includesDate(t)}))}intersectsDay(t){return!this.excludesDay(t)&&(this.dates.find((function(e){return e.intersectsDay(t)}))||!1)}excludesDay(t){return this.hasExcludeDates&&this.excludeDates.find((function(e){return e.intersectsDay(t)}))}}},"234d":function(t,e,r){var n=r("e380"),a=500;function o(t){var e=n(t,(function(t){return r.size===a&&r.clear(),t})),r=e.cache;return e}t.exports=o},"23a5":function(t){t.exports=JSON.parse('{"maxSwipeTime":300,"minHorizontalSwipeDistance":60,"maxVerticalSwipeDistance":80}')},"23cb":function(t,e,r){"use strict";var n=r("5926"),a=Math.max,o=Math.min;t.exports=function(t,e){var r=n(t);return r<0?a(r+e,0):o(r,e)}},"23da":function(t,e,r){var n=r("3963");n.__esModule&&(n=n.default),"string"===typeof n&&(n=[[t.i,n,""]]),n.locals&&(t.exports=n.locals);var a=r("499e").default;a("9371b050",n,!0,{sourceMap:!1,shadowMode:!1})},"23e7":function(t,e,r){"use strict";var n=r("da84"),a=r("06cf").f,o=r("9112"),i=r("cb2d"),s=r("6374"),c=r("e893"),u=r("94ca");t.exports=function(t,e){var r,l,d,f,p,h,v=t.target,b=t.global,m=t.stat;if(l=b?n:m?n[v]||s(v,{}):(n[v]||{}).prototype,l)for(d in e){if(p=e[d],t.dontCallGetSet?(h=a(l,d),f=h&&h.value):f=l[d],r=u(b?d:v+(m?".":"#")+d,t.forced),!r&&void 0!==f){if(typeof p==typeof f)continue;c(p,f)}(t.sham||f&&f.sham)&&o(p,"sham",!0),i(l,d,p,t)}}},2411:function(t,e,r){var n=r("f909"),a=r("2ec1"),o=a((function(t,e,r,a){n(t,e,r,a)}));t.exports=o},"241c":function(t,e,r){"use strict";var n=r("ca84"),a=r("7839"),o=a.concat("length","prototype");e.f=Object.getOwnPropertyNames||function(t){return n(t,o)}},"242e":function(t,e,r){var n=r("72af"),a=r("ec69");function o(t,e){return t&&n(t,e,a)}t.exports=o},2474:function(t,e,r){var n=r("2b3e"),a=n.Uint8Array;t.exports=a},2478:function(t,e,r){var n=r("4245");function a(t){return n(this,t).get(t)}t.exports=a},"24fb":function(t,e,r){"use strict";function n(t,e){var r=t[1]||"",n=t[3];if(!n)return r;if(e&&"function"===typeof btoa){var o=a(n),i=n.sources.map((function(t){return"/*# sourceURL=".concat(n.sourceRoot||"").concat(t," */")}));return[r].concat(i).concat([o]).join("\n")}return[r].join("\n")}function a(t){var e=btoa(unescape(encodeURIComponent(JSON.stringify(t)))),r="sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(e);return"/*# ".concat(r," */")}t.exports=function(t){var e=[];return e.toString=function(){return this.map((function(e){var r=n(e,t);return e[2]?"@media ".concat(e[2]," {").concat(r,"}"):r})).join("")},e.i=function(t,r,n){"string"===typeof t&&(t=[[null,t,""]]);var a={};if(n)for(var o=0;o<this.length;o++){var i=this[o][0];null!=i&&(a[i]=!0)}for(var s=0;s<t.length;s++){var c=[].concat(t[s]);n&&a[c[0]]||(r&&(c[2]?c[2]="".concat(r," and ").concat(c[2]):c[2]=r),e.push(c))}},e}},2524:function(t,e,r){var n=r("6044"),a="__lodash_hash_undefined__";function o(t,e){var r=this.__data__;return this.size+=this.has(t)?0:1,r[t]=n&&void 0===e?a:e,this}t.exports=o},"253c":function(t,e,r){var n=r("3729"),a=r("1310"),o="[object Arguments]";function i(t){return a(t)&&n(t)==o}t.exports=i},2593:function(t,e,r){var n=r("15f3"),a=r("c6cf"),o=a((function(t,e){return null==t?{}:n(t,e)}));t.exports=o},"26e8":function(t,e){function r(t,e){return null!=t&&e in Object(t)}t.exports=r},2745:function(t,e,r){"use strict";r("5332")},"28c9":function(t,e){function r(){this.__data__=[],this.size=0}t.exports=r},"29ae":function(t,e,r){"use strict";r.d(e,"a",(function(){return vt})),r.d(e,"b",(function(){return Tt}));r("14d9"),r("d9e2"),r("13d5");var n=r("2cfd"),a=r.n(n),o=r("5465"),i=r.n(o);function s(t,e){var r=f(e);return r.formatToParts?u(r,t):l(r,t)}var c={year:0,month:1,day:2,hour:3,minute:4,second:5};function u(t,e){try{for(var r=t.formatToParts(e),n=[],a=0;a<r.length;a++){var o=c[r[a].type];o>=0&&(n[o]=parseInt(r[a].value,10))}return n}catch(i){if(i instanceof RangeError)return[NaN];throw i}}function l(t,e){var r=t.format(e).replace(/\u200E/g,""),n=/(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(r);return[n[3],n[1],n[2],n[4],n[5],n[6]]}var d={};function f(t){if(!d[t]){var e=new Intl.DateTimeFormat("en-US",{hour12:!1,timeZone:"America/New_York",year:"numeric",month:"numeric",day:"2-digit",hour:"2-digit",minute:"2-digit",second:"2-digit"}).format(new Date("2014-06-25T04:00:00.123Z")),r="06/25/2014, 00:00:00"===e||"‎06‎/‎25‎/‎2014‎ ‎00‎:‎00‎:‎00"===e;d[t]=r?new Intl.DateTimeFormat("en-US",{hour12:!1,timeZone:t,year:"numeric",month:"numeric",day:"2-digit",hour:"2-digit",minute:"2-digit",second:"2-digit"}):new Intl.DateTimeFormat("en-US",{hourCycle:"h23",timeZone:t,year:"numeric",month:"numeric",day:"2-digit",hour:"2-digit",minute:"2-digit",second:"2-digit"})}return d[t]}function p(t,e,r,n,a,o,i){var s=new Date(0);return s.setUTCFullYear(t,e,r),s.setUTCHours(n,a,o,i),s}var h=36e5,v=6e4,b={timezone:/([Z+-].*)$/,timezoneZ:/^(Z)$/,timezoneHH:/^([+-]\d{2})$/,timezoneHHMM:/^([+-]\d{2}):?(\d{2})$/};function m(t,e,r){var n,a,o;if(!t)return 0;if(n=b.timezoneZ.exec(t),n)return 0;if(n=b.timezoneHH.exec(t),n)return o=parseInt(n[1],10),x(o)?-o*h:NaN;if(n=b.timezoneHHMM.exec(t),n){o=parseInt(n[1],10);var i=parseInt(n[2],10);return x(o,i)?(a=Math.abs(o)*h+i*v,o>0?-a:a):NaN}if(O(t)){e=new Date(e||Date.now());var s=r?e:g(e),c=y(s,t),u=r?c:w(e,c,t);return-u}return NaN}function g(t){return p(t.getFullYear(),t.getMonth(),t.getDate(),t.getHours(),t.getMinutes(),t.getSeconds(),t.getMilliseconds())}function y(t,e){var r=s(t,e),n=p(r[0],r[1]-1,r[2],r[3]%24,r[4],r[5],0).getTime(),a=t.getTime(),o=a%1e3;return a-=o>=0?o:1e3+o,n-a}function w(t,e,r){var n=t.getTime(),a=n-e,o=y(new Date(a),r);if(e===o)return e;a-=o-e;var i=y(new Date(a),r);return o===i?o:Math.max(o,i)}function x(t,e){return-23<=t&&t<=23&&(null==e||0<=e&&e<=59)}var D={};function O(t){if(D[t])return!0;try{return new Intl.DateTimeFormat(void 0,{timeZone:t}),D[t]=!0,!0}catch(e){return!1}}var j=/(Z|[+-]\d{2}(?::?\d{2})?| UTC| [a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?)$/,k=j,M=36e5,P=6e4,Y=2,S={dateTimePattern:/^([0-9W+-]+)(T| )(.*)/,datePattern:/^([0-9W+-]+)(.*)/,plainTime:/:/,YY:/^(\d{2})$/,YYY:[/^([+-]\d{2})$/,/^([+-]\d{3})$/,/^([+-]\d{4})$/],YYYY:/^(\d{4})/,YYYYY:[/^([+-]\d{4})/,/^([+-]\d{5})/,/^([+-]\d{6})/],MM:/^-(\d{2})$/,DDD:/^-?(\d{3})$/,MMDD:/^-?(\d{2})-?(\d{2})$/,Www:/^-?W(\d{2})$/,WwwD:/^-?W(\d{2})-?(\d{1})$/,HH:/^(\d{2}([.,]\d*)?)$/,HHMM:/^(\d{2}):?(\d{2}([.,]\d*)?)$/,HHMMSS:/^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,timeZone:k};function _(t,e){if(arguments.length<1)throw new TypeError("1 argument required, but only "+arguments.length+" present");if(null===t)return new Date(NaN);var r=e||{},n=null==r.additionalDigits?Y:a()(r.additionalDigits);if(2!==n&&1!==n&&0!==n)throw new RangeError("additionalDigits must be 0, 1 or 2");if(t instanceof Date||"object"===typeof t&&"[object Date]"===Object.prototype.toString.call(t))return new Date(t.getTime());if("number"===typeof t||"[object Number]"===Object.prototype.toString.call(t))return new Date(t);if("string"!==typeof t&&"[object String]"!==Object.prototype.toString.call(t))return new Date(NaN);var o=E(t),s=T(o.date,n),c=s.year,u=s.restDateString,l=I(u,c);if(isNaN(l))return new Date(NaN);if(l){var d,f=l.getTime(),p=0;if(o.time&&(p=C(o.time),isNaN(p)))return new Date(NaN);if(o.timeZone||r.timeZone){if(d=m(o.timeZone||r.timeZone,new Date(f+p)),isNaN(d))return new Date(NaN)}else d=i()(new Date(f+p)),d=i()(new Date(f+p+d));return new Date(f+p+d)}return new Date(NaN)}function E(t){var e,r={},n=S.dateTimePattern.exec(t);if(n?(r.date=n[1],e=n[3]):(n=S.datePattern.exec(t),n?(r.date=n[1],e=n[2]):(r.date=null,e=t)),e){var a=S.timeZone.exec(e);a?(r.time=e.replace(a[1],""),r.timeZone=a[1].trim()):r.time=e}return r}function T(t,e){var r,n=S.YYY[e],a=S.YYYYY[e];if(r=S.YYYY.exec(t)||a.exec(t),r){var o=r[1];return{year:parseInt(o,10),restDateString:t.slice(o.length)}}if(r=S.YY.exec(t)||n.exec(t),r){var i=r[1];return{year:100*parseInt(i,10),restDateString:t.slice(i.length)}}return{year:null}}function I(t,e){if(null===e)return null;var r,n,a,o;if(0===t.length)return n=new Date(0),n.setUTCFullYear(e),n;if(r=S.MM.exec(t),r)return n=new Date(0),a=parseInt(r[1],10)-1,z(e,a)?(n.setUTCFullYear(e,a),n):new Date(NaN);if(r=S.DDD.exec(t),r){n=new Date(0);var i=parseInt(r[1],10);return H(e,i)?(n.setUTCFullYear(e,0,i),n):new Date(NaN)}if(r=S.MMDD.exec(t),r){n=new Date(0),a=parseInt(r[1],10)-1;var s=parseInt(r[2],10);return z(e,a,s)?(n.setUTCFullYear(e,a,s),n):new Date(NaN)}if(r=S.Www.exec(t),r)return o=parseInt(r[1],10)-1,L(e,o)?$(e,o):new Date(NaN);if(r=S.WwwD.exec(t),r){o=parseInt(r[1],10)-1;var c=parseInt(r[2],10)-1;return L(e,o,c)?$(e,o,c):new Date(NaN)}return null}function C(t){var e,r,n;if(e=S.HH.exec(t),e)return r=parseFloat(e[1].replace(",",".")),W(r)?r%24*M:NaN;if(e=S.HHMM.exec(t),e)return r=parseInt(e[1],10),n=parseFloat(e[2].replace(",",".")),W(r,n)?r%24*M+n*P:NaN;if(e=S.HHMMSS.exec(t),e){r=parseInt(e[1],10),n=parseInt(e[2],10);var a=parseFloat(e[3].replace(",","."));return W(r,n,a)?r%24*M+n*P+1e3*a:NaN}return null}function $(t,e,r){e=e||0,r=r||0;var n=new Date(0);n.setUTCFullYear(t,0,4);var a=n.getUTCDay()||7,o=7*e+r+1-a;return n.setUTCDate(n.getUTCDate()+o),n}var A=[31,28,31,30,31,30,31,31,30,31,30,31],N=[31,29,31,30,31,30,31,31,30,31,30,31];function F(t){return t%400===0||t%4===0&&t%100!==0}function z(t,e,r){if(e<0||e>11)return!1;if(null!=r){if(r<1)return!1;var n=F(t);if(n&&r>N[e])return!1;if(!n&&r>A[e])return!1}return!0}function H(t,e){if(e<1)return!1;var r=F(t);return!(r&&e>366)&&!(!r&&e>365)}function L(t,e,r){return!(e<0||e>52)&&(null==r||!(r<0||r>6))}function W(t,e,r){return(null==t||!(t<0||t>=25))&&((null==e||!(e<0||e>=60))&&(null==r||!(r<0||r>=60)))}var V=r("fd3a"),R=r("fe1f"),U=r("8c86"),B={};function Z(){return B}function q(t,e){var r,n,a,o,i,s,c,u;Object(U["a"])(1,arguments);var l=Z(),d=Object(R["a"])(null!==(r=null!==(n=null!==(a=null!==(o=null===e||void 0===e?void 0:e.weekStartsOn)&&void 0!==o?o:null===e||void 0===e||null===(i=e.locale)||void 0===i||null===(s=i.options)||void 0===s?void 0:s.weekStartsOn)&&void 0!==a?a:l.weekStartsOn)&&void 0!==n?n:null===(c=l.locale)||void 0===c||null===(u=c.options)||void 0===u?void 0:u.weekStartsOn)&&void 0!==r?r:0);if(!(d>=0&&d<=6))throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");var f=Object(V["a"])(t),p=f.getDay(),h=(p<d?7:0)+p-d;return f.setDate(f.getDate()-h),f.setHours(0,0,0,0),f}function G(t){return Object(U["a"])(1,arguments),q(t,{weekStartsOn:1})}function K(t){Object(U["a"])(1,arguments);var e=Object(V["a"])(t),r=e.getFullYear(),n=new Date(0);n.setFullYear(r+1,0,4),n.setHours(0,0,0,0);var a=G(n),o=new Date(0);o.setFullYear(r,0,4),o.setHours(0,0,0,0);var i=G(o);return e.getTime()>=a.getTime()?r+1:e.getTime()>=i.getTime()?r:r-1}function X(t){Object(U["a"])(1,arguments);var e=K(t),r=new Date(0);r.setFullYear(e,0,4),r.setHours(0,0,0,0);var n=G(r);return n}var J=6048e5;function Q(t){Object(U["a"])(1,arguments);var e=Object(V["a"])(t),r=G(e).getTime()-X(e).getTime();return Math.round(r/J)+1}function tt(t,e){var r,n,a,o,i,s,c,u;Object(U["a"])(1,arguments);var l=Object(V["a"])(t),d=l.getFullYear(),f=Z(),p=Object(R["a"])(null!==(r=null!==(n=null!==(a=null!==(o=null===e||void 0===e?void 0:e.firstWeekContainsDate)&&void 0!==o?o:null===e||void 0===e||null===(i=e.locale)||void 0===i||null===(s=i.options)||void 0===s?void 0:s.firstWeekContainsDate)&&void 0!==a?a:f.firstWeekContainsDate)&&void 0!==n?n:null===(c=f.locale)||void 0===c||null===(u=c.options)||void 0===u?void 0:u.firstWeekContainsDate)&&void 0!==r?r:1);if(!(p>=1&&p<=7))throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");var h=new Date(0);h.setFullYear(d+1,0,p),h.setHours(0,0,0,0);var v=q(h,e),b=new Date(0);b.setFullYear(d,0,p),b.setHours(0,0,0,0);var m=q(b,e);return l.getTime()>=v.getTime()?d+1:l.getTime()>=m.getTime()?d:d-1}function et(t,e){var r,n,a,o,i,s,c,u;Object(U["a"])(1,arguments);var l=Z(),d=Object(R["a"])(null!==(r=null!==(n=null!==(a=null!==(o=null===e||void 0===e?void 0:e.firstWeekContainsDate)&&void 0!==o?o:null===e||void 0===e||null===(i=e.locale)||void 0===i||null===(s=i.options)||void 0===s?void 0:s.firstWeekContainsDate)&&void 0!==a?a:l.firstWeekContainsDate)&&void 0!==n?n:null===(c=l.locale)||void 0===c||null===(u=c.options)||void 0===u?void 0:u.firstWeekContainsDate)&&void 0!==r?r:1),f=tt(t,e),p=new Date(0);p.setFullYear(f,0,d),p.setHours(0,0,0,0);var h=q(p,e);return h}var rt=6048e5;function nt(t,e){Object(U["a"])(1,arguments);var r=Object(V["a"])(t),n=q(r,e).getTime()-et(r,e).getTime();return Math.round(n/rt)+1}function at(t){var e=new Date(Date.UTC(t.getFullYear(),t.getMonth(),t.getDate(),t.getHours(),t.getMinutes(),t.getSeconds(),t.getMilliseconds()));return e.setUTCFullYear(t.getFullYear()),t.getTime()-e.getTime()}var ot=6048e5;function it(t,e,r){Object(U["a"])(2,arguments);var n=q(t,r),a=q(e,r),o=n.getTime()-at(n),i=a.getTime()-at(a);return Math.round((o-i)/ot)}function st(t){Object(U["a"])(1,arguments);var e=Object(V["a"])(t),r=e.getMonth();return e.setFullYear(e.getFullYear(),r+1,0),e.setHours(0,0,0,0),e}function ct(t){Object(U["a"])(1,arguments);var e=Object(V["a"])(t);return e.setDate(1),e.setHours(0,0,0,0),e}function ut(t,e){return Object(U["a"])(1,arguments),it(st(t),ct(t),e)+1}var lt=r("f7f1"),dt=r("cfe5"),ft=r("f15d"),pt=r("2fa3"),ht=r("9404");const vt={DATE_TIME:1,DATE:2,TIME:3},bt={1:["year","month","day","hours","minutes","seconds","milliseconds"],2:["year","month","day"],3:["hours","minutes","seconds","milliseconds"]},mt=/d{1,2}|W{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|Z{1,4}|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g,gt=/\d\d?/,yt=/\d{3}/,wt=/\d{4}/,xt=/[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF/]+(\s*?[\u0600-\u06FF]+){1,2}/i,Dt=/\[([^]*?)\]/gm,Ot=function(){},jt=function(t){return function(e,r,n){const a=n[t].indexOf(r.charAt(0).toUpperCase()+r.substr(1).toLowerCase());~a&&(e.month=a)}},kt=["L","iso"],Mt=7,Pt=[31,28,31,30,31,30,31,31,30,31,30,31],Yt=[{value:0,label:"00"},{value:1,label:"01"},{value:2,label:"02"},{value:3,label:"03"},{value:4,label:"04"},{value:5,label:"05"},{value:6,label:"06"},{value:7,label:"07"},{value:8,label:"08"},{value:9,label:"09"},{value:10,label:"10"},{value:11,label:"11"},{value:12,label:"12"},{value:13,label:"13"},{value:14,label:"14"},{value:15,label:"15"},{value:16,label:"16"},{value:17,label:"17"},{value:18,label:"18"},{value:19,label:"19"},{value:20,label:"20"},{value:21,label:"21"},{value:22,label:"22"},{value:23,label:"23"}],St={D(t){return t.day},DD(t){return Object(pt["m"])(t.day)},Do(t,e){return e.DoFn(t.day)},d(t){return t.weekday-1},dd(t){return Object(pt["m"])(t.weekday-1)},W(t,e){return e.dayNamesNarrow[t.weekday-1]},WW(t,e){return e.dayNamesShorter[t.weekday-1]},WWW(t,e){return e.dayNamesShort[t.weekday-1]},WWWW(t,e){return e.dayNames[t.weekday-1]},M(t){return t.month},MM(t){return Object(pt["m"])(t.month)},MMM(t,e){return e.monthNamesShort[t.month-1]},MMMM(t,e){return e.monthNames[t.month-1]},YY(t){return String(t.year).substr(2)},YYYY(t){return Object(pt["m"])(t.year,4)},h(t){return t.hours%12||12},hh(t){return Object(pt["m"])(t.hours%12||12)},H(t){return t.hours},HH(t){return Object(pt["m"])(t.hours)},m(t){return t.minutes},mm(t){return Object(pt["m"])(t.minutes)},s(t){return t.seconds},ss(t){return Object(pt["m"])(t.seconds)},S(t){return Math.round(t.milliseconds/100)},SS(t){return Object(pt["m"])(Math.round(t.milliseconds/10),2)},SSS(t){return Object(pt["m"])(t.milliseconds,3)},a(t,e){return t.hours<12?e.amPm[0]:e.amPm[1]},A(t,e){return t.hours<12?e.amPm[0].toUpperCase():e.amPm[1].toUpperCase()},Z(){return"Z"},ZZ(t){const e=t.timezoneOffset;return`${e>0?"-":"+"}${Object(pt["m"])(Math.floor(Math.abs(e)/60),2)}`},ZZZ(t){const e=t.timezoneOffset;return`${e>0?"-":"+"}${Object(pt["m"])(100*Math.floor(Math.abs(e)/60)+Math.abs(e)%60,4)}`},ZZZZ(t){const e=t.timezoneOffset;return`${e>0?"-":"+"}${Object(pt["m"])(Math.floor(Math.abs(e)/60),2)}:${Object(pt["m"])(Math.abs(e)%60,2)}`}},_t={D:[gt,function(t,e){t.day=e}],Do:[new RegExp(gt.source+xt.source),function(t,e){t.day=parseInt(e,10)}],d:[gt,Ot],W:[xt,Ot],M:[gt,function(t,e){t.month=e-1}],MMM:[xt,jt("monthNamesShort")],MMMM:[xt,jt("monthNames")],YY:[gt,function(t,e){const r=new Date,n=+r.getFullYear().toString().substr(0,2);t.year=`${e>68?n-1:n}${e}`}],YYYY:[wt,function(t,e){t.year=e}],S:[/\d/,function(t,e){t.millisecond=100*e}],SS:[/\d{2}/,function(t,e){t.millisecond=10*e}],SSS:[yt,function(t,e){t.millisecond=e}],h:[gt,function(t,e){t.hour=e}],m:[gt,function(t,e){t.minute=e}],s:[gt,function(t,e){t.second=e}],a:[xt,function(t,e,r){const n=e.toLowerCase();n===r.amPm[0]?t.isPm=!1:n===r.amPm[1]&&(t.isPm=!0)}],Z:[/[^\s]*?[+-]\d\d:?\d\d|[^\s]*?Z?/,function(t,e){"Z"===e&&(e="+00:00");const r=(""+e).match(/([+-]|\d\d)/gi);if(r){const e=60*r[1]+parseInt(r[2],10);t.timezoneOffset="+"===r[0]?e:-e}}]};function Et(t,e){const r=(new Intl.DateTimeFormat).resolvedOptions().locale;let n;Object(ht["n"])(t)?n=t:Object(ht["e"])(t,"id")&&(n=t.id),n=(n||r).toLowerCase();const a=Object.keys(e),o=function(t){return a.find((function(e){return e.toLowerCase()===t}))};n=o(n)||o(n.substring(0,2))||r;const i={...e["en-IE"],...e[n],id:n};return t=Object(ht["m"])(t)?Object(ht["c"])(t,i):i,t}_t.DD=_t.D,_t.dd=_t.d,_t.WWWW=_t.WWW=_t.WW=_t.W,_t.MM=_t.M,_t.mm=_t.m,_t.hh=_t.H=_t.HH=_t.h,_t.ss=_t.s,_t.A=_t.a,_t.ZZZZ=_t.ZZZ=_t.ZZ=_t.Z;class Tt{constructor(t,{locales:e=ft["a"],timezone:r}={}){const{id:n,firstDayOfWeek:a,masks:o}=Et(t,e);this.id=n,this.daysInWeek=Mt,this.firstDayOfWeek=Object(ht["a"])(a,1,Mt),this.masks=o,this.timezone=r||void 0,this.dayNames=this.getDayNames("long"),this.dayNamesShort=this.getDayNames("short"),this.dayNamesShorter=this.dayNamesShort.map((function(t){return t.substring(0,2)})),this.dayNamesNarrow=this.getDayNames("narrow"),this.monthNames=this.getMonthNames("long"),this.monthNamesShort=this.getMonthNames("short"),this.amPm=["am","pm"],this.monthData={},this.getMonthComps=this.getMonthComps.bind(this),this.parse=this.parse.bind(this),this.format=this.format.bind(this),this.toPage=this.toPage.bind(this)}format(t,e){var r=this;if(t=this.normalizeDate(t),!t)return"";e=this.normalizeMasks(e)[0];const n=[];e=e.replace(Dt,(function(t,e){return n.push(e),"??"}));const a=/Z$/.test(e)?"utc":this.timezone,o=this.getDateParts(t,a);return e=e.replace(mt,(function(t){return t in St?St[t](o,r):t.slice(1,t.length-1)})),e.replace(/\?\?/g,(function(){return n.shift()}))}parse(t,e){var r=this;const n=this.normalizeMasks(e);return n.map((function(e){if("string"!==typeof e)throw new Error("Invalid mask in fecha.parse");let n=t;if(n.length>1e3)return!1;let a=!0;const o={};if(e.replace(mt,(function(t){if(_t[t]){const e=_t[t],i=n.search(e[0]);~i?n.replace(e[0],(function(t){return e[1](o,t,r),n=n.substr(i+t.length),t})):a=!1}return _t[t]?"":t.slice(1,t.length-1)})),!a)return!1;const i=new Date;let s;return!0===o.isPm&&null!=o.hour&&12!==+o.hour?o.hour=+o.hour+12:!1===o.isPm&&12===+o.hour&&(o.hour=0),null!=o.timezoneOffset?(o.minute=+(o.minute||0)-+o.timezoneOffset,s=new Date(Date.UTC(o.year||i.getFullYear(),o.month||0,o.day||1,o.hour||0,o.minute||0,o.second||0,o.millisecond||0))):s=r.getDateFromParts({year:o.year||i.getFullYear(),month:(o.month||0)+1,day:o.day||1,hours:o.hour||0,minutes:o.minute||0,seconds:o.second||0,milliseconds:o.millisecond||0}),s})).find((function(t){return t}))||new Date(t)}normalizeMasks(t){var e=this;return(Object(pt["b"])(t)&&t||[Object(ht["n"])(t)&&t||"YYYY-MM-DD"]).map((function(t){return kt.reduce((function(t,r){return t.replace(r,e.masks[r]||"")}),t)}))}normalizeDate(t,e={}){let r=null,{type:n,fillDate:a}=e;const{mask:o,patch:i,time:s}=e,c="auto"===n||!n;if(Object(ht["l"])(t)?(n="number",r=new Date(+t)):Object(ht["n"])(t)?(n="string",r=t?this.parse(t,o||"iso"):null):Object(ht["m"])(t)?(n="object",r=this.getDateFromParts(t)):(n="date",r=Object(ht["j"])(t)?new Date(t.getTime()):null),r&&i){a=null==a?new Date:this.normalizeDate(a);const t={...this.getDateParts(a),...Object(ht["t"])(this.getDateParts(r),bt[i])};r=this.getDateFromParts(t)}return c&&(e.type=n),r&&!isNaN(r.getTime())?(s&&(r=this.adjustTimeForDate(r,{timeAdjust:s})),r):null}denormalizeDate(t,{type:e,mask:r}={}){switch(e){case"number":return t?t.getTime():NaN;case"string":return t?this.format(t,r||"iso"):"";default:return t?new Date(t):null}}hourIsValid(t,e,r){if(!e)return!0;if(Object(ht["h"])(e))return e.includes(t);if(Object(ht["m"])(e)){const r=e.min||0,n=e.max||24;return r<=t&&n>=t}return e(t,r)}getHourOptions(t,e){var r=this;return Yt.filter((function(n){return r.hourIsValid(n.value,t,e)}))}getMinuteOptions(t){const e=[];t=t>0?t:1;for(let r=0;r<=59;r+=t)e.push({value:r,label:Object(pt["m"])(r,2)});return e}nearestOptionValue(t,e){if(null==t)return t;const r=e.reduce((function(e,r){if(r.disabled)return e;if(isNaN(e))return r.value;const n=Math.abs(e-t),a=Math.abs(r.value-t);return a<n?r.value:e}),NaN);return isNaN(r)?t:r}adjustTimeForDate(t,{timeAdjust:e,validHours:r,minuteIncrement:n}){if(!e&&!r&&!n)return t;const a=this.getDateParts(t);if(e)if("now"===e){const t=this.getDateParts(new Date);a.hours=t.hours,a.minutes=t.minutes,a.seconds=t.seconds,a.milliseconds=t.milliseconds}else{const t=new Date(`2000-01-01T${e}Z`);a.hours=t.getUTCHours(),a.minutes=t.getUTCMinutes(),a.seconds=t.getUTCSeconds(),a.milliseconds=t.getUTCMilliseconds()}if(r){const t=this.getHourOptions(r,a);a.hours=this.nearestOptionValue(a.hours,t)}if(n){const t=this.getMinuteOptions(n);a.minutes=this.nearestOptionValue(a.minutes,t)}return t=this.getDateFromParts(a),t}normalizeDates(t,e){return e=e||{},e.locale=this,(Object(ht["h"])(t)?t:[t]).map((function(t){return t&&(t instanceof dt["a"]?t:new dt["a"](t,e))})).filter((function(t){return t}))}getDateParts(t,e=this.timezone){if(!t)return null;let r=t;if(e){const n=new Date(t.toLocaleString("en-US",{timeZone:e}));n.setMilliseconds(t.getMilliseconds());const a=n.getTime()-t.getTime();r=new Date(t.getTime()+a)}const n=r.getMilliseconds(),a=r.getSeconds(),o=r.getMinutes(),i=r.getHours(),s=r.getMonth()+1,c=r.getFullYear(),u=this.getMonthComps(s,c),l=r.getDate(),d=u.days-l+1,f=r.getDay()+1,p=Math.floor((l-1)/7+1),h=Math.floor((u.days-l)/7+1),v=Math.ceil((l+Math.abs(u.firstWeekday-u.firstDayOfWeek))/7),b=u.weeks-v+1,m={milliseconds:n,seconds:a,minutes:o,hours:i,day:l,dayFromEnd:d,weekday:f,weekdayOrdinal:p,weekdayOrdinalFromEnd:h,week:v,weekFromEnd:b,month:s,year:c,date:t,isValid:!0};return m.timezoneOffset=this.getTimezoneOffset(m),m}getDateFromParts(t){if(!t)return null;const e=new Date,{year:r=e.getFullYear(),month:n=e.getMonth()+1,day:a=e.getDate(),hours:o=0,minutes:i=0,seconds:s=0,milliseconds:c=0}=t;if(this.timezone){const t=`${Object(pt["m"])(r,4)}-${Object(pt["m"])(n,2)}-${Object(pt["m"])(a,2)}T${Object(pt["m"])(o,2)}:${Object(pt["m"])(i,2)}:${Object(pt["m"])(s,2)}.${Object(pt["m"])(c,3)}`;return _(t,{timeZone:this.timezone})}return new Date(r,n-1,a,o,i,s,c)}getTimezoneOffset(t){const{year:e,month:r,day:n,hours:a=0,minutes:o=0,seconds:i=0,milliseconds:s=0}=t;let c;const u=new Date(Date.UTC(e,r-1,n,a,o,i,s));if(this.timezone){const t=`${Object(pt["m"])(e,4)}-${Object(pt["m"])(r,2)}-${Object(pt["m"])(n,2)}T${Object(pt["m"])(a,2)}:${Object(pt["m"])(o,2)}:${Object(pt["m"])(i,2)}.${Object(pt["m"])(s,3)}`;c=_(t,{timeZone:this.timezone})}else c=new Date(e,r-1,n,a,o,i,s);return(c-u)/6e4}toPage(t,e){return Object(ht["l"])(t)?Object(pt["a"])(e,t):Object(ht["n"])(t)?this.getDateParts(this.normalizeDate(t)):Object(ht["j"])(t)?this.getDateParts(t):Object(ht["m"])(t)?t:null}getMonthDates(t=2e3){const e=[];for(let r=0;r<12;r++)e.push(new Date(t,r,15));return e}getMonthNames(t){const e=new Intl.DateTimeFormat(this.id,{month:t,timezome:"UTC"});return this.getMonthDates().map((function(t){return e.format(t)}))}getWeekdayDates(t=this.firstDayOfWeek){const e=[],r=2020,n=1,a=5+t-1;for(let o=0;o<Mt;o++)e.push(this.getDateFromParts({year:r,month:n,day:a+o,hours:12}));return e}getDayNames(t){const e=new Intl.DateTimeFormat(this.id,{weekday:t,timeZone:this.timezone});return this.getWeekdayDates(1).map((function(t){return e.format(t)}))}getMonthComps(t,e){const r=`${t}-${e}`;let n=this.monthData[r];if(!n){const a=e%4===0&&e%100!==0||e%400===0,o=new Date(e,t-1,1),i=o.getDay()+1,s=2===t&&a?29:Pt[t-1],c=this.firstDayOfWeek-1,u=ut(o,{weekStartsOn:c}),l=[],d=[];for(let t=0;t<u;t++){const e=Object(lt["a"])(o,7*t);l.push(nt(e,{weekStartsOn:c})),d.push(Q(e))}n={firstDayOfWeek:this.firstDayOfWeek,inLeapYear:a,firstWeekday:i,days:s,weeks:u,month:t,year:e,weeknumbers:l,isoWeeknumbers:d},this.monthData[r]=n}return n}getThisMonthComps(){const{month:t,year:e}=this.getDateParts(new Date);return this.getMonthComps(t,e)}getPrevMonthComps(t,e){return 1===t?this.getMonthComps(12,e-1):this.getMonthComps(t-1,e)}getNextMonthComps(t,e){return 12===t?this.getMonthComps(1,e+1):this.getMonthComps(t+1,e)}getDayId(t){return this.format(t,"YYYY-MM-DD")}getCalendarDays({weeks:t,monthComps:e,prevMonthComps:r,nextMonthComps:n}){var a=this;const o=[],{firstDayOfWeek:i,firstWeekday:s,isoWeeknumbers:c,weeknumbers:u}=e,l=s+(s<i?Mt:0)-i;let d=!0,f=!1,p=!1;const h=new Intl.DateTimeFormat(this.id,{weekday:"long",year:"numeric",month:"long",day:"numeric"});let v=r.days-l+1,b=r.days-v+1,m=Math.floor((v-1)/Mt+1),g=1,y=r.weeks,w=1,x=r.month,D=r.year;const O=new Date,j=O.getDate(),k=O.getMonth()+1,M=O.getFullYear(),P=function(t,e,r){return function(n,o,i,s){return a.normalizeDate({year:t,month:e,day:r,hours:n,minutes:o,seconds:i,milliseconds:s})}};for(let Y=1;Y<=t;Y++){for(let r=1,a=i;r<=Mt;r++,a+=a===Mt?1-Mt:1){d&&a===s&&(v=1,b=e.days,m=Math.floor((v-1)/Mt+1),g=Math.floor((e.days-v)/Mt+1),y=1,w=e.weeks,x=e.month,D=e.year,d=!1,f=!0);const i=P(D,x,v),l={start:i(0,0,0),end:i(23,59,59,999)},O=l.start,S=`${Object(pt["m"])(D,4)}-${Object(pt["m"])(x,2)}-${Object(pt["m"])(v,2)}`,_=r,E=Mt-r,T=u[Y-1],I=c[Y-1],C=v===j&&x===k&&D===M,$=f&&1===v,A=f&&v===e.days,N=1===Y,F=Y===t,z=1===r,H=r===Mt;o.push({id:S,label:v.toString(),ariaLabel:h.format(new Date(D,x-1,v)),day:v,dayFromEnd:b,weekday:a,weekdayPosition:_,weekdayPositionFromEnd:E,weekdayOrdinal:m,weekdayOrdinalFromEnd:g,week:y,weekFromEnd:w,weeknumber:T,isoWeeknumber:I,month:x,year:D,dateFromTime:i,date:O,range:l,isToday:C,isFirstDay:$,isLastDay:A,inMonth:f,inPrevMonth:d,inNextMonth:p,onTop:N,onBottom:F,onLeft:z,onRight:H,classes:["id-"+S,"day-"+v,"day-from-end-"+b,"weekday-"+a,"weekday-position-"+_,"weekday-ordinal-"+m,"weekday-ordinal-from-end-"+g,"week-"+y,"week-from-end-"+w,{"is-today":C,"is-first-day":$,"is-last-day":A,"in-month":f,"in-prev-month":d,"in-next-month":p,"on-top":N,"on-bottom":F,"on-left":z,"on-right":H}]}),f&&A?(f=!1,p=!0,v=1,b=n.days,m=1,g=Math.floor((n.days-v)/Mt+1),y=1,w=n.weeks,x=n.month,D=n.year):(v++,b--,m=Math.floor((v-1)/Mt+1),g=Math.floor((e.days-v)/Mt+1))}y++,w--}return o}}},"29f3":function(t,e){var r=Object.prototype,n=r.toString;function a(t){return n.call(t)}t.exports=a},"2af9":function(t,e,r){"use strict";r.r(e),r.d(e,"Calendar",(function(){return Ar})),r.d(e,"CalendarNav",(function(){return or})),r.d(e,"DatePicker",(function(){return sn})),r.d(e,"Popover",(function(){return Oe}));r("d9e2"),r("14d9"),r("13d5");var n=r("f7f1"),a=r("fe1f"),o=r("fd3a"),i=r("8c86");function s(t,e){Object(i["a"])(2,arguments);var r=Object(o["a"])(t),n=Object(a["a"])(e);if(isNaN(n))return new Date(NaN);if(!n)return r;var s=r.getDate(),c=new Date(r.getTime());c.setMonth(r.getMonth()+n+1,0);var u=c.getDate();return s>=u?c:(r.setFullYear(c.getFullYear(),c.getMonth(),s),r)}function c(t,e){Object(i["a"])(2,arguments);var r=Object(a["a"])(e);return s(t,12*r)}function u(t){if(null==t)return window;if("[object Window]"!==t.toString()){var e=t.ownerDocument;return e&&e.defaultView||window}return t}function l(t){var e=u(t).Element;return t instanceof e||t instanceof Element}function d(t){var e=u(t).HTMLElement;return t instanceof e||t instanceof HTMLElement}function f(t){if("undefined"===typeof ShadowRoot)return!1;var e=u(t).ShadowRoot;return t instanceof e||t instanceof ShadowRoot}var p=Math.max,h=Math.min,v=Math.round;function b(){var t=navigator.userAgentData;return null!=t&&t.brands&&Array.isArray(t.brands)?t.brands.map((function(t){return t.brand+"/"+t.version})).join(" "):navigator.userAgent}function m(){return!/^((?!chrome|android).)*safari/i.test(b())}function g(t,e,r){void 0===e&&(e=!1),void 0===r&&(r=!1);var n=t.getBoundingClientRect(),a=1,o=1;e&&d(t)&&(a=t.offsetWidth>0&&v(n.width)/t.offsetWidth||1,o=t.offsetHeight>0&&v(n.height)/t.offsetHeight||1);var i=l(t)?u(t):window,s=i.visualViewport,c=!m()&&r,f=(n.left+(c&&s?s.offsetLeft:0))/a,p=(n.top+(c&&s?s.offsetTop:0))/o,h=n.width/a,b=n.height/o;return{width:h,height:b,top:p,right:f+h,bottom:p+b,left:f,x:f,y:p}}function y(t){var e=u(t),r=e.pageXOffset,n=e.pageYOffset;return{scrollLeft:r,scrollTop:n}}function w(t){return{scrollLeft:t.scrollLeft,scrollTop:t.scrollTop}}function x(t){return t!==u(t)&&d(t)?w(t):y(t)}function D(t){return t?(t.nodeName||"").toLowerCase():null}function O(t){return((l(t)?t.ownerDocument:t.document)||window.document).documentElement}function j(t){return g(O(t)).left+y(t).scrollLeft}function k(t){return u(t).getComputedStyle(t)}function M(t){var e=k(t),r=e.overflow,n=e.overflowX,a=e.overflowY;return/auto|scroll|overlay|hidden/.test(r+a+n)}function P(t){var e=t.getBoundingClientRect(),r=v(e.width)/t.offsetWidth||1,n=v(e.height)/t.offsetHeight||1;return 1!==r||1!==n}function Y(t,e,r){void 0===r&&(r=!1);var n=d(e),a=d(e)&&P(e),o=O(e),i=g(t,a,r),s={scrollLeft:0,scrollTop:0},c={x:0,y:0};return(n||!n&&!r)&&(("body"!==D(e)||M(o))&&(s=x(e)),d(e)?(c=g(e,!0),c.x+=e.clientLeft,c.y+=e.clientTop):o&&(c.x=j(o))),{x:i.left+s.scrollLeft-c.x,y:i.top+s.scrollTop-c.y,width:i.width,height:i.height}}function S(t){var e=g(t),r=t.offsetWidth,n=t.offsetHeight;return Math.abs(e.width-r)<=1&&(r=e.width),Math.abs(e.height-n)<=1&&(n=e.height),{x:t.offsetLeft,y:t.offsetTop,width:r,height:n}}function _(t){return"html"===D(t)?t:t.assignedSlot||t.parentNode||(f(t)?t.host:null)||O(t)}function E(t){return["html","body","#document"].indexOf(D(t))>=0?t.ownerDocument.body:d(t)&&M(t)?t:E(_(t))}function T(t,e){var r;void 0===e&&(e=[]);var n=E(t),a=n===(null==(r=t.ownerDocument)?void 0:r.body),o=u(n),i=a?[o].concat(o.visualViewport||[],M(n)?n:[]):n,s=e.concat(i);return a?s:s.concat(T(_(i)))}function I(t){return["table","td","th"].indexOf(D(t))>=0}function C(t){return d(t)&&"fixed"!==k(t).position?t.offsetParent:null}function $(t){var e=/firefox/i.test(b()),r=/Trident/i.test(b());if(r&&d(t)){var n=k(t);if("fixed"===n.position)return null}var a=_(t);f(a)&&(a=a.host);while(d(a)&&["html","body"].indexOf(D(a))<0){var o=k(a);if("none"!==o.transform||"none"!==o.perspective||"paint"===o.contain||-1!==["transform","perspective"].indexOf(o.willChange)||e&&"filter"===o.willChange||e&&o.filter&&"none"!==o.filter)return a;a=a.parentNode}return null}function A(t){var e=u(t),r=C(t);while(r&&I(r)&&"static"===k(r).position)r=C(r);return r&&("html"===D(r)||"body"===D(r)&&"static"===k(r).position)?e:r||$(t)||e}var N="top",F="bottom",z="right",H="left",L="auto",W=[N,F,z,H],V="start",R="end",U="clippingParents",B="viewport",Z="popper",q="reference",G=W.reduce((function(t,e){return t.concat([e+"-"+V,e+"-"+R])}),[]),K=[].concat(W,[L]).reduce((function(t,e){return t.concat([e,e+"-"+V,e+"-"+R])}),[]),X="beforeRead",J="read",Q="afterRead",tt="beforeMain",et="main",rt="afterMain",nt="beforeWrite",at="write",ot="afterWrite",it=[X,J,Q,tt,et,rt,nt,at,ot];function st(t){var e=new Map,r=new Set,n=[];function a(t){r.add(t.name);var o=[].concat(t.requires||[],t.requiresIfExists||[]);o.forEach((function(t){if(!r.has(t)){var n=e.get(t);n&&a(n)}})),n.push(t)}return t.forEach((function(t){e.set(t.name,t)})),t.forEach((function(t){r.has(t.name)||a(t)})),n}function ct(t){var e=st(t);return it.reduce((function(t,r){return t.concat(e.filter((function(t){return t.phase===r})))}),[])}function ut(t){var e;return function(){return e||(e=new Promise((function(r){Promise.resolve().then((function(){e=void 0,r(t())}))}))),e}}function lt(t){var e=t.reduce((function(t,e){var r=t[e.name];return t[e.name]=r?Object.assign({},r,e,{options:Object.assign({},r.options,e.options),data:Object.assign({},r.data,e.data)}):e,t}),{});return Object.keys(e).map((function(t){return e[t]}))}var dt={placement:"bottom",modifiers:[],strategy:"absolute"};function ft(){for(var t=arguments.length,e=new Array(t),r=0;r<t;r++)e[r]=arguments[r];return!e.some((function(t){return!(t&&"function"===typeof t.getBoundingClientRect)}))}function pt(t){void 0===t&&(t={});var e=t,r=e.defaultModifiers,n=void 0===r?[]:r,a=e.defaultOptions,o=void 0===a?dt:a;return function(t,e,r){void 0===r&&(r=o);var a={placement:"bottom",orderedModifiers:[],options:Object.assign({},dt,o),modifiersData:{},elements:{reference:t,popper:e},attributes:{},styles:{}},i=[],s=!1,c={state:a,setOptions:function(r){var i="function"===typeof r?r(a.options):r;d(),a.options=Object.assign({},o,a.options,i),a.scrollParents={reference:l(t)?T(t):t.contextElement?T(t.contextElement):[],popper:T(e)};var s=ct(lt([].concat(n,a.options.modifiers)));return a.orderedModifiers=s.filter((function(t){return t.enabled})),u(),c.update()},forceUpdate:function(){if(!s){var t=a.elements,e=t.reference,r=t.popper;if(ft(e,r)){a.rects={reference:Y(e,A(r),"fixed"===a.options.strategy),popper:S(r)},a.reset=!1,a.placement=a.options.placement,a.orderedModifiers.forEach((function(t){return a.modifiersData[t.name]=Object.assign({},t.data)}));for(var n=0;n<a.orderedModifiers.length;n++)if(!0!==a.reset){var o=a.orderedModifiers[n],i=o.fn,u=o.options,l=void 0===u?{}:u,d=o.name;"function"===typeof i&&(a=i({state:a,options:l,name:d,instance:c})||a)}else a.reset=!1,n=-1}}},update:ut((function(){return new Promise((function(t){c.forceUpdate(),t(a)}))})),destroy:function(){d(),s=!0}};if(!ft(t,e))return c;function u(){a.orderedModifiers.forEach((function(t){var e=t.name,r=t.options,n=void 0===r?{}:r,o=t.effect;if("function"===typeof o){var s=o({state:a,name:e,instance:c,options:n}),u=function(){};i.push(s||u)}}))}function d(){i.forEach((function(t){return t()})),i=[]}return c.setOptions(r).then((function(t){!s&&r.onFirstUpdate&&r.onFirstUpdate(t)})),c}}var ht={passive:!0};function vt(t){var e=t.state,r=t.instance,n=t.options,a=n.scroll,o=void 0===a||a,i=n.resize,s=void 0===i||i,c=u(e.elements.popper),l=[].concat(e.scrollParents.reference,e.scrollParents.popper);return o&&l.forEach((function(t){t.addEventListener("scroll",r.update,ht)})),s&&c.addEventListener("resize",r.update,ht),function(){o&&l.forEach((function(t){t.removeEventListener("scroll",r.update,ht)})),s&&c.removeEventListener("resize",r.update,ht)}}var bt={name:"eventListeners",enabled:!0,phase:"write",fn:function(){},effect:vt,data:{}};function mt(t){return t.split("-")[0]}function gt(t){return t.split("-")[1]}function yt(t){return["top","bottom"].indexOf(t)>=0?"x":"y"}function wt(t){var e,r=t.reference,n=t.element,a=t.placement,o=a?mt(a):null,i=a?gt(a):null,s=r.x+r.width/2-n.width/2,c=r.y+r.height/2-n.height/2;switch(o){case N:e={x:s,y:r.y-n.height};break;case F:e={x:s,y:r.y+r.height};break;case z:e={x:r.x+r.width,y:c};break;case H:e={x:r.x-n.width,y:c};break;default:e={x:r.x,y:r.y}}var u=o?yt(o):null;if(null!=u){var l="y"===u?"height":"width";switch(i){case V:e[u]=e[u]-(r[l]/2-n[l]/2);break;case R:e[u]=e[u]+(r[l]/2-n[l]/2);break;default:}}return e}function xt(t){var e=t.state,r=t.name;e.modifiersData[r]=wt({reference:e.rects.reference,element:e.rects.popper,strategy:"absolute",placement:e.placement})}var Dt={name:"popperOffsets",enabled:!0,phase:"read",fn:xt,data:{}},Ot={top:"auto",right:"auto",bottom:"auto",left:"auto"};function jt(t,e){var r=t.x,n=t.y,a=e.devicePixelRatio||1;return{x:v(r*a)/a||0,y:v(n*a)/a||0}}function kt(t){var e,r=t.popper,n=t.popperRect,a=t.placement,o=t.variation,i=t.offsets,s=t.position,c=t.gpuAcceleration,l=t.adaptive,d=t.roundOffsets,f=t.isFixed,p=i.x,h=void 0===p?0:p,v=i.y,b=void 0===v?0:v,m="function"===typeof d?d({x:h,y:b}):{x:h,y:b};h=m.x,b=m.y;var g=i.hasOwnProperty("x"),y=i.hasOwnProperty("y"),w=H,x=N,D=window;if(l){var j=A(r),M="clientHeight",P="clientWidth";if(j===u(r)&&(j=O(r),"static"!==k(j).position&&"absolute"===s&&(M="scrollHeight",P="scrollWidth")),j=j,a===N||(a===H||a===z)&&o===R){x=F;var Y=f&&j===D&&D.visualViewport?D.visualViewport.height:j[M];b-=Y-n.height,b*=c?1:-1}if(a===H||(a===N||a===F)&&o===R){w=z;var S=f&&j===D&&D.visualViewport?D.visualViewport.width:j[P];h-=S-n.width,h*=c?1:-1}}var _,E=Object.assign({position:s},l&&Ot),T=!0===d?jt({x:h,y:b},u(r)):{x:h,y:b};return h=T.x,b=T.y,c?Object.assign({},E,(_={},_[x]=y?"0":"",_[w]=g?"0":"",_.transform=(D.devicePixelRatio||1)<=1?"translate("+h+"px, "+b+"px)":"translate3d("+h+"px, "+b+"px, 0)",_)):Object.assign({},E,(e={},e[x]=y?b+"px":"",e[w]=g?h+"px":"",e.transform="",e))}function Mt(t){var e=t.state,r=t.options,n=r.gpuAcceleration,a=void 0===n||n,o=r.adaptive,i=void 0===o||o,s=r.roundOffsets,c=void 0===s||s,u={placement:mt(e.placement),variation:gt(e.placement),popper:e.elements.popper,popperRect:e.rects.popper,gpuAcceleration:a,isFixed:"fixed"===e.options.strategy};null!=e.modifiersData.popperOffsets&&(e.styles.popper=Object.assign({},e.styles.popper,kt(Object.assign({},u,{offsets:e.modifiersData.popperOffsets,position:e.options.strategy,adaptive:i,roundOffsets:c})))),null!=e.modifiersData.arrow&&(e.styles.arrow=Object.assign({},e.styles.arrow,kt(Object.assign({},u,{offsets:e.modifiersData.arrow,position:"absolute",adaptive:!1,roundOffsets:c})))),e.attributes.popper=Object.assign({},e.attributes.popper,{"data-popper-placement":e.placement})}var Pt={name:"computeStyles",enabled:!0,phase:"beforeWrite",fn:Mt,data:{}};function Yt(t){var e=t.state;Object.keys(e.elements).forEach((function(t){var r=e.styles[t]||{},n=e.attributes[t]||{},a=e.elements[t];d(a)&&D(a)&&(Object.assign(a.style,r),Object.keys(n).forEach((function(t){var e=n[t];!1===e?a.removeAttribute(t):a.setAttribute(t,!0===e?"":e)})))}))}function St(t){var e=t.state,r={popper:{position:e.options.strategy,left:"0",top:"0",margin:"0"},arrow:{position:"absolute"},reference:{}};return Object.assign(e.elements.popper.style,r.popper),e.styles=r,e.elements.arrow&&Object.assign(e.elements.arrow.style,r.arrow),function(){Object.keys(e.elements).forEach((function(t){var n=e.elements[t],a=e.attributes[t]||{},o=Object.keys(e.styles.hasOwnProperty(t)?e.styles[t]:r[t]),i=o.reduce((function(t,e){return t[e]="",t}),{});d(n)&&D(n)&&(Object.assign(n.style,i),Object.keys(a).forEach((function(t){n.removeAttribute(t)})))}))}}var _t={name:"applyStyles",enabled:!0,phase:"write",fn:Yt,effect:St,requires:["computeStyles"]};function Et(t,e,r){var n=mt(t),a=[H,N].indexOf(n)>=0?-1:1,o="function"===typeof r?r(Object.assign({},e,{placement:t})):r,i=o[0],s=o[1];return i=i||0,s=(s||0)*a,[H,z].indexOf(n)>=0?{x:s,y:i}:{x:i,y:s}}function Tt(t){var e=t.state,r=t.options,n=t.name,a=r.offset,o=void 0===a?[0,0]:a,i=K.reduce((function(t,r){return t[r]=Et(r,e.rects,o),t}),{}),s=i[e.placement],c=s.x,u=s.y;null!=e.modifiersData.popperOffsets&&(e.modifiersData.popperOffsets.x+=c,e.modifiersData.popperOffsets.y+=u),e.modifiersData[n]=i}var It={name:"offset",enabled:!0,phase:"main",requires:["popperOffsets"],fn:Tt},Ct={left:"right",right:"left",bottom:"top",top:"bottom"};function $t(t){return t.replace(/left|right|bottom|top/g,(function(t){return Ct[t]}))}var At={start:"end",end:"start"};function Nt(t){return t.replace(/start|end/g,(function(t){return At[t]}))}function Ft(t,e){var r=u(t),n=O(t),a=r.visualViewport,o=n.clientWidth,i=n.clientHeight,s=0,c=0;if(a){o=a.width,i=a.height;var l=m();(l||!l&&"fixed"===e)&&(s=a.offsetLeft,c=a.offsetTop)}return{width:o,height:i,x:s+j(t),y:c}}function zt(t){var e,r=O(t),n=y(t),a=null==(e=t.ownerDocument)?void 0:e.body,o=p(r.scrollWidth,r.clientWidth,a?a.scrollWidth:0,a?a.clientWidth:0),i=p(r.scrollHeight,r.clientHeight,a?a.scrollHeight:0,a?a.clientHeight:0),s=-n.scrollLeft+j(t),c=-n.scrollTop;return"rtl"===k(a||r).direction&&(s+=p(r.clientWidth,a?a.clientWidth:0)-o),{width:o,height:i,x:s,y:c}}function Ht(t,e){var r=e.getRootNode&&e.getRootNode();if(t.contains(e))return!0;if(r&&f(r)){var n=e;do{if(n&&t.isSameNode(n))return!0;n=n.parentNode||n.host}while(n)}return!1}function Lt(t){return Object.assign({},t,{left:t.x,top:t.y,right:t.x+t.width,bottom:t.y+t.height})}function Wt(t,e){var r=g(t,!1,"fixed"===e);return r.top=r.top+t.clientTop,r.left=r.left+t.clientLeft,r.bottom=r.top+t.clientHeight,r.right=r.left+t.clientWidth,r.width=t.clientWidth,r.height=t.clientHeight,r.x=r.left,r.y=r.top,r}function Vt(t,e,r){return e===B?Lt(Ft(t,r)):l(e)?Wt(e,r):Lt(zt(O(t)))}function Rt(t){var e=T(_(t)),r=["absolute","fixed"].indexOf(k(t).position)>=0,n=r&&d(t)?A(t):t;return l(n)?e.filter((function(t){return l(t)&&Ht(t,n)&&"body"!==D(t)})):[]}function Ut(t,e,r,n){var a="clippingParents"===e?Rt(t):[].concat(e),o=[].concat(a,[r]),i=o[0],s=o.reduce((function(e,r){var a=Vt(t,r,n);return e.top=p(a.top,e.top),e.right=h(a.right,e.right),e.bottom=h(a.bottom,e.bottom),e.left=p(a.left,e.left),e}),Vt(t,i,n));return s.width=s.right-s.left,s.height=s.bottom-s.top,s.x=s.left,s.y=s.top,s}function Bt(){return{top:0,right:0,bottom:0,left:0}}function Zt(t){return Object.assign({},Bt(),t)}function qt(t,e){return e.reduce((function(e,r){return e[r]=t,e}),{})}function Gt(t,e){void 0===e&&(e={});var r=e,n=r.placement,a=void 0===n?t.placement:n,o=r.strategy,i=void 0===o?t.strategy:o,s=r.boundary,c=void 0===s?U:s,u=r.rootBoundary,d=void 0===u?B:u,f=r.elementContext,p=void 0===f?Z:f,h=r.altBoundary,v=void 0!==h&&h,b=r.padding,m=void 0===b?0:b,y=Zt("number"!==typeof m?m:qt(m,W)),w=p===Z?q:Z,x=t.rects.popper,D=t.elements[v?w:p],j=Ut(l(D)?D:D.contextElement||O(t.elements.popper),c,d,i),k=g(t.elements.reference),M=wt({reference:k,element:x,strategy:"absolute",placement:a}),P=Lt(Object.assign({},x,M)),Y=p===Z?P:k,S={top:j.top-Y.top+y.top,bottom:Y.bottom-j.bottom+y.bottom,left:j.left-Y.left+y.left,right:Y.right-j.right+y.right},_=t.modifiersData.offset;if(p===Z&&_){var E=_[a];Object.keys(S).forEach((function(t){var e=[z,F].indexOf(t)>=0?1:-1,r=[N,F].indexOf(t)>=0?"y":"x";S[t]+=E[r]*e}))}return S}function Kt(t,e){void 0===e&&(e={});var r=e,n=r.placement,a=r.boundary,o=r.rootBoundary,i=r.padding,s=r.flipVariations,c=r.allowedAutoPlacements,u=void 0===c?K:c,l=gt(n),d=l?s?G:G.filter((function(t){return gt(t)===l})):W,f=d.filter((function(t){return u.indexOf(t)>=0}));0===f.length&&(f=d);var p=f.reduce((function(e,r){return e[r]=Gt(t,{placement:r,boundary:a,rootBoundary:o,padding:i})[mt(r)],e}),{});return Object.keys(p).sort((function(t,e){return p[t]-p[e]}))}function Xt(t){if(mt(t)===L)return[];var e=$t(t);return[Nt(t),e,Nt(e)]}function Jt(t){var e=t.state,r=t.options,n=t.name;if(!e.modifiersData[n]._skip){for(var a=r.mainAxis,o=void 0===a||a,i=r.altAxis,s=void 0===i||i,c=r.fallbackPlacements,u=r.padding,l=r.boundary,d=r.rootBoundary,f=r.altBoundary,p=r.flipVariations,h=void 0===p||p,v=r.allowedAutoPlacements,b=e.options.placement,m=mt(b),g=m===b,y=c||(g||!h?[$t(b)]:Xt(b)),w=[b].concat(y).reduce((function(t,r){return t.concat(mt(r)===L?Kt(e,{placement:r,boundary:l,rootBoundary:d,padding:u,flipVariations:h,allowedAutoPlacements:v}):r)}),[]),x=e.rects.reference,D=e.rects.popper,O=new Map,j=!0,k=w[0],M=0;M<w.length;M++){var P=w[M],Y=mt(P),S=gt(P)===V,_=[N,F].indexOf(Y)>=0,E=_?"width":"height",T=Gt(e,{placement:P,boundary:l,rootBoundary:d,altBoundary:f,padding:u}),I=_?S?z:H:S?F:N;x[E]>D[E]&&(I=$t(I));var C=$t(I),$=[];if(o&&$.push(T[Y]<=0),s&&$.push(T[I]<=0,T[C]<=0),$.every((function(t){return t}))){k=P,j=!1;break}O.set(P,$)}if(j)for(var A=h?3:1,W=function(t){var e=w.find((function(e){var r=O.get(e);if(r)return r.slice(0,t).every((function(t){return t}))}));if(e)return k=e,"break"},R=A;R>0;R--){var U=W(R);if("break"===U)break}e.placement!==k&&(e.modifiersData[n]._skip=!0,e.placement=k,e.reset=!0)}}var Qt={name:"flip",enabled:!0,phase:"main",fn:Jt,requiresIfExists:["offset"],data:{_skip:!1}};function te(t){return"x"===t?"y":"x"}function ee(t,e,r){return p(t,h(e,r))}function re(t,e,r){var n=ee(t,e,r);return n>r?r:n}function ne(t){var e=t.state,r=t.options,n=t.name,a=r.mainAxis,o=void 0===a||a,i=r.altAxis,s=void 0!==i&&i,c=r.boundary,u=r.rootBoundary,l=r.altBoundary,d=r.padding,f=r.tether,v=void 0===f||f,b=r.tetherOffset,m=void 0===b?0:b,g=Gt(e,{boundary:c,rootBoundary:u,padding:d,altBoundary:l}),y=mt(e.placement),w=gt(e.placement),x=!w,D=yt(y),O=te(D),j=e.modifiersData.popperOffsets,k=e.rects.reference,M=e.rects.popper,P="function"===typeof m?m(Object.assign({},e.rects,{placement:e.placement})):m,Y="number"===typeof P?{mainAxis:P,altAxis:P}:Object.assign({mainAxis:0,altAxis:0},P),_=e.modifiersData.offset?e.modifiersData.offset[e.placement]:null,E={x:0,y:0};if(j){if(o){var T,I="y"===D?N:H,C="y"===D?F:z,$="y"===D?"height":"width",L=j[D],W=L+g[I],R=L-g[C],U=v?-M[$]/2:0,B=w===V?k[$]:M[$],Z=w===V?-M[$]:-k[$],q=e.elements.arrow,G=v&&q?S(q):{width:0,height:0},K=e.modifiersData["arrow#persistent"]?e.modifiersData["arrow#persistent"].padding:Bt(),X=K[I],J=K[C],Q=ee(0,k[$],G[$]),tt=x?k[$]/2-U-Q-X-Y.mainAxis:B-Q-X-Y.mainAxis,et=x?-k[$]/2+U+Q+J+Y.mainAxis:Z+Q+J+Y.mainAxis,rt=e.elements.arrow&&A(e.elements.arrow),nt=rt?"y"===D?rt.clientTop||0:rt.clientLeft||0:0,at=null!=(T=null==_?void 0:_[D])?T:0,ot=L+tt-at-nt,it=L+et-at,st=ee(v?h(W,ot):W,L,v?p(R,it):R);j[D]=st,E[D]=st-L}if(s){var ct,ut="x"===D?N:H,lt="x"===D?F:z,dt=j[O],ft="y"===O?"height":"width",pt=dt+g[ut],ht=dt-g[lt],vt=-1!==[N,H].indexOf(y),bt=null!=(ct=null==_?void 0:_[O])?ct:0,wt=vt?pt:dt-k[ft]-M[ft]-bt+Y.altAxis,xt=vt?dt+k[ft]+M[ft]-bt-Y.altAxis:ht,Dt=v&&vt?re(wt,dt,xt):ee(v?wt:pt,dt,v?xt:ht);j[O]=Dt,E[O]=Dt-dt}e.modifiersData[n]=E}}var ae={name:"preventOverflow",enabled:!0,phase:"main",fn:ne,requiresIfExists:["offset"]},oe=function(t,e){return t="function"===typeof t?t(Object.assign({},e.rects,{placement:e.placement})):t,Zt("number"!==typeof t?t:qt(t,W))};function ie(t){var e,r=t.state,n=t.name,a=t.options,o=r.elements.arrow,i=r.modifiersData.popperOffsets,s=mt(r.placement),c=yt(s),u=[H,z].indexOf(s)>=0,l=u?"height":"width";if(o&&i){var d=oe(a.padding,r),f=S(o),p="y"===c?N:H,h="y"===c?F:z,v=r.rects.reference[l]+r.rects.reference[c]-i[c]-r.rects.popper[l],b=i[c]-r.rects.reference[c],m=A(o),g=m?"y"===c?m.clientHeight||0:m.clientWidth||0:0,y=v/2-b/2,w=d[p],x=g-f[l]-d[h],D=g/2-f[l]/2+y,O=ee(w,D,x),j=c;r.modifiersData[n]=(e={},e[j]=O,e.centerOffset=O-D,e)}}function se(t){var e=t.state,r=t.options,n=r.element,a=void 0===n?"[data-popper-arrow]":n;null!=a&&("string"!==typeof a||(a=e.elements.popper.querySelector(a),a))&&Ht(e.elements.popper,a)&&(e.elements.arrow=a)}var ce={name:"arrow",enabled:!0,phase:"main",fn:ie,effect:se,requires:["popperOffsets"],requiresIfExists:["preventOverflow"]};function ue(t,e,r){return void 0===r&&(r={x:0,y:0}),{top:t.top-e.height-r.y,right:t.right-e.width+r.x,bottom:t.bottom-e.height+r.y,left:t.left-e.width-r.x}}function le(t){return[N,z,F,H].some((function(e){return t[e]>=0}))}function de(t){var e=t.state,r=t.name,n=e.rects.reference,a=e.rects.popper,o=e.modifiersData.preventOverflow,i=Gt(e,{elementContext:"reference"}),s=Gt(e,{altBoundary:!0}),c=ue(i,n),u=ue(s,a,o),l=le(c),d=le(u);e.modifiersData[r]={referenceClippingOffsets:c,popperEscapeOffsets:u,isReferenceHidden:l,hasPopperEscaped:d},e.attributes.popper=Object.assign({},e.attributes.popper,{"data-popper-reference-hidden":l,"data-popper-escaped":d})}var fe,pe,he={name:"hide",enabled:!0,phase:"main",requiresIfExists:["preventOverflow"],fn:de},ve=[bt,Dt,Pt,_t,It,Qt,ae,ce,he],be=pt({defaultModifiers:ve}),me=r("2fa3"),ge=r("9404"),ye={name:"Popover",render(t){return t("div",{class:["vc-popover-content-wrapper",{"is-interactive":this.isInteractive}],ref:"popover"},[t("transition",{props:{name:this.transition,appear:!0},on:{beforeEnter:this.beforeEnter,afterEnter:this.afterEnter,beforeLeave:this.beforeLeave,afterLeave:this.afterLeave}},[this.isVisible&&t("div",{attrs:{tabindex:-1},class:["vc-popover-content","direction-"+this.direction,this.contentClass]},[this.content,t("span",{class:["vc-popover-caret","direction-"+this.direction,"align-"+this.alignment]})])])])},props:{id:{type:String,required:!0},contentClass:String},data(){return{ref:null,opts:null,data:null,transition:"slide-fade",placement:"bottom",positionFixed:!1,modifiers:[],isInteractive:!1,isHovered:!1,isFocused:!1,showDelay:0,hideDelay:110,autoHide:!1,popperEl:null}},computed:{content(){var t=this;return Object(ge["k"])(this.$scopedSlots.default)&&this.$scopedSlots.default({direction:this.direction,alignment:this.alignment,data:this.data,updateLayout:this.setupPopper,hide:function(e){return t.hide(e)}})||this.$slots.default},popperOptions(){return{placement:this.placement,strategy:this.positionFixed?"fixed":"absolute",modifiers:[{name:"onUpdate",enabled:!0,phase:"afterWrite",fn:this.onPopperUpdate},...this.modifiers||[]],onFirstUpdate:this.onPopperUpdate}},isVisible(){return!(!this.ref||!this.content)},direction(){return this.placement&&this.placement.split("-")[0]||"bottom"},alignment(){const t="left"===this.direction||"right"===this.direction;let e=this.placement.split("-");return e=e.length>1?e[1]:"",["start","top","left"].includes(e)?t?"top":"left":["end","bottom","right"].includes(e)?t?"bottom":"right":t?"middle":"center"},state(){return this.$popovers[this.id]}},watch:{opts(t,e){e&&e.callback&&e.callback({...e,completed:!t,reason:t?"Overridden by action":null})}},mounted(){this.popoverEl=this.$refs.popover,this.addEvents()},beforeDestroy(){this.destroyPopper(),this.removeEvents(),this.popoverEl=null},methods:{addEvents(){Object(me["k"])(this.popoverEl,"click",this.onClick),Object(me["k"])(this.popoverEl,"mouseover",this.onMouseOver),Object(me["k"])(this.popoverEl,"mouseleave",this.onMouseLeave),Object(me["k"])(this.popoverEl,"focusin",this.onFocusIn),Object(me["k"])(this.popoverEl,"focusout",this.onFocusOut),Object(me["k"])(document,"keydown",this.onDocumentKeydown),Object(me["k"])(document,"click",this.onDocumentClick),Object(me["k"])(document,"show-popover",this.onDocumentShowPopover),Object(me["k"])(document,"hide-popover",this.onDocumentHidePopover),Object(me["k"])(document,"toggle-popover",this.onDocumentTogglePopover),Object(me["k"])(document,"update-popover",this.onDocumentUpdatePopover)},removeEvents(){Object(me["j"])(this.popoverEl,"click",this.onClick),Object(me["j"])(this.popoverEl,"mouseover",this.onMouseOver),Object(me["j"])(this.popoverEl,"mouseleave",this.onMouseLeave),Object(me["j"])(this.popoverEl,"focusin",this.onFocusIn),Object(me["j"])(this.popoverEl,"focusout",this.onFocusOut),Object(me["j"])(document,"keydown",this.onDocumentKeydown),Object(me["j"])(document,"click",this.onDocumentClick),Object(me["j"])(document,"show-popover",this.onDocumentShowPopover),Object(me["j"])(document,"hide-popover",this.onDocumentHidePopover),Object(me["j"])(document,"toggle-popover",this.onDocumentTogglePopover),Object(me["j"])(document,"update-popover",this.onDocumentUpdatePopover)},onClick(t){t.stopPropagation()},onMouseOver(){this.isHovered=!0,this.isInteractive&&this.show()},onMouseLeave(){this.isHovered=!1,!this.autoHide||this.isFocused||this.ref&&this.ref===document.activeElement||this.hide()},onFocusIn(){this.isFocused=!0,this.isInteractive&&this.show()},onFocusOut(t){t.relatedTarget&&Object(me["e"])(this.popoverEl,t.relatedTarget)||(this.isFocused=!1,!this.isHovered&&this.autoHide&&this.hide())},onDocumentClick(t){this.$refs.popover&&this.ref&&(Object(me["e"])(this.popoverEl,t.target)||Object(me["e"])(this.ref,t.target)||this.hide())},onDocumentKeydown(t){"Esc"!==t.key&&"Escape"!==t.key||this.hide()},onDocumentShowPopover({detail:t}){t.id&&t.id===this.id&&this.show(t)},onDocumentHidePopover({detail:t}){t.id&&t.id===this.id&&this.hide(t)},onDocumentTogglePopover({detail:t}){t.id&&t.id===this.id&&this.toggle(t)},onDocumentUpdatePopover({detail:t}){t.id&&t.id===this.id&&this.update(t)},show(t={}){var e=this;t.action="show";const r=t.ref||this.ref,n=t.showDelay>=0?t.showDelay:this.showDelay;if(!r)return void(t.callback&&t.callback({completed:!1,reason:"Invalid reference element provided"}));clearTimeout(this.timeout),this.opts=t;const a=function(){Object.assign(e,t),e.setupPopper(),e.opts=null};n>0?this.timeout=setTimeout((function(){return a()}),n):a()},hide(t={}){var e=this;t.action="hide";const r=t.ref||this.ref,n=t.hideDelay>=0?t.hideDelay:this.hideDelay;if(!this.ref||r!==this.ref)return void(t.callback&&t.callback({...t,completed:!1,reason:this.ref?"Invalid reference element provided":"Popover already hidden"}));const a=function(){e.ref=null,e.opts=null};clearTimeout(this.timeout),this.opts=t,n>0?this.timeout=setTimeout(a,n):a()},toggle(t={}){this.isVisible&&t.ref===this.ref?this.hide(t):this.show(t)},update(t={}){Object.assign(this,t),this.setupPopper()},setupPopper(){var t=this;this.$nextTick((function(){t.ref&&t.$refs.popover&&(t.popper&&t.popper.reference!==t.ref&&t.destroyPopper(),t.popper?t.popper.update():t.popper=be(t.ref,t.popoverEl,t.popperOptions))}))},onPopperUpdate(t){t.placement?this.placement=t.placement:t.state&&(this.placement=t.state.placement)},beforeEnter(t){this.$emit("beforeShow",t)},afterEnter(t){this.$emit("afterShow",t)},beforeLeave(t){this.$emit("beforeHide",t)},afterLeave(t){this.destroyPopper(),this.$emit("afterHide",t)},destroyPopper(){this.popper&&(this.popper.destroy(),this.popper=null)}}},we=ye;r("2745");function xe(t,e,r,n,a,o,i,s){var c,u="function"===typeof t?t.options:t;if(e&&(u.render=e,u.staticRenderFns=r,u._compiled=!0),n&&(u.functional=!0),o&&(u._scopeId="data-v-"+o),i?(c=function(t){t=t||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext,t||"undefined"===typeof __VUE_SSR_CONTEXT__||(t=__VUE_SSR_CONTEXT__),a&&a.call(this,t),t&&t._registeredComponents&&t._registeredComponents.add(i)},u._ssrRegister=c):a&&(c=s?function(){a.call(this,(u.functional?this.parent:this).$root.$options.shadowRoot)}:a),c)if(u.functional){u._injectStyles=c;var l=u.render;u.render=function(t,e){return c.call(e),l(t,e)}}else{var d=u.beforeCreate;u.beforeCreate=d?[].concat(d,c):[c]}return{exports:t,options:u}}var De=xe(we,fe,pe,!1,null,"03f17c2c",null),Oe=De.exports,je=function(){var t=this,e=t._self._c;return e("div",{staticClass:"vc-day-popover-row"},[t.indicator?e("div",{staticClass:"vc-day-popover-row-indicator"},[e("span",{class:t.indicator.class,style:t.indicator.style})]):t._e(),e("div",{staticClass:"vc-day-popover-row-content"},[t._t("default",(function(){return[t._v(t._s(t.attribute.popover?t.attribute.popover.label:"No content provided"))]}))],2)])},ke=[],Me=r("51ec");const Pe={inject:["sharedState"],mixins:[Me["a"]],computed:{masks(){return this.sharedState.masks},theme(){return this.sharedState.theme},locale(){return this.sharedState.locale},dayPopoverId(){return this.sharedState.dayPopoverId}},methods:{format(t,e){return this.locale.format(t,e)},pageForDate(t){return this.locale.getDateParts(this.locale.normalizeDate(t))}}},Ye=["base","start","end","startEnd"],Se=["class","contentClass","style","contentStyle","color","fillMode"],_e={color:"blue",isDark:!1,highlight:{base:{fillMode:"light"},start:{fillMode:"solid"},end:{fillMode:"solid"}},dot:{base:{fillMode:"solid"},start:{fillMode:"solid"},end:{fillMode:"solid"}},bar:{base:{fillMode:"solid"},start:{fillMode:"solid"},end:{fillMode:"solid"}},content:{base:{},start:{},end:{}}};class Ee{constructor(t){Object.assign(this,_e,t)}normalizeAttr({config:t,type:e}){let r=this.color,n={};const a=this[e];if(!0===t||Object(ge["n"])(t))r=Object(ge["n"])(t)?t:r,n={...a};else{if(!Object(ge["m"])(t))return null;n=Object(ge["f"])(t,Ye)?{...t}:{base:{...t},start:{...t},end:{...t}}}return Object(ge["b"])(n,{start:n.startEnd,end:n.startEnd},a),Object(ge["w"])(n).forEach((function([t,e]){let a=r;!0===e||Object(ge["n"])(e)?(a=Object(ge["n"])(e)?e:a,n[t]={color:a}):Object(ge["m"])(e)&&(Object(ge["f"])(e,Se)?n[t]={...e}:n[t]={}),Object(ge["e"])(n,t+".color")||Object(ge["u"])(n,t+".color",a)})),n}normalizeHighlight(t){var e=this;const r=this.normalizeAttr({config:t,type:"highlight"});return Object(ge["w"])(r).forEach((function([t,r]){const n=Object(ge["b"])(r,{isDark:e.isDark,color:e.color});r.style={...e.getHighlightBgStyle(n),...r.style},r.contentStyle={...e.getHighlightContentStyle(n),...r.contentStyle}})),r}getHighlightBgStyle({fillMode:t,color:e,isDark:r}){switch(t){case"outline":case"none":return{backgroundColor:r?"var(--gray-900)":"var(--white)",border:"2px solid",borderColor:r?`var(--${e}-200)`:`var(--${e}-700)`,borderRadius:"var(--rounded-full)"};case"light":return{backgroundColor:r?`var(--${e}-800)`:`var(--${e}-200)`,opacity:r?.75:1,borderRadius:"var(--rounded-full)"};case"solid":return{backgroundColor:r?`var(--${e}-500)`:`var(--${e}-600)`,borderRadius:"var(--rounded-full)"};default:return{borderRadius:"var(--rounded-full)"}}}getHighlightContentStyle({fillMode:t,color:e,isDark:r}){switch(t){case"outline":case"none":return{fontWeight:"var(--font-bold)",color:r?`var(--${e}-100)`:`var(--${e}-900)`};case"light":return{fontWeight:"var(--font-bold)",color:r?`var(--${e}-100)`:`var(--${e}-900)`};case"solid":return{fontWeight:"var(--font-bold)",color:"var(--white)"};default:return""}}bgAccentHigh({color:t,isDark:e}){return{backgroundColor:e?`var(--${t}-500)`:`var(--${t}-600)`}}contentAccent({color:t,isDark:e}){return t?{fontWeight:"var(--font-bold)",color:e?`var(--${t}-100)`:`var(--${t}-900)`}:null}normalizeDot(t){return this.normalizeNonHighlight("dot",t,this.bgAccentHigh)}normalizeBar(t){return this.normalizeNonHighlight("bar",t,this.bgAccentHigh)}normalizeContent(t){return this.normalizeNonHighlight("content",t,this.contentAccent)}normalizeNonHighlight(t,e,r){var n=this;const a=this.normalizeAttr({type:t,config:e});return Object(ge["w"])(a).forEach((function([t,e]){Object(ge["b"])(e,{isDark:n.isDark,color:n.color}),e.style={...r(e),...e.style}})),a}}var Te=r("29ae"),Ie=r("1315"),Ce=r("22f3");const $e={mixins:[Me["a"]],props:{color:String,isDark:Boolean,firstDayOfWeek:Number,masks:Object,locale:[String,Object],timezone:String,minDate:null,maxDate:null,minDateExact:null,maxDateExact:null,disabledDates:null,availableDates:null,theme:null},computed:{$theme(){return this.theme instanceof Ee?this.theme:new Ee({color:this.passedProp("color","blue"),isDark:this.passedProp("isDark",!1)})},$locale(){if(this.locale instanceof Te["b"])return this.locale;const t=Object(ge["m"])(this.locale)?this.locale:{id:this.locale,firstDayOfWeek:this.firstDayOfWeek,masks:this.masks};return new Te["b"](t,{locales:this.$locales,timezone:this.timezone})},disabledDates_(){const t=this.normalizeDates(this.disabledDates),{minDate:e,minDateExact:r,maxDate:n,maxDateExact:a}=this;if(r||e){const n=r?this.normalizeDate(r):this.normalizeDate(e,{time:"00:00:00"});t.push({start:null,end:new Date(n.getTime()-1e3)})}if(a||n){const e=a?this.normalizeDate(a):this.normalizeDate(n,{time:"23:59:59"});t.push({start:new Date(e.getTime()+1e3),end:null})}return t},availableDates_(){return this.normalizeDates(this.availableDates)},disabledAttribute(){return new Ce["a"]({key:"disabled",dates:this.disabledDates_,excludeDates:this.availableDates_,excludeMode:"includes",order:100},this.$theme,this.$locale)}},created(){Object(Ie["a"])(this.$defaults.screens)},methods:{formatDate(t,e){return this.$locale?this.$locale.format(t,e):""},parseDate(t,e){if(!this.$locale)return null;const r=this.$locale.parse(t,e);return Object(ge["j"])(r)?r:null},normalizeDate(t,e){return this.$locale?this.$locale.normalizeDate(t,e):t},normalizeDates(t){return this.$locale.normalizeDates(t,{isFullDay:!0})},pageForDate(t){return this.$locale.getDateParts(this.normalizeDate(t))},pageForThisMonth(){return this.pageForDate(new Date)}}},Ae={methods:{safeScopedSlot(t,e,r=null){return Object(ge["k"])(this.$scopedSlots[t])?this.$scopedSlots[t](e):r}}},Ne=Pe,Fe=$e,ze=Ae;var He={name:"PopoverRow",mixins:[Ne],props:{attribute:Object},computed:{indicator(){const{highlight:t,dot:e,bar:r,popover:n}=this.attribute;if(n&&n.hideIndicator)return null;if(t){const{color:e,isDark:r}=t.start;return{style:{...this.theme.bgAccentHigh({color:e,isDark:!r}),width:"10px",height:"5px",borderRadius:"3px"}}}if(e){const{color:t,isDark:r}=e.start;return{style:{...this.theme.bgAccentHigh({color:t,isDark:!r}),width:"5px",height:"5px",borderRadius:"50%"}}}if(r){const{color:t,isDark:e}=r.start;return{style:{...this.theme.bgAccentHigh({color:t,isDark:!e}),width:"10px",height:"3px"}}}return null}}},Le=He,We=(r("ca17"),xe(Le,je,ke,!1,null,"eb5afd1a",null)),Ve=We.exports,Re=function(){var t=this,e=t._self._c;return e("div",{staticClass:"vc-nav-container"},[e("div",{staticClass:"vc-nav-header"},[e("span",{staticClass:"vc-nav-arrow is-left",class:{"is-disabled":!t.prevItemsEnabled},attrs:{role:"button",tabindex:t.prevItemsEnabled?0:void 0},on:{click:t.movePrev,keydown:function(e){return t.onSpaceOrEnter(e,t.movePrev)}}},[t._t("nav-left-button",(function(){return[e("svg-icon",{attrs:{name:"left-arrow",width:"20px",height:"24px"}})]}))],2),e("span",{staticClass:"vc-nav-title vc-grid-focus",style:{whiteSpace:"nowrap"},attrs:{role:"button",tabindex:"0"},on:{click:t.toggleMode,keydown:function(e){return t.onSpaceOrEnter(e,t.toggleMode)}}},[t._v(" "+t._s(t.title)+" ")]),e("span",{staticClass:"vc-nav-arrow is-right",class:{"is-disabled":!t.nextItemsEnabled},attrs:{role:"button",tabindex:t.nextItemsEnabled?0:void 0},on:{click:t.moveNext,keydown:function(e){return t.onSpaceOrEnter(e,t.moveNext)}}},[t._t("nav-right-button",(function(){return[e("svg-icon",{attrs:{name:"right-arrow",width:"20px",height:"24px"}})]}))],2)]),e("div",{staticClass:"vc-nav-items"},t._l(t.activeItems,(function(r){return e("span",{key:r.label,class:t.getItemClasses(r),attrs:{role:"button","data-id":r.id,"aria-label":r.ariaLabel,tabindex:r.isDisabled?void 0:0},on:{click:r.click,keydown:function(e){return t.onSpaceOrEnter(e,r.click)}}},[t._v(" "+t._s(r.label)+" ")])})),0)])},Ue=[],Be=function(){var t=this,e=t._self._c;return e("svg",t._g({staticClass:"vc-svg-icon",attrs:{width:t.width,height:t.height,viewBox:t.viewBox}},t.$listeners),[e("path",{attrs:{d:t.path}})])},Ze=[];const qe="26px",Ge="0 0 32 32",Ke={"left-arrow":{viewBox:"0 -1 16 34",path:"M11.196 10c0 0.143-0.071 0.304-0.179 0.411l-7.018 7.018 7.018 7.018c0.107 0.107 0.179 0.268 0.179 0.411s-0.071 0.304-0.179 0.411l-0.893 0.893c-0.107 0.107-0.268 0.179-0.411 0.179s-0.304-0.071-0.411-0.179l-8.321-8.321c-0.107-0.107-0.179-0.268-0.179-0.411s0.071-0.304 0.179-0.411l8.321-8.321c0.107-0.107 0.268-0.179 0.411-0.179s0.304 0.071 0.411 0.179l0.893 0.893c0.107 0.107 0.179 0.25 0.179 0.411z"},"right-arrow":{viewBox:"-5 -1 16 34",path:"M10.625 17.429c0 0.143-0.071 0.304-0.179 0.411l-8.321 8.321c-0.107 0.107-0.268 0.179-0.411 0.179s-0.304-0.071-0.411-0.179l-0.893-0.893c-0.107-0.107-0.179-0.25-0.179-0.411 0-0.143 0.071-0.304 0.179-0.411l7.018-7.018-7.018-7.018c-0.107-0.107-0.179-0.268-0.179-0.411s0.071-0.304 0.179-0.411l0.893-0.893c0.107-0.107 0.268-0.179 0.411-0.179s0.304 0.071 0.411 0.179l8.321 8.321c0.107 0.107 0.179 0.268 0.179 0.411z"}};var Xe={props:["name"],data(){return{width:qe,height:qe,viewBox:Ge,path:"",isBaseline:!1}},mounted(){this.updateIcon()},watch:{name(){this.updateIcon()}},methods:{updateIcon(){const t=Ke[this.name];t&&(this.width=t.width||qe,this.height=t.height||qe,this.viewBox=t.viewBox,this.path=t.path)}}},Je=Xe,Qe=(r("52ca"),xe(Je,Be,Ze,!1,null,"63f7b5ec",null)),tr=Qe.exports;const er=12;var rr={name:"CalendarNav",components:{SvgIcon:tr},mixins:[Ne],props:{value:{type:Object,default:function(){return{month:0,year:0}}},validator:{type:Function,default:function(){return function(){return!0}}}},data(){return{monthMode:!0,yearIndex:0,yearGroupIndex:0,onSpaceOrEnter:me["l"]}},computed:{month(){return this.value&&this.value.month||0},year(){return this.value&&this.value.year||0},title(){return this.monthMode?this.yearIndex:`${this.firstYear} - ${this.lastYear}`},monthItems(){return this.getMonthItems(this.yearIndex)},yearItems(){return this.getYearItems(this.yearGroupIndex)},prevItemsEnabled(){return this.monthMode?this.prevMonthItemsEnabled:this.prevYearItemsEnabled},nextItemsEnabled(){return this.monthMode?this.nextMonthItemsEnabled:this.nextYearItemsEnabled},prevMonthItemsEnabled(){return this.getMonthItems(this.yearIndex-1).some((function(t){return!t.isDisabled}))},nextMonthItemsEnabled(){return this.getMonthItems(this.yearIndex+1).some((function(t){return!t.isDisabled}))},prevYearItemsEnabled(){return this.getYearItems(this.yearGroupIndex-1).some((function(t){return!t.isDisabled}))},nextYearItemsEnabled(){return this.getYearItems(this.yearGroupIndex+1).some((function(t){return!t.isDisabled}))},activeItems(){return this.monthMode?this.monthItems:this.yearItems},firstYear(){return Object(ge["g"])(this.yearItems.map((function(t){return t.year})))},lastYear(){return Object(ge["p"])(this.yearItems.map((function(t){return t.year})))}},watch:{year(){this.yearIndex=this.year},yearIndex(t){this.yearGroupIndex=this.getYearGroupIndex(t)},value(){this.focusFirstItem()}},created(){this.yearIndex=this.year},mounted(){this.focusFirstItem()},methods:{focusFirstItem(){var t=this;this.$nextTick((function(){const e=t.$el.querySelector(".vc-nav-item:not(.is-disabled)");e&&e.focus()}))},getItemClasses({isActive:t,isCurrent:e,isDisabled:r}){const n=["vc-nav-item"];return t?n.push("is-active"):e&&n.push("is-current"),r&&n.push("is-disabled"),n},getYearGroupIndex(t){return Math.floor(t/er)},getMonthItems(t){var e=this;const{month:r,year:n}=this.pageForDate(new Date);return this.locale.getMonthDates().map((function(a,o){const i=o+1;return{month:i,year:t,id:`${t}.${Object(me["m"])(i,2)}`,label:e.locale.format(a,e.masks.navMonths),ariaLabel:e.locale.format(a,"MMMM YYYY"),isActive:i===e.month&&t===e.year,isCurrent:i===r&&t===n,isDisabled:!e.validator({month:i,year:t}),click:function(){return e.monthClick(i,t)}}}))},getYearItems(t){var e=this;const{_:r,year:n}=this.pageForDate(new Date),a=t*er,o=a+er,i=[];for(let s=a;s<o;s+=1){let t=!1;for(let e=1;e<12;e++)if(t=this.validator({month:e,year:s}),t)break;i.push({year:s,id:s,label:s,ariaLabel:s,isActive:s===this.year,isCurrent:s===n,isDisabled:!t,click:function(){return e.yearClick(s)}})}return i},monthClick(t,e){this.validator({month:t,year:e})&&this.$emit("input",{month:t,year:e})},yearClick(t){this.yearIndex=t,this.monthMode=!0,this.focusFirstItem()},toggleMode(){this.monthMode=!this.monthMode},movePrev(){this.prevItemsEnabled&&(this.monthMode&&this.movePrevYear(),this.movePrevYearGroup())},moveNext(){this.nextItemsEnabled&&(this.monthMode&&this.moveNextYear(),this.moveNextYearGroup())},movePrevYear(){this.yearIndex--},moveNextYear(){this.yearIndex++},movePrevYearGroup(){this.yearGroupIndex--},moveNextYearGroup(){this.yearGroupIndex++}}},nr=rr,ar=(r("dc9e"),xe(nr,Re,Ue,!1,null,null,null)),or=ar.exports;r("3c65");function ir(t){document&&document.dispatchEvent(new CustomEvent("show-popover",{detail:t}))}function sr(t){document&&document.dispatchEvent(new CustomEvent("hide-popover",{detail:t}))}function cr(t){document&&document.dispatchEvent(new CustomEvent("toggle-popover",{detail:t}))}function ur(t){document&&document.dispatchEvent(new CustomEvent("update-popover",{detail:t}))}function lr(t){const{visibility:e}=t,r="click"===e,n="hover"===e,a="hover-focus"===e,o="focus"===e;t.autoHide=!r;let i=!1,s=!1;return{click(e){r&&(t.ref=e.target,cr(t),e.stopPropagation())},mousemove(e){t.ref=e.currentTarget,i||(i=!0,(n||a)&&ir(t))},mouseleave(e){t.ref=e.target,i&&(i=!1,(n||a&&!s)&&sr(t))},focusin(e){t.ref=e.currentTarget,s||(s=!0,(o||a)&&ir(t))},focusout(e){t.ref=e.currentTarget,s&&!Object(me["e"])(t.ref,e.relatedTarget)&&(s=!1,(o||a&&!i)&&sr(t))}}}var dr,fr,pr,hr,vr,br,mr,gr,yr={name:"CalendarDay",mixins:[Ne,ze],render(t){var e=this;const r=function(){return e.hasBackgrounds&&t("div",{class:"vc-highlights vc-day-layer"},e.backgrounds.map((function({key:e,wrapperClass:r,class:n,style:a}){return t("div",{key:e,class:r},[t("div",{class:n,style:a})])})))},n=function(){return e.safeScopedSlot("day-content",{day:e.day,attributes:e.day.attributes,attributesMap:e.day.attributesMap,dayProps:e.dayContentProps,dayEvents:e.dayContentEvents})||t("span",{class:e.dayContentClass,style:e.dayContentStyle,attrs:{...e.dayContentProps},on:e.dayContentEvents,ref:"content"},[e.day.label])},a=function(){return e.hasDots&&t("div",{class:"vc-day-layer vc-day-box-center-bottom"},[t("div",{class:"vc-dots"},e.dots.map((function({key:e,class:r,style:n}){return t("span",{key:e,class:r,style:n})})))])},o=function(){return e.hasBars&&t("div",{class:"vc-day-layer vc-day-box-center-bottom"},[t("div",{class:"vc-bars"},e.bars.map((function({key:e,class:r,style:n}){return t("span",{key:e,class:r,style:n})})))])};return t("div",{class:["vc-day",...this.day.classes,{"vc-day-box-center-center":!this.$scopedSlots["day-content"]},{"is-not-in-month":!this.inMonth}]},[r(),n(),a(),o()])},inject:["sharedState"],props:{day:{type:Object,required:!0}},data(){return{glyphs:{},dayContentEvents:{}}},computed:{label(){return this.day.label},startTime(){return this.day.range.start.getTime()},endTime(){return this.day.range.end.getTime()},inMonth(){return this.day.inMonth},isDisabled(){return this.day.isDisabled},backgrounds(){return this.glyphs.backgrounds},hasBackgrounds(){return!!Object(me["b"])(this.backgrounds)},content(){return this.glyphs.content},dots(){return this.glyphs.dots},hasDots(){return!!Object(me["b"])(this.dots)},bars(){return this.glyphs.bars},hasBars(){return!!Object(me["b"])(this.bars)},popovers(){return this.glyphs.popovers},hasPopovers(){return!!Object(me["b"])(this.popovers)},dayContentClass(){return["vc-day-content vc-focusable",{"is-disabled":this.isDisabled},Object(ge["d"])(Object(ge["p"])(this.content),"class")||""]},dayContentStyle(){return Object(ge["d"])(Object(ge["p"])(this.content),"style")},dayContentProps(){let t;return this.day.isFocusable?t="0":this.day.inMonth&&(t="-1"),{tabindex:t,"aria-label":this.day.ariaLabel,"aria-disabled":this.day.isDisabled?"true":"false",role:"button"}},dayEvent(){return{...this.day,el:this.$refs.content,popovers:this.popovers}}},watch:{theme(){this.refresh()},popovers(){this.refreshPopovers()}},mounted(){this.refreshPopovers()},methods:{getDayEvent(t){return{...this.dayEvent,event:t}},click(t){this.$emit("dayclick",this.getDayEvent(t))},mouseenter(t){this.$emit("daymouseenter",this.getDayEvent(t))},mouseleave(t){this.$emit("daymouseleave",this.getDayEvent(t))},focusin(t){this.$emit("dayfocusin",this.getDayEvent(t))},focusout(t){this.$emit("dayfocusout",this.getDayEvent(t))},keydown(t){this.$emit("daykeydown",this.getDayEvent(t))},refresh(){var t=this;if(!this.day.refresh)return;this.day.refresh=!1;const e={backgrounds:[],dots:[],bars:[],popovers:[],content:[]};this.$set(this.day,"attributes",Object.values(this.day.attributesMap||{}).sort((function(t,e){return t.order-e.order}))),this.day.attributes.forEach((function(r){const{targetDate:n}=r,{isDate:a,isComplex:o,startTime:i,endTime:s}=n,c=t.startTime<=i,u=t.endTime>=s,l=c&&u,d=c||u,f={isDate:a,isComplex:o,onStart:c,onEnd:u,onStartAndEnd:l,onStartOrEnd:d};t.processHighlight(r,f,e),t.processNonHighlight(r,"content",f,e.content),t.processNonHighlight(r,"dot",f,e.dots),t.processNonHighlight(r,"bar",f,e.bars),t.processPopover(r,e)})),this.glyphs=e},processHighlight({key:t,highlight:e},{isDate:r,isComplex:n,onStart:a,onEnd:o,onStartAndEnd:i},{backgrounds:s,content:c}){if(!e)return;const{base:u,start:l,end:d}=e;r||n||i?(s.push({key:t,wrapperClass:"vc-day-layer vc-day-box-center-center",class:["vc-highlight",l.class],style:l.style}),c.push({key:t+"-content",class:l.contentClass,style:l.contentStyle})):a?(s.push({key:t+"-base",wrapperClass:"vc-day-layer vc-day-box-right-center",class:["vc-highlight vc-highlight-base-start",u.class],style:u.style}),s.push({key:t,wrapperClass:"vc-day-layer vc-day-box-center-center",class:["vc-highlight",l.class],style:l.style}),c.push({key:t+"-content",class:l.contentClass,style:l.contentStyle})):o?(s.push({key:t+"-base",wrapperClass:"vc-day-layer vc-day-box-left-center",class:["vc-highlight vc-highlight-base-end",u.class],style:u.style}),s.push({key:t,wrapperClass:"vc-day-layer vc-day-box-center-center",class:["vc-highlight",d.class],style:d.style}),c.push({key:t+"-content",class:d.contentClass,style:d.contentStyle})):(s.push({key:t+"-middle",wrapperClass:"vc-day-layer vc-day-box-center-center",class:["vc-highlight vc-highlight-base-middle",u.class],style:u.style}),c.push({key:t+"-content",class:u.contentClass,style:u.contentStyle}))},processNonHighlight(t,e,{isDate:r,onStart:n,onEnd:a},o){if(!t[e])return;const{key:i}=t,s="vc-"+e,{base:c,start:u,end:l}=t[e];r||n?o.push({key:i,class:[s,u.class],style:u.style}):a?o.push({key:i,class:[s,l.class],style:l.style}):o.push({key:i,class:[s,c.class],style:c.style})},processPopover(t,{popovers:e}){const{key:r,customData:n,popover:a}=t;if(!a)return;const o=Object(ge["b"])({key:r,customData:n,attribute:t},{...a},{visibility:a.label?"hover":"click",placement:"bottom",isInteractive:!a.label});e.splice(0,0,o)},refreshPopovers(){let t={};Object(me["b"])(this.popovers)&&(t=lr(Object(ge["b"])({id:this.dayPopoverId,data:this.day},...this.popovers))),this.dayContentEvents=Object(me["h"])({click:this.click,mouseenter:this.mouseenter,mouseleave:this.mouseleave,focusin:this.focusin,focusout:this.focusout,keydown:this.keydown},t),ur({id:this.dayPopoverId,data:this.day})}}},wr=yr,xr=(r("8ab2"),xe(wr,dr,fr,!1,null,"4420d078",null)),Dr=xr.exports,Or={name:"CalendarPane",mixins:[Ne,ze],render(t){var e=this;const r=this.safeScopedSlot("header",this.page)||t("div",{class:"vc-header align-"+this.titlePosition},[t("div",{class:"vc-title",on:this.navPopoverEvents},[this.safeScopedSlot("header-title",this.page,this.page.title)])]),n=this.weekdayLabels.map((function(e,r){return t("div",{key:r+1,class:"vc-weekday"},[e])})),a=this.showWeeknumbers_.startsWith("left"),o=this.showWeeknumbers_.startsWith("right");a?n.unshift(t("div",{class:"vc-weekday"})):o&&n.push(t("div",{class:"vc-weekday"}));const i=function(r){return t("div",{class:["vc-weeknumber"]},[t("span",{class:["vc-weeknumber-content","is-"+e.showWeeknumbers_],on:{click:function(t){e.$emit("weeknumberclick",{weeknumber:r,days:e.page.days.filter((function(t){return t[e.weeknumberKey]===r})),event:t})}}},[r])])},s=[],{daysInWeek:c}=this.locale;this.page.days.forEach((function(r,n){const u=n%c;(a&&0===u||o&&u===c)&&s.push(i(r[e.weeknumberKey])),s.push(t(Dr,{attrs:{day:r},on:{...e.$listeners},scopedSlots:e.$scopedSlots,key:r.id,ref:"days",refInFor:!0})),o&&u===c-1&&s.push(i(r[e.weeknumberKey]))}));const u=t("div",{class:{"vc-weeks":!0,"vc-show-weeknumbers":this.showWeeknumbers_,"is-left":a,"is-right":o}},[n,s]);return t("div",{class:["vc-pane","row-from-end-"+this.rowFromEnd,"column-from-end-"+this.columnFromEnd],ref:"pane"},[r,u])},inheritAttrs:!1,props:{page:Object,position:Number,row:Number,rowFromEnd:Number,column:Number,columnFromEnd:Number,titlePosition:String,navVisibility:String,showWeeknumbers:[Boolean,String],showIsoWeeknumbers:[Boolean,String]},computed:{weeknumberKey(){return this.showWeeknumbers?"weeknumber":"isoWeeknumber"},showWeeknumbers_(){const t=this.showWeeknumbers||this.showIsoWeeknumbers;return null==t?"":Object(ge["i"])(t)?t?"left":"":t.startsWith("right")?this.columnFromEnd>1?"right":t:this.column>1?"left":t},navVisibility_(){return this.propOrDefault("navVisibility","navVisibility")},navPlacement(){switch(this.titlePosition){case"left":return"bottom-start";case"right":return"bottom-end";default:return"bottom"}},navPopoverEvents(){const{sharedState:t,navVisibility_:e,navPlacement:r,page:n,position:a}=this;return lr({id:t.navPopoverId,visibility:e,placement:r,modifiers:[{name:"flip",options:{fallbackPlacements:["bottom"]}}],data:{page:n,position:a},isInteractive:!0})},weekdayLabels(){var t=this;return this.locale.getWeekdayDates().map((function(e){return t.format(e,t.masks.weekdays)}))}},methods:{refresh(){this.$refs.days.forEach((function(t){return t.refresh()}))}}},jr=Or,kr=(r("f954"),r("4638"),xe(jr,pr,hr,!1,null,"74ad501d",null)),Mr=kr.exports,Pr={name:"CustomTransition",render(t){return t("transition",{props:{name:this.name_,appear:this.appear},on:{beforeEnter:this.beforeEnter,afterEnter:this.afterEnter}},[this.$slots.default])},props:{name:String,appear:Boolean},computed:{name_(){return this.name||"none"}},methods:{beforeEnter(t){this.$emit("beforeEnter",t),this.$emit("beforeTransition",t)},afterEnter(t){this.$emit("afterEnter",t),this.$emit("afterTransition",t)}}},Yr=Pr,Sr=(r("0459"),xe(Yr,vr,br,!1,null,"5be4b00c",null)),_r=Sr.exports,Er=r("9349"),Tr=r("0733"),Ir=(r("3ee2"),{name:"Calendar",render(t){var e=this;const r=this.pages.map((function(r,n){const a=n+1,o=Math.ceil((n+1)/e.columns),i=e.rows-o+1,s=a%e.columns||e.columns,c=e.columns-s+1;return t(Mr,{attrs:{...e.$attrs,attributes:e.store},props:{page:r,position:a,row:o,rowFromEnd:i,column:s,columnFromEnd:c,titlePosition:e.titlePosition_},on:{...e.$listeners,dayfocusin:function(t){e.lastFocusedDay=t,e.$emit("dayfocusin",t)},dayfocusout:function(t){e.lastFocusedDay=null,e.$emit("dayfocusout",t)}},scopedSlots:e.$scopedSlots,key:r.key,ref:"pages",refInFor:!0})})),n=function(r){const n=function(){return e.move(r?-e.step_:e.step_)},a=function(t){return Object(me["l"])(t,n)},o=r?!e.canMovePrev:!e.canMoveNext;return t("div",{class:["vc-arrow","is-"+(r?"left":"right"),{"is-disabled":o}],attrs:{role:"button"},on:{click:n,keydown:a}},[(r?e.safeScopedSlot("header-left-button",{click:n}):e.safeScopedSlot("header-right-button",{click:n}))||t(tr,{props:{name:r?"left-arrow":"right-arrow"}})])},a=function(){return t(Oe,{props:{id:e.sharedState.navPopoverId,contentClass:"vc-nav-popover-container"},ref:"navPopover",scopedSlots:{default:function({data:r}){const{position:n,page:a}=r;return t(or,{props:{value:a,position:n,validator:function(t){return e.canMove(t,{position:n})}},on:{input:function(t){return e.move(t,{position:n})}},scopedSlots:e.$scopedSlots})}}})},o=function(){return t(Oe,{props:{id:e.sharedState.dayPopoverId,contentClass:"vc-day-popover-container"},scopedSlots:{default:function({data:r,updateLayout:n,hide:a}){const o=r.attributes?Object.values(r.attributes).filter((function(t){return t.popover})):[],i=e.$locale.masks,s=e.formatDate,c=s(r.date,i.dayPopover);return e.safeScopedSlot("day-popover",{day:r,attributes:o,masks:i,format:s,dayTitle:c,updateLayout:n,hide:a})||t("div",[i.dayPopover&&t("div",{class:["vc-day-popover-header"]},[c]),o.map((function(e){return t(Ve,{key:e.key,props:{attribute:e}})}))])}}})};return t("div",{attrs:{"data-helptext":"Press the arrow keys to navigate by day, Home and End to navigate to week ends, PageUp and PageDown to navigate by month, Alt+PageUp and Alt+PageDown to navigate by year"},class:["vc-container","vc-"+this.$theme.color,{"vc-is-expanded":this.isExpanded,"vc-is-dark":this.$theme.isDark}],on:{keydown:this.handleKeydown,mouseup:function(t){return t.preventDefault()}},ref:"container"},[a(),t("div",{class:["vc-pane-container",{"in-transition":this.inTransition}]},[t(_r,{props:{name:this.transitionName},on:{beforeEnter:function(){e.inTransition=!0},afterEnter:function(){e.inTransition=!1}}},[t("div",{class:"vc-pane-layout",style:{gridTemplateColumns:`repeat(${this.columns}, 1fr)`},attrs:{...this.$attrs},key:Object(me["b"])(this.pages)?this.pages[0].key:""},r)]),t("div",{class:["vc-arrows-container title-"+this.titlePosition_]},[n(!0),n(!1)]),this.$scopedSlots.footer&&this.$scopedSlots.footer()]),o()])},mixins:[Fe,ze],provide(){return{sharedState:this.sharedState}},props:{rows:{type:Number,default:1},columns:{type:Number,default:1},step:Number,titlePosition:String,isExpanded:Boolean,fromDate:Date,toDate:Date,fromPage:Object,toPage:Object,minPage:Object,maxPage:Object,transition:String,attributes:[Object,Array],trimWeeks:Boolean,disablePageSwipe:Boolean},data(){return{pages:[],store:null,lastFocusedDay:null,focusableDay:(new Date).getDate(),transitionName:"",inTransition:!1,sharedState:{navPopoverId:Object(me["c"])(),dayPopoverId:Object(me["c"])(),theme:{},masks:{},locale:{}}}},computed:{titlePosition_(){return this.propOrDefault("titlePosition","titlePosition")},firstPage(){return Object(ge["g"])(this.pages)},lastPage(){return Object(ge["p"])(this.pages)},minPage_(){return this.minPage||this.pageForDate(this.minDate)},maxPage_(){return this.maxPage||this.pageForDate(this.maxDate)},count(){return this.rows*this.columns},step_(){return this.step||this.count},canMovePrev(){return this.canMove(-this.step_)},canMoveNext(){return this.canMove(this.step_)}},watch:{$locale(){this.refreshLocale(),this.refreshPages({page:this.firstPage,ignoreCache:!0}),this.initStore()},$theme(){this.refreshTheme(),this.initStore()},fromDate(){this.refreshPages()},fromPage(t){const e=this.pages&&this.pages[0];Object(me["q"])(t,e)||this.refreshPages()},toPage(t){const e=this.pages&&this.pages[this.pages.length-1];Object(me["q"])(t,e)||this.refreshPages()},count(){this.refreshPages()},attributes:{handler(t){const{adds:e,deletes:r}=this.store.refresh(t);this.refreshAttrs(this.pages,e,r)},deep:!0},pages(t){this.refreshAttrs(t,this.store.list,null,!0)},disabledAttribute(){this.refreshDisabledDays()},lastFocusedDay(t){t&&(this.focusableDay=t.day,this.refreshFocusableDays())},inTransition(t){t?this.$emit("transition-start"):(this.$emit("transition-end"),this.transitionPromise&&(this.transitionPromise.resolve(!0),this.transitionPromise=null))}},created(){this.refreshLocale(),this.refreshTheme(),this.initStore(),this.refreshPages()},mounted(){var t=this;this.disablePageSwipe||(this.removeHandlers=Object(Tr["a"])(this.$refs.container,(function({toLeft:e,toRight:r}){e?t.moveNext():r&&t.movePrev()}),this.$defaults.touch))},destroyed(){this.pages=[],this.store.destroy(),this.store=null,this.sharedState=null,this.removeHandlers&&this.removeHandlers()},methods:{refreshLocale(){this.sharedState.locale=this.$locale,this.sharedState.masks=this.$locale.masks},refreshTheme(){this.sharedState.theme=this.$theme},canMove(t,e={}){var r=this;const n=this.$locale.toPage(t,this.firstPage);let{position:a}=e;if(Object(ge["l"])(t)&&(a=1),!n)return Promise.reject(new Error("Invalid argument provided: "+t));if(!a)if(Object(me["o"])(n,this.firstPage))a=-1;else{if(!Object(me["n"])(n,this.lastPage))return Promise.resolve(!0);a=1}return Object.assign(e,this.getTargetPageRange(n,{position:a,force:!0})),Object(me["s"])(e.fromPage,e.toPage).some((function(t){return Object(me["p"])(t,r.minPage_,r.maxPage_)}))},movePrev(t){return this.move(-this.step_,t)},moveNext(t){return this.move(this.step_,t)},move(t,e={}){const r=this.canMove(t,e);return e.force||r?(this.$refs.navPopover.hide({hideDelay:0}),e.fromPage&&!Object(me["q"])(e.fromPage,this.firstPage)?this.refreshPages({...e,page:e.fromPage,position:1,force:!0}):Promise.resolve(!0)):Promise.reject(new Error("Move target is disabled: "+JSON.stringify(e)))},focusDate(t,e={}){var r=this;return this.move(t,e).then((function(){const e=r.$el.querySelector(`.id-${r.$locale.getDayId(t)}.in-month .vc-focusable`);return e?(e.focus(),Promise.resolve(!0)):Promise.resolve(!1)}))},showPageRange(t,e){let r,n;if(Object(ge["j"])(t))r=this.pageForDate(t);else{if(!Object(ge["m"])(t))return Promise.reject(new Error("Invalid page range provided."));{const{month:e,year:a}=t,{from:o,to:i}=t;Object(ge["l"])(e)&&Object(ge["l"])(a)?r=t:(o||i)&&(r=Object(ge["j"])(o)?this.pageForDate(o):o,n=Object(ge["j"])(i)?this.pageForDate(i):i)}}const a=this.lastPage;let o=r;return Object(me["n"])(n,a)&&(o=Object(me["a"])(n,-(this.pages.length-1))),Object(me["o"])(o,r)&&(o=r),this.refreshPages({...e,page:o})},getTargetPageRange(t,{position:e,force:r}={}){let n=null,a=null;if(Object(me["r"])(t)){let r=0;e=+e,isNaN(e)||(r=e>0?1-e:-(this.count+e)),n=Object(me["a"])(t,r)}else n=this.getDefaultInitialPage();return a=Object(me["a"])(n,this.count-1),r||(Object(me["o"])(n,this.minPage_)?n=this.minPage_:Object(me["n"])(a,this.maxPage_)&&(n=Object(me["a"])(this.maxPage_,1-this.count)),a=Object(me["a"])(n,this.count-1)),{fromPage:n,toPage:a}},getDefaultInitialPage(){let t=this.fromPage||this.pageForDate(this.fromDate);if(!Object(me["r"])(t)){const e=this.toPage||this.pageForDate(this.toPage);Object(me["r"])(e)&&(t=Object(me["a"])(e,1-this.count))}return Object(me["r"])(t)||(t=this.getPageForAttributes()),Object(me["r"])(t)||(t=this.pageForThisMonth()),t},refreshPages({page:t,position:e=1,force:r,transition:n,ignoreCache:a}={}){var o=this;return new Promise((function(i,s){const{fromPage:c,toPage:u}=o.getTargetPageRange(t,{position:e,force:r}),l=[];for(let t=0;t<o.count;t++)l.push(o.buildPage(Object(me["a"])(c,t),a));o.refreshDisabledDays(l),o.refreshFocusableDays(l),o.transitionName=o.getPageTransition(o.pages[0],l[0],n),o.pages=l,o.$emit("update:from-page",c),o.$emit("update:to-page",u),o.transitionName&&"none"!==o.transitionName?o.transitionPromise={resolve:i,reject:s}:i(!0)}))},refreshDisabledDays(t){var e=this;this.getPageDays(t).forEach((function(t){t.isDisabled=!!e.disabledAttribute&&e.disabledAttribute.intersectsDay(t)}))},refreshFocusableDays(t){var e=this;this.getPageDays(t).forEach((function(t){t.isFocusable=t.inMonth&&t.day===e.focusableDay}))},getPageDays(t=this.pages){return t.reduce((function(t,e){return t.concat(e.days)}),[])},getPageTransition(t,e,r=this.transition){if("none"===r)return r;if("fade"===r||!r&&this.count>1||!Object(me["r"])(t)||!Object(me["r"])(e))return"fade";const n=Object(me["o"])(e,t);return"slide-v"===r?n?"slide-down":"slide-up":n?"slide-right":"slide-left"},getPageForAttributes(){let t=null;const e=this.store.pinAttr;if(e&&e.hasDates){let[r]=e.dates;r=r.start||r.date,t=this.pageForDate(r)}return t},buildPage({month:t,year:e},r){var n=this;const a=`${e.toString()}-${t.toString()}`;let o=this.pages.find((function(t){return t.key===a}));if(!o||r){const r=new Date(e,t-1,15),i=this.$locale.getMonthComps(t,e),s=this.$locale.getPrevMonthComps(t,e),c=this.$locale.getNextMonthComps(t,e);o={key:a,month:t,year:e,weeks:this.trimWeeks?i.weeks:6,title:this.$locale.format(r,this.$locale.masks.title),shortMonthLabel:this.$locale.format(r,"MMM"),monthLabel:this.$locale.format(r,"MMMM"),shortYearLabel:e.toString().substring(2),yearLabel:e.toString(),monthComps:i,prevMonthComps:s,nextMonthComps:c,canMove:function(t){return n.canMove(t)},move:function(t){return n.move(t)},moveThisMonth:function(){return n.moveThisMonth()},movePrevMonth:function(){return n.move(s)},moveNextMonth:function(){return n.move(c)},refresh:!0},o.days=this.$locale.getCalendarDays(o)}return o},initStore(){this.store=new Er["a"](this.$theme,this.$locale,this.attributes),this.refreshAttrs(this.pages,this.store.list,[],!0)},refreshAttrs(t=[],e=[],r=[],n){var a=this;Object(me["b"])(t)&&(t.forEach((function(t){t.days.forEach((function(t){let a={};n?t.refresh=!0:Object(ge["f"])(t.attributesMap,r)?(a=Object(ge["s"])(t.attributesMap,r),t.refresh=!0):a=t.attributesMap||{},e.forEach((function(e){const r=e.intersectsDay(t);if(r){const n={...e,targetDate:r};a[e.key]=n,t.refresh=!0}})),t.refresh&&(t.attributesMap=a)}))})),this.$nextTick((function(){a.$refs.pages.forEach((function(t){return t.refresh()}))})))},handleKeydown(t){const e=this.lastFocusedDay;null!=e&&(e.event=t,this.handleDayKeydown(e))},handleDayKeydown(t){const{dateFromTime:e,event:r}=t,a=e(12);let o=null;switch(r.key){case"ArrowLeft":o=Object(n["a"])(a,-1);break;case"ArrowRight":o=Object(n["a"])(a,1);break;case"ArrowUp":o=Object(n["a"])(a,-7);break;case"ArrowDown":o=Object(n["a"])(a,7);break;case"Home":o=Object(n["a"])(a,1-t.weekdayPosition);break;case"End":o=Object(n["a"])(a,t.weekdayPositionFromEnd);break;case"PageUp":o=r.altKey?c(a,-1):s(a,-1);break;case"PageDown":o=r.altKey?c(a,1):s(a,1);break}o&&(r.preventDefault(),this.focusDate(o).catch((function(){})))}}}),Cr=Ir,$r=(r("1c6b"),xe(Cr,mr,gr,!1,null,null,null)),Ar=$r.exports,Nr=function(){var t=this,e=t._self._c;return e("div",{staticClass:"vc-time-picker",class:[{"vc-disabled":t.isDisabled,"vc-bordered":t.showBorder}]},[e("div",[e("svg",{staticClass:"vc-time-icon",attrs:{fill:"none","stroke-linecap":"round","stroke-linejoin":"round","stroke-width":"2",viewBox:"0 0 24 24",stroke:"currentColor"}},[e("path",{attrs:{d:"M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"}})])]),e("div",{staticClass:"vc-date-time"},[t.date?e("div",{staticClass:"vc-date"},[e("span",{staticClass:"vc-weekday"},[t._v(" "+t._s(t.locale.format(t.date,"WWW"))+" ")]),e("span",{staticClass:"vc-month"},[t._v(" "+t._s(t.locale.format(t.date,"MMM"))+" ")]),e("span",{staticClass:"vc-day"},[t._v(" "+t._s(t.locale.format(t.date,"D"))+" ")]),e("span",{staticClass:"vc-year"},[t._v(" "+t._s(t.locale.format(t.date,"YYYY"))+" ")])]):t._e(),e("div",{staticClass:"vc-time"},[e("time-select",{attrs:{options:t.hourOptions_},model:{value:t.hours,callback:function(e){t.hours=t._n(e)},expression:"hours"}}),e("span",{staticStyle:{margin:"0 4px"}},[t._v(":")]),e("time-select",{attrs:{options:t.minuteOptions},model:{value:t.minutes,callback:function(e){t.minutes=t._n(e)},expression:"minutes"}}),t.is24hr?t._e():e("div",{staticClass:"vc-am-pm",class:{"vc-disabled":!(t.hours>=0)}},[e("button",{class:{active:t.isAM,"vc-disabled":t.amDisabled},attrs:{type:"button"},on:{click:function(e){e.preventDefault(),t.isAM=!0}}},[t._v(" AM ")]),e("button",{class:{active:!t.isAM,"vc-disabled":t.pmDisabled},attrs:{type:"button"},on:{click:function(e){e.preventDefault(),t.isAM=!1}}},[t._v(" PM ")])])],1)])])},Fr=[],zr=function(){var t=this,e=t._self._c;return e("div",{staticClass:"vc-select"},[e("select",t._b({directives:[{name:"model",rawName:"v-model",value:t.model,expression:"model"}],on:{change:function(e){var r=Array.prototype.filter.call(e.target.options,(function(t){return t.selected})).map((function(t){var e="_value"in t?t._value:t.value;return e}));t.model=e.target.multiple?r:r[0]}}},"select",t.$attrs,!1),t._l(t.options,(function(r){return e("option",{key:r.value,attrs:{disabled:r.disabled},domProps:{value:r.value}},[t._v(" "+t._s(r.label)+" ")])})),0),e("div",{staticClass:"vc-select-arrow"},[e("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20"}},[e("path",{attrs:{d:"M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"}})])])])},Hr=[],Lr={inheritAttrs:!1,props:{options:Array,value:Number},computed:{model:{get(){return this.value},set(t){this.$emit("input",t)}}}},Wr=Lr,Vr=(r("47c6"),xe(Wr,zr,Hr,!1,null,"7b2eaf0a",null)),Rr=Vr.exports;const Ur=[{value:0,label:"12"},{value:1,label:"1"},{value:2,label:"2"},{value:3,label:"3"},{value:4,label:"4"},{value:5,label:"5"},{value:6,label:"6"},{value:7,label:"7"},{value:8,label:"8"},{value:9,label:"9"},{value:10,label:"10"},{value:11,label:"11"}],Br=[{value:12,label:"12"},{value:13,label:"1"},{value:14,label:"2"},{value:15,label:"3"},{value:16,label:"4"},{value:17,label:"5"},{value:18,label:"6"},{value:19,label:"7"},{value:20,label:"8"},{value:21,label:"9"},{value:22,label:"10"},{value:23,label:"11"}];var Zr={name:"TimePicker",components:{TimeSelect:Rr},props:{value:{type:Object,required:!0},locale:{type:Object,required:!0},theme:{type:Object,required:!0},is24hr:{type:Boolean,default:!0},showBorder:Boolean,isDisabled:Boolean,hourOptions:Array,minuteOptions:Array},computed:{date(){let t=this.locale.normalizeDate(this.value);return 24===this.value.hours&&(t=new Date(t.getTime()-1)),t},hours:{get(){return this.value.hours},set(t){this.updateValue(t,this.minutes)}},minutes:{get(){return this.value.minutes},set(t){this.updateValue(this.hours,t)}},isAM:{get(){return this.value.hours<12},set(t){let e=this.hours;t&&e>=12?e-=12:!t&&e<12&&(e+=12),this.updateValue(e,this.minutes)}},amHourOptions(){var t=this;return Ur.filter((function(e){return t.hourOptions.some((function(t){return t.value===e.value}))}))},pmHourOptions(){var t=this;return Br.filter((function(e){return t.hourOptions.some((function(t){return t.value===e.value}))}))},hourOptions_(){return this.is24hr?this.hourOptions:this.isAM?this.amHourOptions:this.pmHourOptions},amDisabled(){return!Object(me["b"])(this.amHourOptions)},pmDisabled(){return!Object(me["b"])(this.pmHourOptions)}},methods:{updateValue(t,e){t===this.hours&&e===this.minutes||this.$emit("input",{...this.value,hours:t,minutes:e,seconds:0,milliseconds:0})}}},qr=Zr,Gr=(r("e177"),xe(qr,Nr,Fr,!1,null,"f4e11af8",null)),Kr=Gr.exports;const Xr={type:"auto",mask:"iso",timeAdjust:""},Jr=[Xr,Xr],Qr={DATE:"date",DATE_TIME:"datetime",TIME:"time"},tn={NONE:0,START:1,END:2,BOTH:3};var en,rn,nn={name:"DatePicker",render(t){var e=this;const r=function(){if(!e.dateParts)return null;const r=e.isRange?e.dateParts:[e.dateParts[0]];return t("div",[...r.map((function(r,n){const a=e.$locale.getHourOptions(e.modelConfig_[n].validHours,r),o=e.$locale.getMinuteOptions(e.modelConfig_[n].minuteIncrement,r);return t(Kr,{props:{value:r,locale:e.$locale,theme:e.$theme,is24hr:e.is24hr,minuteIncrement:e.minuteIncrement,showBorder:!e.isTime,isDisabled:e.isDateTime&&!r.isValid||e.isDragging,hourOptions:a,minuteOptions:o},on:{input:function(t){return e.onTimeInput(t,0===n)}}})})),e.$scopedSlots.footer&&e.$scopedSlots.footer()])},n=function(){return t(Ar,{attrs:{...e.$attrs,attributes:e.attributes_,theme:e.$theme,locale:e.$locale},props:{minDate:e.minDateExact||e.minDate,maxDate:e.maxDateExact||e.maxDate,disabledDates:e.disabledDates,availableDates:e.availableDates},on:{...e.$listeners,dayclick:e.onDayClick,daykeydown:e.onDayKeydown,daymouseenter:e.onDayMouseEnter},scopedSlots:{...e.$scopedSlots,footer:e.isDateTime?r:e.$scopedSlots.footer},ref:"calendar"})},a=function(){return e.isTime?t("div",{class:["vc-container","vc-"+e.$theme.color,{"vc-is-dark":e.$theme.isDark}]},[r()]):n()};return this.$scopedSlots.default&&t("span",[this.$scopedSlots.default(this.slotArgs),t(Oe,{props:{id:this.datePickerPopoverId,placement:"bottom-start",contentClass:"vc-container"+(this.isDark?" vc-is-dark":"")},on:{beforeShow:function(t){return e.$emit("popoverWillShow",t)},afterShow:function(t){return e.$emit("popoverDidShow",t)},beforeHide:function(t){return e.$emit("popoverWillHide",t)},afterHide:function(t){return e.$emit("popoverDidHide",t)}},scopedSlots:{default(){return a()}},ref:"popover"})])||a()},mixins:[Fe],props:{mode:{type:String,default:Qr.DATE},value:{type:null,required:!0},modelConfig:{type:Object,default:function(){return{}}},is24hr:Boolean,minuteIncrement:Number,isRequired:Boolean,isRange:Boolean,updateOnInput:Boolean,inputDebounce:Number,popover:{type:Object,default:function(){return{}}},dragAttribute:Object,selectAttribute:Object,attributes:Array,validHours:[Object,Array,Function]},data(){return{value_:null,dateParts:null,activeDate:"",dragValue:null,inputValues:["",""],updateTimeout:null,watchValue:!0,datePickerPopoverId:Object(me["c"])()}},computed:{updateOnInput_(){return this.propOrDefault("updateOnInput","datePicker.updateOnInput")},inputDebounce_(){return this.propOrDefault("inputDebounce","datePicker.inputDebounce")},isDate(){return this.mode.toLowerCase()===Qr.DATE},isDateTime(){return this.mode.toLowerCase()===Qr.DATE_TIME},isTime(){return this.mode.toLowerCase()===Qr.TIME},isDragging(){return!!this.dragValue&&this.isRange},modelConfig_(){return this.normalizeConfig(this.modelConfig,Jr)},inputMask(){const t=this.$locale.masks;return this.isTime?this.is24hr?t.inputTime24hr:t.inputTime:this.isDateTime?this.is24hr?t.inputDateTime24hr:t.inputDateTime:this.$locale.masks.input},inputMaskHasTime(){return/[Hh]/g.test(this.inputMask)},inputMaskHasDate(){return/[dD]{1,2}|Do|W{1,4}|M{1,4}|YY(?:YY)?/g.test(this.inputMask)},inputMaskPatch(){return this.inputMaskHasTime&&this.inputMaskHasDate?Te["a"].DATE_TIME:this.inputMaskHasDate?Te["a"].DATE:this.inputMaskHasTime?Te["a"].TIME:void 0},slotArgs(){var t=this;const{isRange:e,isDragging:r,updateValue:n,showPopover:a,hidePopover:o,togglePopover:i}=this,s=e?{start:this.inputValues[0],end:this.inputValues[1]}:this.inputValues[0],c=[!0,!1].map((function(e){return{input:t.onInputInput(e),change:t.onInputChange(e),keyup:t.onInputKeyup,...lr({...t.popover_,id:t.datePickerPopoverId,callback:function(r){"show"===r.action&&r.completed&&t.onInputShow(e)}})}})),u=e?{start:c[0],end:c[1]}:c[0];return{inputValue:s,inputEvents:u,isDragging:r,updateValue:n,showPopover:a,hidePopover:o,togglePopover:i,getPopoverTriggerEvents:lr}},popover_(){return this.propOrDefault("popover","datePicker.popover","merge")},selectAttribute_(){if(!this.hasValue(this.value_))return null;const t={key:"select-drag",...this.selectAttribute,dates:this.value_,pinPage:!0},{dot:e,bar:r,highlight:n,content:a}=t;return e||r||n||a||(t.highlight=!0),t},dragAttribute_(){if(!this.isRange||!this.hasValue(this.dragValue))return null;const t={key:"select-drag",...this.dragAttribute,dates:this.dragValue},{dot:e,bar:r,highlight:n,content:a}=t;return e||r||n||a||(t.highlight={startEnd:{fillMode:"outline"}}),t},attributes_(){const t=Object(ge["h"])(this.attributes)?[...this.attributes]:[];return this.dragAttribute_?t.push(this.dragAttribute_):this.selectAttribute_&&t.push(this.selectAttribute_),t}},watch:{inputMask(){this.formatInput()},value(t){this.watchValue&&this.forceUpdateValue(t,{config:this.modelConfig_,notify:!1,formatInput:!0,hidePopover:!1})},value_(){this.refreshDateParts()},dragValue(){this.refreshDateParts()},timezone(){this.refreshDateParts(),this.forceUpdateValue(this.value_,{formatInput:!0})}},created(){this.value_=this.normalizeValue(this.value,this.modelConfig_,Te["a"].DATE_TIME,tn.BOTH),this.forceUpdateValue(this.value,{config:this.modelConfig_,formatInput:!0,hidePopover:!1}),this.refreshDateParts()},mounted(){Object(me["k"])(document,"keydown",this.onDocumentKeyDown),Object(me["k"])(document,"click",this.onDocumentClick)},destroyed(){Object(me["j"])(document,"keydown",this.onDocumentKeyDown),Object(me["j"])(document,"click",this.onDocumentClick)},methods:{getDateParts(t){return this.$locale.getDateParts(t)},getDateFromParts(t){return this.$locale.getDateFromParts(t)},refreshDateParts(){var t=this;const e=this.dragValue||this.value_,r=[];this.isRange?(e&&e.start?r.push(this.getDateParts(e.start)):r.push({}),e&&e.end?r.push(this.getDateParts(e.end)):r.push({})):e?e&&e.start?r.push(this.getDateParts(e.start)):r.push(this.getDateParts(e)):r.push({}),this.$nextTick((function(){return t.dateParts=r}))},onDocumentKeyDown(t){this.dragValue&&"Escape"===t.key&&(this.dragValue=null)},onDocumentClick(t){document.body.contains(t.target)&&!Object(me["e"])(this.$el,t.target)&&(this.dragValue=null,this.formatInput())},onDayClick(t){this.handleDayClick(t),this.$emit("dayclick",t)},onDayKeydown(t){switch(t.event.key){case" ":case"Enter":this.handleDayClick(t),t.event.preventDefault();break;case"Escape":this.hidePopover()}this.$emit("daykeydown",t)},handleDayClick(t){const{keepVisibleOnInput:e,visibility:r}=this.popover_,n={patch:Te["a"].DATE,adjustTime:!0,formatInput:!0,hidePopover:this.isDate&&!e&&"visible"!==r};this.isRange?(this.isDragging?this.dragTrackingValue.end=t.date:this.dragTrackingValue={...t.range},n.isDragging=!this.isDragging,n.rangePriority=n.isDragging?tn.NONE:tn.BOTH,n.hidePopover=n.hidePopover&&!n.isDragging,this.updateValue(this.dragTrackingValue,n)):(n.clearIfEqual=!this.isRequired,this.updateValue(t.date,n))},onDayMouseEnter(t){this.isDragging&&(this.dragTrackingValue.end=t.date,this.updateValue(this.dragTrackingValue,{patch:Te["a"].DATE,adjustTime:!0,formatInput:!0,hidePopover:!1,rangePriority:tn.NONE}))},onTimeInput(t,e){var r=this;let n=null;if(this.isRange){const r=e?t:this.dateParts[0],a=e?this.dateParts[1]:t;n={start:r,end:a}}else n=t;this.updateValue(n,{patch:Te["a"].TIME,rangePriority:e?tn.START:tn.END}).then((function(){return r.adjustPageRange(e)}))},onInputInput(t){var e=this;return function(r){e.updateOnInput_&&e.onInputUpdate(r.target.value,t,{formatInput:!1,hidePopover:!1,debounce:e.inputDebounce_})}},onInputChange(t){var e=this;return function(r){e.onInputUpdate(r.target.value,t,{formatInput:!0,hidePopover:!1})}},onInputUpdate(t,e,r){var n=this;this.inputValues.splice(e?0:1,1,t);const a=this.isRange?{start:this.inputValues[0],end:this.inputValues[1]||this.inputValues[0]}:t,o={type:"string",mask:this.inputMask};this.updateValue(a,{...r,config:o,patch:this.inputMaskPatch,rangePriority:e?tn.START:tn.END}).then((function(){return n.adjustPageRange(e)}))},onInputShow(t){this.adjustPageRange(t)},onInputKeyup(t){"Escape"===t.key&&this.updateValue(this.value_,{formatInput:!0,hidePopover:!0})},normalizeConfig(t,e=this.modelConfig_){var r=this;return t=Object(ge["h"])(t)?t:[t.start||t,t.end||t],e.map((function(e,n){return{validHours:r.validHours,minuteIncrement:r.minuteIncrement,...e,...t[n]}}))},updateValue(t,e={}){var r=this;return clearTimeout(this.updateTimeout),new Promise((function(n){const{debounce:a,...o}=e;a>0?r.updateTimeout=setTimeout((function(){r.forceUpdateValue(t,o),n(r.value_)}),a):(r.forceUpdateValue(t,o),n(r.value_))}))},forceUpdateValue(t,{config:e=this.modelConfig_,patch:r=Te["a"].DATE_TIME,clearIfEqual:n=!1,formatInput:a=!0,hidePopover:o=!1,isDragging:i=this.isDragging,rangePriority:s=tn.BOTH}={}){var c=this;e=this.normalizeConfig(e);let u=this.normalizeValue(t,e,r,s);!u&&this.isRequired&&(u=this.value_),u=this.adjustTimeForValue(u,e);const l=this.valueIsDisabled(u);if(l){if(i)return;u=this.value_,o=!1}const d=i?"dragValue":"value_";let f=!this.valuesAreEqual(this[d],u);if(l||f||!n||(u=null,f=!0),f){this.$set(this,d,u),i||(this.dragValue=null);const t=this.denormalizeValue(u),e=this.isDragging?"drag":"input";this.watchValue=!1,this.$emit(e,t),this.$nextTick((function(){return c.watchValue=!0}))}o&&this.hidePopover(),a&&this.formatInput()},hasValue(t){return this.isRange?Object(ge["m"])(t)&&!!t.start&&!!t.end:!!t},normalizeValue(t,e,r,n){if(!this.hasValue(t))return null;if(this.isRange){const a={},o=t.start>t.end?t.end:t.start;a.start=this.normalizeDate(o,{...e[0],fillDate:this.value_&&this.value_.start||e[0].fillDate,patch:r});const i=t.start>t.end?t.start:t.end;return a.end=this.normalizeDate(i,{...e[1],fillDate:this.value_&&this.value_.end||e[1].fillDate,patch:r}),this.sortRange(a,n)}return this.normalizeDate(t,{...e[0],fillDate:this.value_||e[0].fillDate,patch:r})},adjustTimeForValue(t,e){return this.hasValue(t)?this.isRange?{start:this.$locale.adjustTimeForDate(t.start,e[0]),end:this.$locale.adjustTimeForDate(t.end,e[1])}:this.$locale.adjustTimeForDate(t,e[0]):null},sortRange(t,e=tn.NONE){const{start:r,end:n}=t;if(r>n)switch(e){case tn.START:return{start:r,end:r};case tn.END:return{start:n,end:n};case tn.BOTH:return{start:n,end:r}}return{start:r,end:n}},denormalizeValue(t,e=this.modelConfig_){return this.isRange?this.hasValue(t)?{start:this.$locale.denormalizeDate(t.start,e[0]),end:this.$locale.denormalizeDate(t.end,e[1])}:null:this.$locale.denormalizeDate(t,e[0])},valuesAreEqual(t,e){if(this.isRange){const r=this.hasValue(t),n=this.hasValue(e);return!r&&!n||r===n&&(Object(me["d"])(t.start,e.start)&&Object(me["d"])(t.end,e.end))}return Object(me["d"])(t,e)},valueIsDisabled(t){return this.hasValue(t)&&this.disabledAttribute&&this.disabledAttribute.intersectsDate(t)},formatInput(){var t=this;this.$nextTick((function(){const e=t.normalizeConfig({type:"string",mask:t.inputMask}),r=t.denormalizeValue(t.dragValue||t.value_,e);t.isRange?t.inputValues=[r&&r.start,r&&r.end]:t.inputValues=[r,""]}))},showPopover(t={}){ir({ref:this.$el,...this.popover_,...t,isInteractive:!0,id:this.datePickerPopoverId})},hidePopover(t={}){sr({hideDelay:10,...this.popover_,...t,id:this.datePickerPopoverId})},togglePopover(t){cr({ref:this.$el,...this.popover_,...t,isInteractive:!0,id:this.datePickerPopoverId})},adjustPageRange(t){var e=this;this.$nextTick((function(){const r=e.$refs.calendar,n=e.getPageForValue(t),a=t?1:-1;n&&r&&!Object(me["p"])(n,r.firstPage,r.lastPage)&&r.move(n,{position:a,transition:"fade"})}))},getPageForValue(t){return this.hasValue(this.value_)?this.pageForDate(this.isRange?this.value_[t?"start":"end"]:this.value_):null},move(t,e){return this.$refs.calendar?this.$refs.calendar.move(t,e):Promise.reject(new Error("Navigation disabled while calendar is not yet displayed"))},focusDate(t,e){return this.$refs.calendar?this.$refs.calendar.focusDate(t,e):Promise.reject(new Error("Navigation disabled while calendar is not yet displayed"))}}},an=nn,on=xe(an,en,rn,!1,null,null,null),sn=on.exports},"2b10":function(t,e){function r(t,e,r){var n=-1,a=t.length;e<0&&(e=-e>a?0:a+e),r=r>a?a:r,r<0&&(r+=a),a=e>r?0:r-e>>>0,e>>>=0;var o=Array(a);while(++n<a)o[n]=t[n+e];return o}t.exports=r},"2b3e":function(t,e,r){var n=r("585a"),a="object"==typeof self&&self&&self.Object===Object&&self,o=n||a||Function("return this")();t.exports=o},"2ba4":function(t,e,r){"use strict";var n=r("40d5"),a=Function.prototype,o=a.apply,i=a.call;t.exports="object"==typeof Reflect&&Reflect.apply||(n?i.bind(o):function(){return i.apply(o,arguments)})},"2cfd":function(t,e,r){"use strict";function n(t){if(null===t||!0===t||!1===t)return NaN;var e=Number(t);return isNaN(e)?e:e<0?Math.ceil(e):Math.floor(e)}Object.defineProperty(e,"__esModule",{value:!0}),e.default=n,t.exports=e.default},"2d00":function(t,e,r){"use strict";var n,a,o=r("da84"),i=r("342f"),s=o.process,c=o.Deno,u=s&&s.versions||c&&c.version,l=u&&u.v8;l&&(n=l.split("."),a=n[0]>0&&n[0]<4?1:+(n[0]+n[1])),!a&&i&&(n=i.match(/Edge\/(\d+)/),(!n||n[1]>=74)&&(n=i.match(/Chrome\/(\d+)/),n&&(a=+n[1]))),t.exports=a},"2d7c":function(t,e){function r(t,e){var r=-1,n=null==t?0:t.length,a=0,o=[];while(++r<n){var i=t[r];e(i,r,t)&&(o[a++]=i)}return o}t.exports=r},"2dcb":function(t,e,r){var n=r("91e9"),a=n(Object.getPrototypeOf,Object);t.exports=a},"2ec1":function(t,e,r){var n=r("100e"),a=r("9aff");function o(t){return n((function(e,r){var n=-1,o=r.length,i=o>1?r[o-1]:void 0,s=o>2?r[2]:void 0;i=t.length>3&&"function"==typeof i?(o--,i):void 0,s&&a(r[0],r[1],s)&&(i=o<3?void 0:i,o=1),e=Object(e);while(++n<o){var c=r[n];c&&t(e,c,n,i)}return e}))}t.exports=o},"2fa3":function(t,e,r){"use strict";r.d(e,"m",(function(){return a})),r.d(e,"f",(function(){return o})),r.d(e,"h",(function(){return i})),r.d(e,"r",(function(){return s})),r.d(e,"o",(function(){return c})),r.d(e,"n",(function(){return u})),r.d(e,"p",(function(){return l})),r.d(e,"q",(function(){return d})),r.d(e,"a",(function(){return f})),r.d(e,"s",(function(){return p})),r.d(e,"d",(function(){return h})),r.d(e,"b",(function(){return v})),r.d(e,"i",(function(){return b})),r.d(e,"k",(function(){return m})),r.d(e,"j",(function(){return g})),r.d(e,"e",(function(){return y})),r.d(e,"l",(function(){return w})),r.d(e,"c",(function(){return x})),r.d(e,"g",(function(){return D}));r("14d9");var n=r("9404");const a=function(t,e,r="0"){t=null!==t&&void 0!==t?String(t):"",e=e||2;while(t.length<e)t=`${r}${t}`;return t},o=function(t,e){return Object(n["k"])(t)?t(e):t},i=function(...t){const e={};return t.forEach((function(t){return Object.entries(t).forEach((function([t,r]){e[t]?Object(n["h"])(e[t])?e[t].push(r):e[t]=[e[t],r]:e[t]=r}))})),e},s=function(t){return!!(t&&t.month&&t.year)},c=function(t,e){return!(!s(t)||!s(e))&&(t.year===e.year?t.month<e.month:t.year<e.year)},u=function(t,e){return!(!s(t)||!s(e))&&(t.year===e.year?t.month>e.month:t.year>e.year)},l=function(t,e,r){return!!t&&!c(t,e)&&!u(t,r)},d=function(t,e){return!(!t&&e)&&(!(t&&!e)&&(!t&&!e||t.month===e.month&&t.year===e.year))},f=function({month:t,year:e},r){const n=r>0?1:-1;for(let a=0;a<Math.abs(r);a++)t+=n,t>12?(t=1,e++):t<1&&(t=12,e--);return{month:t,year:e}},p=function(t,e){if(!s(t)||!s(e))return[];const r=[];while(!u(t,e))r.push(t),t=f(t,1);return r};function h(t,e){const r=Object(n["j"])(t),a=Object(n["j"])(e);return!r&&!a||r===a&&t.getTime()===e.getTime()}const v=function(t){return Object(n["h"])(t)&&t.length},b=function(t,e,r){const a=[];return r.forEach((function(r){const o=r.name||r.toString(),i=r.mixin,s=r.validate;if(Object.prototype.hasOwnProperty.call(t,o)){const r=s?s(t[o]):t[o];e[o]=i&&Object(n["m"])(r)?{...i,...r}:r,a.push(o)}})),{target:e,assigned:a.length?a:null}},m=function(t,e,r,n){t&&e&&r&&t.addEventListener(e,r,n)},g=function(t,e,r,n){t&&e&&t.removeEventListener(e,r,n)},y=function(t,e){return!!t&&!!e&&(t===e||t.contains(e))},w=function(t,e){" "!==t.key&&"Enter"!==t.key||(e(t),t.preventDefault())},x=function(){function t(){return(65536*(1+Math.random())|0).toString(16).substring(1)}return`${t()+t()}-${t()}-${t()}-${t()}-${t()}${t()}${t()}`};function D(t){let e,r=0,n=0;if(0===t.length)return r;for(n=0;n<t.length;n++)e=t.charCodeAt(n),r=(r<<5)-r+e,r|=0;return r}},"2fcc":function(t,e){function r(t){var e=this.__data__,r=e["delete"](t);return this.size=e.size,r}t.exports=r},"2feb":function(t,e,r){var n=r("d798");n.__esModule&&(n=n.default),"string"===typeof n&&(n=[[t.i,n,""]]),n.locals&&(t.exports=n.locals);var a=r("499e").default;a("010e9ae0",n,!0,{sourceMap:!1,shadowMode:!1})},3092:function(t,e,r){var n=r("4284"),a=r("badf"),o=r("361d"),i=r("6747"),s=r("9aff");function c(t,e,r){var c=i(t)?n:o;return r&&s(t,e,r)&&(e=void 0),c(t,a(e,3))}t.exports=c},"30c9":function(t,e,r){var n=r("9520"),a=r("b218");function o(t){return null!=t&&a(t.length)&&!n(t)}t.exports=o},"32b3":function(t,e,r){var n=r("872a"),a=r("9638"),o=Object.prototype,i=o.hasOwnProperty;function s(t,e,r){var o=t[e];i.call(t,e)&&a(o,r)&&(void 0!==r||e in t)||n(t,e,r)}t.exports=s},"32f4":function(t,e,r){var n=r("2d7c"),a=r("d327"),o=Object.prototype,i=o.propertyIsEnumerable,s=Object.getOwnPropertySymbols,c=s?function(t){return null==t?[]:(t=Object(t),n(s(t),(function(e){return i.call(t,e)})))}:a;t.exports=c},"342f":function(t,e,r){"use strict";t.exports="undefined"!=typeof navigator&&String(navigator.userAgent)||""},"34ac":function(t,e,r){var n=r("9520"),a=r("1368"),o=r("1a8c"),i=r("dc57"),s=/[\\^$.*+?()[\]{}|]/g,c=/^\[object .+?Constructor\]$/,u=Function.prototype,l=Object.prototype,d=u.toString,f=l.hasOwnProperty,p=RegExp("^"+d.call(f).replace(s,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");function h(t){if(!o(t)||a(t))return!1;var e=n(t)?p:c;return e.test(i(t))}t.exports=h},"34e9":function(t,e,r){"use strict";(function(t){var n=r("2af9"),a=r("ed08");function o(t,e){if(o.installed)return;o.installed=!0;const r=a["setupCalendar"](e);Object.entries(n).forEach((function([e,n]){t.component(`${r.componentPrefix}${e}`,n)}))}r.d(e,"c",(function(){return n["Calendar"]})),r.d(e,"d",(function(){return n["CalendarNav"]})),r.d(e,"f",(function(){return n["DatePicker"]})),r.d(e,"h",(function(){return n["Popover"]})),r.d(e,"a",(function(){return a["Attribute"]})),r.d(e,"b",(function(){return a["AttributeStore"]})),r.d(e,"e",(function(){return a["DateInfo"]})),r.d(e,"g",(function(){return a["Locale"]})),r.d(e,"i",(function(){return a["addHorizontalSwipeHandler"]})),r.d(e,"j",(function(){return a["addPages"]})),r.d(e,"k",(function(){return a["arrayHasItems"]})),r.d(e,"l",(function(){return a["createGuid"]})),r.d(e,"m",(function(){return a["datesAreEqual"]})),r.d(e,"o",(function(){return a["elementContains"]})),r.d(e,"p",(function(){return a["evalFn"]})),r.d(e,"q",(function(){return a["hash"]})),r.d(e,"r",(function(){return a["mergeEvents"]})),r.d(e,"s",(function(){return a["mixinOptionalProps"]})),r.d(e,"t",(function(){return a["off"]})),r.d(e,"u",(function(){return a["on"]})),r.d(e,"v",(function(){return a["onSpaceOrEnter"]})),r.d(e,"w",(function(){return a["pad"]})),r.d(e,"x",(function(){return a["pageIsAfterPage"]})),r.d(e,"y",(function(){return a["pageIsBeforePage"]})),r.d(e,"z",(function(){return a["pageIsBetweenPages"]})),r.d(e,"A",(function(){return a["pageIsEqualToPage"]})),r.d(e,"B",(function(){return a["pageIsValid"]})),r.d(e,"C",(function(){return a["pageRangeToArray"]})),r.d(e,"D",(function(){return a["setupCalendar"]}));const i={install:o,...n,...a};let s=null;"undefined"!==typeof window?s=window.Vue:"undefined"!==typeof t&&(s=t.Vue),s&&s.use(i),e["n"]=i}).call(this,r("c8ba"))},3511:function(t,e,r){"use strict";var n=TypeError,a=9007199254740991;t.exports=function(t){if(t>a)throw n("Maximum allowed index exceeded");return t}},"361d":function(t,e,r){var n=r("48a0");function a(t,e){var r;return n(t,(function(t,n,a){return r=e(t,n,a),!r})),!!r}t.exports=a},3698:function(t,e){function r(t,e){return null==t?void 0:t[e]}t.exports=r},3729:function(t,e,r){var n=r("9e69"),a=r("00fd"),o=r("29f3"),i="[object Null]",s="[object Undefined]",c=n?n.toStringTag:void 0;function u(t){return null==t?void 0===t?s:i:c&&c in Object(t)?a(t):o(t)}t.exports=u},3818:function(t,e,r){var n=r("7e64"),a=r("8057"),o=r("32b3"),i=r("5b01"),s=r("0f0f"),c=r("e538"),u=r("4359"),l=r("54eb"),d=r("1041"),f=r("a994"),p=r("1bac"),h=r("42a2"),v=r("c87c"),b=r("c2b6"),m=r("fa21"),g=r("6747"),y=r("0d24"),w=r("cc45"),x=r("1a8c"),D=r("d7ee"),O=r("ec69"),j=r("9934"),k=1,M=2,P=4,Y="[object Arguments]",S="[object Array]",_="[object Boolean]",E="[object Date]",T="[object Error]",I="[object Function]",C="[object GeneratorFunction]",$="[object Map]",A="[object Number]",N="[object Object]",F="[object RegExp]",z="[object Set]",H="[object String]",L="[object Symbol]",W="[object WeakMap]",V="[object ArrayBuffer]",R="[object DataView]",U="[object Float32Array]",B="[object Float64Array]",Z="[object Int8Array]",q="[object Int16Array]",G="[object Int32Array]",K="[object Uint8Array]",X="[object Uint8ClampedArray]",J="[object Uint16Array]",Q="[object Uint32Array]",tt={};function et(t,e,r,S,_,E){var T,$=e&k,A=e&M,F=e&P;if(r&&(T=_?r(t,S,_,E):r(t)),void 0!==T)return T;if(!x(t))return t;var z=g(t);if(z){if(T=v(t),!$)return u(t,T)}else{var H=h(t),L=H==I||H==C;if(y(t))return c(t,$);if(H==N||H==Y||L&&!_){if(T=A||L?{}:m(t),!$)return A?d(t,s(T,t)):l(t,i(T,t))}else{if(!tt[H])return _?t:{};T=b(t,H,$)}}E||(E=new n);var W=E.get(t);if(W)return W;E.set(t,T),D(t)?t.forEach((function(n){T.add(et(n,e,r,n,t,E))})):w(t)&&t.forEach((function(n,a){T.set(a,et(n,e,r,a,t,E))}));var V=F?A?p:f:A?j:O,R=z?void 0:V(t);return a(R||t,(function(n,a){R&&(a=n,n=t[a]),o(T,a,et(n,e,r,a,t,E))})),T}tt[Y]=tt[S]=tt[V]=tt[R]=tt[_]=tt[E]=tt[U]=tt[B]=tt[Z]=tt[q]=tt[G]=tt[$]=tt[A]=tt[N]=tt[F]=tt[z]=tt[H]=tt[L]=tt[K]=tt[X]=tt[J]=tt[Q]=!0,tt[T]=tt[I]=tt[W]=!1,t.exports=et},3852:function(t,e,r){var n=r("96f3"),a=r("e2c0");function o(t,e){return null!=t&&a(t,e,n)}t.exports=o},"386f":function(t,e,r){var n=r("24fb");e=n(!1),e.push([t.i,".vc-time-picker[data-v-f4e11af8]{display:flex;align-items:center;padding:8px}.vc-time-picker.vc-invalid[data-v-f4e11af8]{pointer-events:none;opacity:.5}.vc-time-picker.vc-bordered[data-v-f4e11af8]{border-top:1px solid var(--gray-400)}.vc-date-time[data-v-f4e11af8]{margin-left:8px}.vc-disabled[data-v-f4e11af8]{pointer-events:none;opacity:.5}.vc-time-icon[data-v-f4e11af8]{width:16px;height:16px;color:var(--gray-600)}.vc-date[data-v-f4e11af8]{display:flex;align-items:center;font-size:var(--text-sm);font-weight:var(--font-semibold);text-transform:uppercase;padding:0 0 4px 4px;margin-top:-4px}.vc-date .vc-weekday[data-v-f4e11af8]{color:var(--gray-700);letter-spacing:var(--tracking-wide)}.vc-date .vc-month[data-v-f4e11af8]{color:var(--accent-600);margin-left:8px}.vc-date .vc-day[data-v-f4e11af8]{color:var(--accent-600);margin-left:4px}.vc-date .vc-year[data-v-f4e11af8]{color:var(--gray-500);margin-left:8px}.vc-am-pm[data-v-f4e11af8],.vc-time[data-v-f4e11af8]{display:flex;align-items:center}.vc-am-pm[data-v-f4e11af8]{background:var(--gray-200);margin-left:8px;padding:4px;border-radius:var(--rounded);height:30px}.vc-am-pm button[data-v-f4e11af8]{color:var(--gray-900);font-size:var(--text-sm);font-weight:var(--font-medium);padding:0 4px;background:transparent;border:2px solid transparent;border-radius:var(--rounded);line-height:var(--leading-snug)}.vc-am-pm button[data-v-f4e11af8]:hover{color:var(--gray-600)}.vc-am-pm button[data-v-f4e11af8]:focus{border-color:var(--accent-400)}.vc-am-pm button.active[data-v-f4e11af8]{background:var(--accent-600);color:var(--white)}.vc-am-pm button.active[data-v-f4e11af8]:hover{background:var(--accent-500)}.vc-am-pm button.active[data-v-f4e11af8]:focus{border-color:var(--accent-400)}.vc-is-dark .vc-time-picker[data-v-f4e11af8]{border-color:var(--gray-700)}.vc-is-dark .vc-time-icon[data-v-f4e11af8],.vc-is-dark .vc-weekday[data-v-f4e11af8]{color:var(--gray-400)}.vc-is-dark .vc-day[data-v-f4e11af8],.vc-is-dark .vc-month[data-v-f4e11af8]{color:var(--accent-400)}.vc-is-dark .vc-year[data-v-f4e11af8]{color:var(--gray-500)}.vc-is-dark .vc-am-pm[data-v-f4e11af8]{background:var(--gray-700)}.vc-is-dark .vc-am-pm[data-v-f4e11af8]:focus{border-color:var(--accent-500)}.vc-is-dark .vc-am-pm button[data-v-f4e11af8]{color:var(--gray-100)}.vc-is-dark .vc-am-pm button[data-v-f4e11af8]:hover{color:var(--gray-400)}.vc-is-dark .vc-am-pm button[data-v-f4e11af8]:focus{border-color:var(--accent-500)}.vc-is-dark .vc-am-pm button.active[data-v-f4e11af8]{background:var(--accent-500);color:var(--white)}.vc-is-dark .vc-am-pm button.active[data-v-f4e11af8]:hover{background:var(--accent-600)}.vc-is-dark .vc-am-pm button.active[data-v-f4e11af8]:focus{border-color:var(--accent-500)}",""]),t.exports=e},3963:function(t,e,r){var n=r("24fb");e=n(!1),e.push([t.i,".vc-day[data-v-4420d078]{position:relative;min-height:32px;z-index:1}.vc-day.is-not-in-month *[data-v-4420d078]{opacity:0;pointer-events:none}.vc-day-layer[data-v-4420d078]{position:absolute;left:0;right:0;top:0;bottom:0;pointer-events:none}.vc-day-box-center-center[data-v-4420d078]{display:flex;justify-content:center;align-items:center;transform-origin:50% 50%}.vc-day-box-left-center[data-v-4420d078]{display:flex;justify-content:flex-start;align-items:center;transform-origin:0 50%}.vc-day-box-right-center[data-v-4420d078]{display:flex;justify-content:flex-end;align-items:center;transform-origin:100% 50%}.vc-day-box-center-bottom[data-v-4420d078]{display:flex;justify-content:center;align-items:flex-end}.vc-day-content[data-v-4420d078]{display:flex;justify-content:center;align-items:center;font-size:var(--text-sm);font-weight:var(--font-medium);width:28px;height:28px;line-height:28px;border-radius:var(--rounded-full);-webkit-user-select:none;user-select:none;cursor:pointer}.vc-day-content[data-v-4420d078]:hover{background-color:rgba(204,214,224,.3)}.vc-day-content[data-v-4420d078]:focus{font-weight:var(--font-bold);background-color:rgba(204,214,224,.4)}.vc-day-content.is-disabled[data-v-4420d078]{color:var(--gray-400)}.vc-is-dark .vc-day-content[data-v-4420d078]:hover{background-color:rgba(114,129,151,.3)}.vc-is-dark .vc-day-content[data-v-4420d078]:focus{background-color:rgba(114,129,151,.4)}.vc-is-dark .vc-day-content.is-disabled[data-v-4420d078]{color:var(--gray-600)}.vc-highlights[data-v-4420d078]{overflow:hidden;pointer-events:none;z-index:-1}.vc-highlight[data-v-4420d078]{width:28px;height:28px}.vc-highlight.vc-highlight-base-start[data-v-4420d078]{width:50%!important;border-radius:0!important;border-right-width:0!important}.vc-highlight.vc-highlight-base-end[data-v-4420d078]{width:50%!important;border-radius:0!important;border-left-width:0!important}.vc-highlight.vc-highlight-base-middle[data-v-4420d078]{width:100%;border-radius:0!important;border-left-width:0!important;border-right-width:0!important;margin:0 -1px}.vc-dots[data-v-4420d078]{display:flex;justify-content:center;align-items:center}.vc-dot[data-v-4420d078]{width:5px;height:5px;border-radius:50%;transition:all var(--day-content-transition-time)}.vc-dot[data-v-4420d078]:not(:last-child){margin-right:3px}.vc-bars[data-v-4420d078]{display:flex;justify-content:flex-start;align-items:center;width:75%}.vc-bar[data-v-4420d078]{flex-grow:1;height:3px;transition:all var(--day-content-transition-time)}",""]),t.exports=e},"39ff":function(t,e,r){var n=r("0b07"),a=r("2b3e"),o=n(a,"WeakMap");t.exports=o},"3a34":function(t,e,r){"use strict";var n=r("83ab"),a=r("e8b5"),o=TypeError,i=Object.getOwnPropertyDescriptor,s=n&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(t){return t instanceof TypeError}}();t.exports=s?function(t,e){if(a(t)&&!i(t,"length").writable)throw new o("Cannot set read only .length");return t.length=e}:function(t,e){return t.length=e}},"3a9b":function(t,e,r){"use strict";var n=r("e330");t.exports=n({}.isPrototypeOf)},"3b4a":function(t,e,r){var n=r("0b07"),a=function(){try{var t=n(Object,"defineProperty");return t({},"",{}),t}catch(e){}}();t.exports=a},"3bb4":function(t,e,r){var n=r("08cc"),a=r("ec69");function o(t){var e=a(t),r=e.length;while(r--){var o=e[r],i=t[o];e[r]=[o,i,n(i)]}return e}t.exports=o},"3bbe":function(t,e,r){"use strict";var n=r("1626"),a=String,o=TypeError;t.exports=function(t){if("object"==typeof t||n(t))return t;throw new o("Can't set "+a(t)+" as a prototype")}},"3c65":function(t,e,r){"use strict";var n=r("23e7"),a=r("7b0b"),o=r("07fa"),i=r("3a34"),s=r("083a"),c=r("3511"),u=1!==[].unshift(0),l=function(){try{Object.defineProperty([],"length",{writable:!1}).unshift()}catch(t){return t instanceof TypeError}},d=u||!l();n({target:"Array",proto:!0,arity:1,forced:d},{unshift:function(t){var e=a(this),r=o(e),n=arguments.length;if(n){c(r+n);var u=r;while(u--){var l=u+n;u in e?e[l]=e[u]:s(e,l)}for(var d=0;d<n;d++)e[d]=arguments[d]}return i(e,r+n)}})},"3ee2":function(t,e,r){var n=r("dc8c");n.__esModule&&(n=n.default),"string"===typeof n&&(n=[[t.i,n,""]]),n.locals&&(t.exports=n.locals);var a=r("499e").default;a("72fef618",n,!0,{sourceMap:!1,shadowMode:!1})},"3eea":function(t,e,r){var n=r("7948"),a=r("3818"),o=r("4bb5"),i=r("e2e4"),s=r("8eeb"),c=r("e0e7"),u=r("c6cf"),l=r("1bac"),d=1,f=2,p=4,h=u((function(t,e){var r={};if(null==t)return r;var u=!1;e=n(e,(function(e){return e=i(e,t),u||(u=e.length>1),e})),s(t,l(t),r),u&&(r=a(r,d|f|p,c));var h=e.length;while(h--)o(r,e[h]);return r}));t.exports=h},"3f84":function(t,e,r){var n=r("85e3"),a=r("100e"),o=r("e031"),i=r("2411"),s=a((function(t){return t.push(void 0,o),n(i,void 0,t)}));t.exports=s},"40d5":function(t,e,r){"use strict";var n=r("d039");t.exports=!n((function(){var t=function(){}.bind();return"function"!=typeof t||t.hasOwnProperty("prototype")}))},"41c3":function(t,e,r){var n=r("1a8c"),a=r("eac5"),o=r("ec8c"),i=Object.prototype,s=i.hasOwnProperty;function c(t){if(!n(t))return o(t);var e=a(t),r=[];for(var i in t)("constructor"!=i||!e&&s.call(t,i))&&r.push(i);return r}t.exports=c},4245:function(t,e,r){var n=r("1290");function a(t,e){var r=t.__data__;return n(e)?r["string"==typeof e?"string":"hash"]:r.map}t.exports=a},4284:function(t,e){function r(t,e){var r=-1,n=null==t?0:t.length;while(++r<n)if(e(t[r],r,t))return!0;return!1}t.exports=r},"42a2":function(t,e,r){var n=r("b5a7"),a=r("79bc"),o=r("1cec"),i=r("c869"),s=r("39ff"),c=r("3729"),u=r("dc57"),l="[object Map]",d="[object Object]",f="[object Promise]",p="[object Set]",h="[object WeakMap]",v="[object DataView]",b=u(n),m=u(a),g=u(o),y=u(i),w=u(s),x=c;(n&&x(new n(new ArrayBuffer(1)))!=v||a&&x(new a)!=l||o&&x(o.resolve())!=f||i&&x(new i)!=p||s&&x(new s)!=h)&&(x=function(t){var e=c(t),r=e==d?t.constructor:void 0,n=r?u(r):"";if(n)switch(n){case b:return v;case m:return l;case g:return f;case y:return p;case w:return h}return e}),t.exports=x},4359:function(t,e){function r(t,e){var r=-1,n=t.length;e||(e=Array(n));while(++r<n)e[r]=t[r];return e}t.exports=r},4416:function(t,e){function r(t){var e=null==t?0:t.length;return e?t[e-1]:void 0}t.exports=r},"44ad":function(t,e,r){"use strict";var n=r("e330"),a=r("d039"),o=r("c6b6"),i=Object,s=n("".split);t.exports=a((function(){return!i("z").propertyIsEnumerable(0)}))?function(t){return"String"===o(t)?s(t,""):i(t)}:i},4638:function(t,e,r){"use strict";r("6562")},"47c6":function(t,e,r){"use strict";r("1205")},"485a":function(t,e,r){"use strict";var n=r("c65b"),a=r("1626"),o=r("861d"),i=TypeError;t.exports=function(t,e){var r,s;if("string"===e&&a(r=t.toString)&&!o(s=n(r,t)))return s;if(a(r=t.valueOf)&&!o(s=n(r,t)))return s;if("string"!==e&&a(r=t.toString)&&!o(s=n(r,t)))return s;throw new i("Can't convert object to primitive value")}},"48a0":function(t,e,r){var n=r("242e"),a=r("950a"),o=a(n);t.exports=o},"499e":function(t,e,r){"use strict";function n(t,e){for(var r=[],n={},a=0;a<e.length;a++){var o=e[a],i=o[0],s=o[1],c=o[2],u=o[3],l={id:t+":"+a,css:s,media:c,sourceMap:u};n[i]?n[i].parts.push(l):r.push(n[i]={id:i,parts:[l]})}return r}r.r(e),r.d(e,"default",(function(){return h}));var a="undefined"!==typeof document;if("undefined"!==typeof DEBUG&&DEBUG&&!a)throw new Error("vue-style-loader cannot be used in a non-browser environment. Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.");var o={},i=a&&(document.head||document.getElementsByTagName("head")[0]),s=null,c=0,u=!1,l=function(){},d=null,f="data-vue-ssr-id",p="undefined"!==typeof navigator&&/msie [6-9]\b/.test(navigator.userAgent.toLowerCase());function h(t,e,r,a){u=r,d=a||{};var i=n(t,e);return v(i),function(e){for(var r=[],a=0;a<i.length;a++){var s=i[a],c=o[s.id];c.refs--,r.push(c)}e?(i=n(t,e),v(i)):i=[];for(a=0;a<r.length;a++){c=r[a];if(0===c.refs){for(var u=0;u<c.parts.length;u++)c.parts[u]();delete o[c.id]}}}}function v(t){for(var e=0;e<t.length;e++){var r=t[e],n=o[r.id];if(n){n.refs++;for(var a=0;a<n.parts.length;a++)n.parts[a](r.parts[a]);for(;a<r.parts.length;a++)n.parts.push(m(r.parts[a]));n.parts.length>r.parts.length&&(n.parts.length=r.parts.length)}else{var i=[];for(a=0;a<r.parts.length;a++)i.push(m(r.parts[a]));o[r.id]={id:r.id,refs:1,parts:i}}}}function b(){var t=document.createElement("style");return t.type="text/css",i.appendChild(t),t}function m(t){var e,r,n=document.querySelector("style["+f+'~="'+t.id+'"]');if(n){if(u)return l;n.parentNode.removeChild(n)}if(p){var a=c++;n=s||(s=b()),e=y.bind(null,n,a,!1),r=y.bind(null,n,a,!0)}else n=b(),e=w.bind(null,n),r=function(){n.parentNode.removeChild(n)};return e(t),function(n){if(n){if(n.css===t.css&&n.media===t.media&&n.sourceMap===t.sourceMap)return;e(t=n)}else r()}}var g=function(){var t=[];return function(e,r){return t[e]=r,t.filter(Boolean).join("\n")}}();function y(t,e,r,n){var a=r?"":n.css;if(t.styleSheet)t.styleSheet.cssText=g(e,a);else{var o=document.createTextNode(a),i=t.childNodes;i[e]&&t.removeChild(i[e]),i.length?t.insertBefore(o,i[e]):t.appendChild(o)}}function w(t,e){var r=e.css,n=e.media,a=e.sourceMap;if(n&&t.setAttribute("media",n),d.ssrId&&t.setAttribute(f,e.id),a&&(r+="\n/*# sourceURL="+a.sources[0]+" */",r+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(a))))+" */"),t.styleSheet)t.styleSheet.cssText=r;else{while(t.firstChild)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(r))}}},"49f4":function(t,e,r){var n=r("6044");function a(){this.__data__=n?n(null):{},this.size=0}t.exports=a},"4bb5":function(t,e,r){var n=r("e2e4"),a=r("4416"),o=r("8296"),i=r("f4d6");function s(t,e){return e=n(e,t),t=o(t,e),null==t||delete t[i(a(e))]}t.exports=s},"4cef":function(t,e){var r=/\s/;function n(t){var e=t.length;while(e--&&r.test(t.charAt(e)));return e}t.exports=n},"4cfe":function(t,e){function r(t){return void 0===t}t.exports=r},"4d64":function(t,e,r){"use strict";var n=r("fc6a"),a=r("23cb"),o=r("07fa"),i=function(t){return function(e,r,i){var s,c=n(e),u=o(c),l=a(i,u);if(t&&r!==r){while(u>l)if(s=c[l++],s!==s)return!0}else for(;u>l;l++)if((t||l in c)&&c[l]===r)return t||l||0;return!t&&-1}};t.exports={includes:i(!0),indexOf:i(!1)}},"4d8c":function(t,e,r){var n=r("5c69");function a(t){var e=null==t?0:t.length;return e?n(t,1):[]}t.exports=a},"4f50":function(t,e,r){var n=r("b760"),a=r("e538"),o=r("c8fe"),i=r("4359"),s=r("fa21"),c=r("d370"),u=r("6747"),l=r("dcbe"),d=r("0d24"),f=r("9520"),p=r("1a8c"),h=r("60ed"),v=r("73ac"),b=r("8adb"),m=r("8de2");function g(t,e,r,g,y,w,x){var D=b(t,r),O=b(e,r),j=x.get(O);if(j)n(t,r,j);else{var k=w?w(D,O,r+"",t,e,x):void 0,M=void 0===k;if(M){var P=u(O),Y=!P&&d(O),S=!P&&!Y&&v(O);k=O,P||Y||S?u(D)?k=D:l(D)?k=i(D):Y?(M=!1,k=a(O,!0)):S?(M=!1,k=o(O,!0)):k=[]:h(O)||c(O)?(k=D,c(D)?k=m(D):p(D)&&!f(D)||(k=s(O))):M=!1}M&&(x.set(O,k),y(k,O,g,w,x),x["delete"](O)),n(t,r,k)}}t.exports=g},"501e":function(t,e,r){var n=r("3729"),a=r("1310"),o="[object Number]";function i(t){return"number"==typeof t||a(t)&&n(t)==o}t.exports=i},"50c4":function(t,e,r){"use strict";var n=r("5926"),a=Math.min;t.exports=function(t){return t>0?a(n(t),9007199254740991):0}},"50d8":function(t,e){function r(t,e){var r=-1,n=Array(t);while(++r<t)n[r]=e(r);return n}t.exports=r},"51ec":function(t,e,r){"use strict";r.d(e,"b",(function(){return f})),r.d(e,"a",(function(){return p}));var n=r("8bbf"),a=r.n(n),o=r("9404"),i=r("23a5"),s=r("7efe"),c=r("85a9"),u=r("f15d");const l={componentPrefix:"v",navVisibility:"click",titlePosition:"center",transition:"slide-h",touch:i,masks:s,screens:c,locales:u["a"],datePicker:{updateOnInput:!0,inputDebounce:1e3,popover:{visibility:"hover-focus",placement:"bottom-start",keepVisibleOnInput:!1,isInteractive:!0}}};let d=null;const f=function(t){return d||(d=new a.a({data(){return{defaults:Object(o["c"])(t,l)}},computed:{locales(){var t=this;return Object(o["r"])(this.defaults.locales,(function(e){return e.masks=Object(o["c"])(e.masks,t.defaults.masks),e}))}}})),d.defaults},p={beforeCreate(){f()},computed:{$defaults(){return d.defaults},$locales(){return d.locales}},methods:{propOrDefault(t,e,r){return this.passedProp(t,Object(o["d"])(this.$defaults,e),r)},passedProp(t,e,r){if(Object(o["e"])(this.$options.propsData,t)){const n=this[t];return Object(o["m"])(n)&&"merge"===r?Object(o["c"])(n,e):n}return e}}}},"52ca":function(t,e,r){"use strict";r("bfb3")},5332:function(t,e,r){var n=r("d8e2");n.__esModule&&(n=n.default),"string"===typeof n&&(n=[[t.i,n,""]]),n.locals&&(t.exports=n.locals);var a=r("499e").default;a("ecf39550",n,!0,{sourceMap:!1,shadowMode:!1})},"53ca":function(t,e,r){"use strict";function n(t){return n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},n(t)}r.d(e,"a",(function(){return n}))},5465:function(t,e,r){"use strict";function n(t){var e=new Date(Date.UTC(t.getFullYear(),t.getMonth(),t.getDate(),t.getHours(),t.getMinutes(),t.getSeconds(),t.getMilliseconds()));return e.setUTCFullYear(t.getFullYear()),t.getTime()-e.getTime()}Object.defineProperty(e,"__esModule",{value:!0}),e.default=n,t.exports=e.default},"54eb":function(t,e,r){var n=r("8eeb"),a=r("32f4");function o(t,e){return n(t,a(t),e)}t.exports=o},"55a3":function(t,e){function r(t){return this.__data__.has(t)}t.exports=r},"55ed":function(t,e,r){var n=r("386f");n.__esModule&&(n=n.default),"string"===typeof n&&(n=[[t.i,n,""]]),n.locals&&(t.exports=n.locals);var a=r("499e").default;a("557943a7",n,!0,{sourceMap:!1,shadowMode:!1})},5692:function(t,e,r){"use strict";var n=r("c430"),a=r("c6cd");(t.exports=function(t,e){return a[t]||(a[t]=void 0!==e?e:{})})("versions",[]).push({version:"3.33.0",mode:n?"pure":"global",copyright:"© 2014-2023 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.33.0/LICENSE",source:"https://github.com/zloirock/core-js"})},"56ef":function(t,e,r){"use strict";var n=r("d066"),a=r("e330"),o=r("241c"),i=r("7418"),s=r("825a"),c=a([].concat);t.exports=n("Reflect","ownKeys")||function(t){var e=o.f(s(t)),r=i.f;return r?c(e,r(t)):e}},"577e":function(t,e,r){"use strict";var n=r("f5df"),a=String;t.exports=function(t){if("Symbol"===n(t))throw new TypeError("Cannot convert a Symbol value to a string");return a(t)}},"57a5":function(t,e,r){var n=r("91e9"),a=n(Object.keys,Object);t.exports=a},"585a":function(t,e,r){(function(e){var r="object"==typeof e&&e&&e.Object===Object&&e;t.exports=r}).call(this,r("c8ba"))},5926:function(t,e,r){"use strict";var n=r("b42e");t.exports=function(t){var e=+t;return e!==e||0===e?0:n(e)}},"59ed":function(t,e,r){"use strict";var n=r("1626"),a=r("0d51"),o=TypeError;t.exports=function(t){if(n(t))return t;throw new o(a(t)+" is not a function")}},"5b01":function(t,e,r){var n=r("8eeb"),a=r("ec69");function o(t,e){return t&&n(e,a(e),t)}t.exports=o},"5c69":function(t,e,r){var n=r("087d"),a=r("0621");function o(t,e,r,i,s){var c=-1,u=t.length;r||(r=a),s||(s=[]);while(++c<u){var l=t[c];e>0&&r(l)?e>1?o(l,e-1,r,i,s):n(s,l):i||(s[s.length]=l)}return s}t.exports=o},"5c6c":function(t,e,r){"use strict";t.exports=function(t,e){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:e}}},"5d89":function(t,e,r){var n=r("f8af");function a(t,e){var r=e?n(t.buffer):t.buffer;return new t.constructor(r,t.byteOffset,t.byteLength)}t.exports=a},"5e2e":function(t,e,r){var n=r("28c9"),a=r("69d5"),o=r("b4c0"),i=r("fba5"),s=r("67ca");function c(t){var e=-1,r=null==t?0:t.length;this.clear();while(++e<r){var n=t[e];this.set(n[0],n[1])}}c.prototype.clear=n,c.prototype["delete"]=a,c.prototype.get=o,c.prototype.has=i,c.prototype.set=s,t.exports=c},"5e77":function(t,e,r){"use strict";var n=r("83ab"),a=r("1a2d"),o=Function.prototype,i=n&&Object.getOwnPropertyDescriptor,s=a(o,"name"),c=s&&"something"===function(){}.name,u=s&&(!n||n&&i(o,"name").configurable);t.exports={EXISTS:s,PROPER:c,CONFIGURABLE:u}},6044:function(t,e,r){var n=r("0b07"),a=n(Object,"create");t.exports=a},"605d":function(t,e,r){"use strict";var n=r("da84"),a=r("c6b6");t.exports="process"===a(n.process)},"60ed":function(t,e,r){var n=r("3729"),a=r("2dcb"),o=r("1310"),i="[object Object]",s=Function.prototype,c=Object.prototype,u=s.toString,l=c.hasOwnProperty,d=u.call(Object);function f(t){if(!o(t)||n(t)!=i)return!1;var e=a(t);if(null===e)return!0;var r=l.call(e,"constructor")&&e.constructor;return"function"==typeof r&&r instanceof r&&u.call(r)==d}t.exports=f},6220:function(t,e,r){var n=r("b1d2"),a=r("b047"),o=r("99d3"),i=o&&o.isDate,s=i?a(i):n;t.exports=s},"62e4":function(t,e){t.exports=function(t){return t.webpackPolyfill||(t.deprecate=function(){},t.paths=[],t.children||(t.children=[]),Object.defineProperty(t,"loaded",{enumerable:!0,get:function(){return t.l}}),Object.defineProperty(t,"id",{enumerable:!0,get:function(){return t.i}}),t.webpackPolyfill=1),t}},6374:function(t,e,r){"use strict";var n=r("da84"),a=Object.defineProperty;t.exports=function(t,e){try{a(n,t,{value:e,configurable:!0,writable:!0})}catch(r){n[t]=e}return e}},"642a":function(t,e,r){var n=r("966f"),a=r("3bb4"),o=r("20ec");function i(t){var e=a(t);return 1==e.length&&e[0][2]?o(e[0][0],e[0][1]):function(r){return r===t||n(r,t,e)}}t.exports=i},"643d":function(t,e,r){var n=r("116a");n.__esModule&&(n=n.default),"string"===typeof n&&(n=[[t.i,n,""]]),n.locals&&(t.exports=n.locals);var a=r("499e").default;a("d4127e08",n,!0,{sourceMap:!1,shadowMode:!1})},6562:function(t,e,r){var n=r("9419");n.__esModule&&(n=n.default),"string"===typeof n&&(n=[[t.i,n,""]]),n.locals&&(t.exports=n.locals);var a=r("499e").default;a("0ba08e60",n,!0,{sourceMap:!1,shadowMode:!1})},"656b":function(t,e,r){var n=r("e2e4"),a=r("f4d6");function o(t,e){e=n(e,t);var r=0,o=e.length;while(null!=t&&r<o)t=t[a(e[r++])];return r&&r==o?t:void 0}t.exports=o},6679:function(t,e,r){var n=r("3729"),a=r("1310"),o="[object Boolean]";function i(t){return!0===t||!1===t||a(t)&&n(t)==o}t.exports=i},6747:function(t,e){var r=Array.isArray;t.exports=r},"67ca":function(t,e,r){var n=r("cb5a");function a(t,e){var r=this.__data__,a=n(r,t);return a<0?(++this.size,r.push([t,e])):r[a][1]=e,this}t.exports=a},"69d5":function(t,e,r){var n=r("cb5a"),a=Array.prototype,o=a.splice;function i(t){var e=this.__data__,r=n(e,t);if(r<0)return!1;var a=e.length-1;return r==a?e.pop():o.call(e,r,1),--this.size,!0}t.exports=i},"69f3":function(t,e,r){"use strict";var n,a,o,i=r("cdce"),s=r("da84"),c=r("861d"),u=r("9112"),l=r("1a2d"),d=r("c6cd"),f=r("f772"),p=r("d012"),h="Object already initialized",v=s.TypeError,b=s.WeakMap,m=function(t){return o(t)?a(t):n(t,{})},g=function(t){return function(e){var r;if(!c(e)||(r=a(e)).type!==t)throw new v("Incompatible receiver, "+t+" required");return r}};if(i||d.state){var y=d.state||(d.state=new b);y.get=y.get,y.has=y.has,y.set=y.set,n=function(t,e){if(y.has(t))throw new v(h);return e.facade=t,y.set(t,e),e},a=function(t){return y.get(t)||{}},o=function(t){return y.has(t)}}else{var w=f("state");p[w]=!0,n=function(t,e){if(l(t,w))throw new v(h);return e.facade=t,u(t,w,e),e},a=function(t){return l(t,w)?t[w]:{}},o=function(t){return l(t,w)}}t.exports={set:n,get:a,has:o,enforce:m,getterFor:g}},"6f19":function(t,e,r){"use strict";var n=r("9112"),a=r("0d26"),o=r("b980"),i=Error.captureStackTrace;t.exports=function(t,e,r,s){o&&(i?i(t,e):n(t,"stack",a(r,s)))}},"6f6c":function(t,e){var r=/\w*$/;function n(t){var e=new t.constructor(t.source,r.exec(t));return e.lastIndex=t.lastIndex,e}t.exports=n},"6fcd":function(t,e,r){var n=r("50d8"),a=r("d370"),o=r("6747"),i=r("0d24"),s=r("c098"),c=r("73ac"),u=Object.prototype,l=u.hasOwnProperty;function d(t,e){var r=o(t),u=!r&&a(t),d=!r&&!u&&i(t),f=!r&&!u&&!d&&c(t),p=r||u||d||f,h=p?n(t.length,String):[],v=h.length;for(var b in t)!e&&!l.call(t,b)||p&&("length"==b||d&&("offset"==b||"parent"==b)||f&&("buffer"==b||"byteLength"==b||"byteOffset"==b)||s(b,v))||h.push(b);return h}t.exports=d},7156:function(t,e,r){"use strict";var n=r("1626"),a=r("861d"),o=r("d2bb");t.exports=function(t,e,r){var i,s;return o&&n(i=e.constructor)&&i!==r&&a(s=i.prototype)&&s!==r.prototype&&o(t,s),t}},7234:function(t,e,r){"use strict";t.exports=function(t){return null===t||void 0===t}},7282:function(t,e,r){"use strict";var n=r("e330"),a=r("59ed");t.exports=function(t,e,r){try{return n(a(Object.getOwnPropertyDescriptor(t,e)[r]))}catch(o){}}},"72af":function(t,e,r){var n=r("99cd"),a=n();t.exports=a},"72f0":function(t,e){function r(t){return function(){return t}}t.exports=r},"73ac":function(t,e,r){var n=r("743f"),a=r("b047"),o=r("99d3"),i=o&&o.isTypedArray,s=i?a(i):n;t.exports=s},7418:function(t,e,r){"use strict";e.f=Object.getOwnPropertySymbols},"743f":function(t,e,r){var n=r("3729"),a=r("b218"),o=r("1310"),i="[object Arguments]",s="[object Array]",c="[object Boolean]",u="[object Date]",l="[object Error]",d="[object Function]",f="[object Map]",p="[object Number]",h="[object Object]",v="[object RegExp]",b="[object Set]",m="[object String]",g="[object WeakMap]",y="[object ArrayBuffer]",w="[object DataView]",x="[object Float32Array]",D="[object Float64Array]",O="[object Int8Array]",j="[object Int16Array]",k="[object Int32Array]",M="[object Uint8Array]",P="[object Uint8ClampedArray]",Y="[object Uint16Array]",S="[object Uint32Array]",_={};function E(t){return o(t)&&a(t.length)&&!!_[n(t)]}_[x]=_[D]=_[O]=_[j]=_[k]=_[M]=_[P]=_[Y]=_[S]=!0,_[i]=_[s]=_[y]=_[c]=_[w]=_[u]=_[l]=_[d]=_[f]=_[p]=_[h]=_[v]=_[b]=_[m]=_[g]=!1,t.exports=E},7530:function(t,e,r){var n=r("1a8c"),a=Object.create,o=function(){function t(){}return function(e){if(!n(e))return{};if(a)return a(e);t.prototype=e;var r=new t;return t.prototype=void 0,r}}();t.exports=o},"76dd":function(t,e,r){var n=r("ce86");function a(t){return null==t?"":n(t)}t.exports=a},7839:function(t,e,r){"use strict";t.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},7948:function(t,e){function r(t,e){var r=-1,n=null==t?0:t.length,a=Array(n);while(++r<n)a[r]=e(t[r],r,t);return a}t.exports=r},"79bc":function(t,e,r){var n=r("0b07"),a=r("2b3e"),o=n(a,"Map");t.exports=o},"7a48":function(t,e,r){var n=r("6044"),a=Object.prototype,o=a.hasOwnProperty;function i(t){var e=this.__data__;return n?void 0!==e[t]:o.call(e,t)}t.exports=i},"7b0b":function(t,e,r){"use strict";var n=r("1d80"),a=Object;t.exports=function(t){return a(n(t))}},"7b83":function(t,e,r){var n=r("7c64"),a=r("93ed"),o=r("2478"),i=r("a524"),s=r("1fc8");function c(t){var e=-1,r=null==t?0:t.length;this.clear();while(++e<r){var n=t[e];this.set(n[0],n[1])}}c.prototype.clear=n,c.prototype["delete"]=a,c.prototype.get=o,c.prototype.has=i,c.prototype.set=s,t.exports=c},"7b97":function(t,e,r){var n=r("7e64"),a=r("a2be"),o=r("1c3c"),i=r("b1e5"),s=r("42a2"),c=r("6747"),u=r("0d24"),l=r("73ac"),d=1,f="[object Arguments]",p="[object Array]",h="[object Object]",v=Object.prototype,b=v.hasOwnProperty;function m(t,e,r,v,m,g){var y=c(t),w=c(e),x=y?p:s(t),D=w?p:s(e);x=x==f?h:x,D=D==f?h:D;var O=x==h,j=D==h,k=x==D;if(k&&u(t)){if(!u(e))return!1;y=!0,O=!1}if(k&&!O)return g||(g=new n),y||l(t)?a(t,e,r,v,m,g):o(t,e,x,r,v,m,g);if(!(r&d)){var M=O&&b.call(t,"__wrapped__"),P=j&&b.call(e,"__wrapped__");if(M||P){var Y=M?t.value():t,S=P?e.value():e;return g||(g=new n),m(Y,S,r,v,g)}}return!!k&&(g||(g=new n),i(t,e,r,v,m,g))}t.exports=m},"7c64":function(t,e,r){var n=r("e24b"),a=r("5e2e"),o=r("79bc");function i(){this.size=0,this.__data__={hash:new n,map:new(o||a),string:new n}}t.exports=i},"7d1f":function(t,e,r){var n=r("087d"),a=r("6747");function o(t,e,r){var o=e(t);return a(t)?o:n(o,r(t))}t.exports=o},"7d87":function(t,e,r){var n=r("0f62");n.__esModule&&(n=n.default),"string"===typeof n&&(n=[[t.i,n,""]]),n.locals&&(t.exports=n.locals);var a=r("499e").default;a("d0e2b3b8",n,!0,{sourceMap:!1,shadowMode:!1})},"7e64":function(t,e,r){var n=r("5e2e"),a=r("efb6"),o=r("2fcc"),i=r("802a"),s=r("55a3"),c=r("d02c");function u(t){var e=this.__data__=new n(t);this.size=e.size}u.prototype.clear=a,u.prototype["delete"]=o,u.prototype.get=i,u.prototype.has=s,u.prototype.set=c,t.exports=u},"7ed2":function(t,e){var r="__lodash_hash_undefined__";function n(t){return this.__data__.set(t,r),this}t.exports=n},"7efe":function(t){t.exports=JSON.parse('{"title":"MMMM YYYY","weekdays":"W","navMonths":"MMM","input":["L","YYYY-MM-DD","YYYY/MM/DD"],"inputDateTime":["L h:mm A","YYYY-MM-DD h:mm A","YYYY/MM/DD h:mm A"],"inputDateTime24hr":["L HH:mm","YYYY-MM-DD HH:mm","YYYY/MM/DD HH:mm"],"inputTime":["h:mm A"],"inputTime24hr":["HH:mm"],"dayPopover":"WWW, MMM D, YYYY","data":["L","YYYY-MM-DD","YYYY/MM/DD"],"iso":"YYYY-MM-DDTHH:mm:ss.SSSZ"}')},"802a":function(t,e){function r(t){return this.__data__.get(t)}t.exports=r},8057:function(t,e){function r(t,e){var r=-1,n=null==t?0:t.length;while(++r<n)if(!1===e(t[r],r,t))break;return t}t.exports=r},"825a":function(t,e,r){"use strict";var n=r("861d"),a=String,o=TypeError;t.exports=function(t){if(n(t))return t;throw new o(a(t)+" is not an object")}},8296:function(t,e,r){var n=r("656b"),a=r("2b10");function o(t,e){return e.length<2?t:n(t,a(e,0,-1))}t.exports=o},8384:function(t,e){function r(t,e,r){return t===t&&(void 0!==r&&(t=t<=r?t:r),void 0!==e&&(t=t>=e?t:e)),t}t.exports=r},"83ab":function(t,e,r){"use strict";var n=r("d039");t.exports=!n((function(){return 7!==Object.defineProperty({},1,{get:function(){return 7}})[1]}))},8518:function(t,e,r){var n=r("b3ff");n.__esModule&&(n=n.default),"string"===typeof n&&(n=[[t.i,n,""]]),n.locals&&(t.exports=n.locals);var a=r("499e").default;a("22adb7aa",n,!0,{sourceMap:!1,shadowMode:!1})},"85a9":function(t){t.exports=JSON.parse('{"sm":"640px","md":"768px","lg":"1024px","xl":"1280px"}')},"85e3":function(t,e){function r(t,e,r){switch(r.length){case 0:return t.call(e);case 1:return t.call(e,r[0]);case 2:return t.call(e,r[0],r[1]);case 3:return t.call(e,r[0],r[1],r[2])}return t.apply(e,r)}t.exports=r},8604:function(t,e,r){var n=r("26e8"),a=r("e2c0");function o(t,e){return null!=t&&a(t,e,n)}t.exports=o},"861d":function(t,e,r){"use strict";var n=r("1626"),a=r("8ea1"),o=a.all;t.exports=a.IS_HTMLDDA?function(t){return"object"==typeof t?null!==t:n(t)||t===o}:function(t){return"object"==typeof t?null!==t:n(t)}},"872a":function(t,e,r){var n=r("3b4a");function a(t,e,r){"__proto__"==e&&n?n(t,e,{configurable:!0,enumerable:!0,value:r,writable:!0}):t[e]=r}t.exports=a},8925:function(t,e,r){"use strict";var n=r("e330"),a=r("1626"),o=r("c6cd"),i=n(Function.toString);a(o.inspectSource)||(o.inspectSource=function(t){return i(t)}),t.exports=o.inspectSource},"89d9":function(t,e,r){var n=r("656b"),a=r("159a"),o=r("e2e4");function i(t,e,r){var i=-1,s=e.length,c={};while(++i<s){var u=e[i],l=n(t,u);r(l,u)&&a(c,o(u,t),l)}return c}t.exports=i},"8ab2":function(t,e,r){"use strict";r("23da")},"8adb":function(t,e){function r(t,e){if(("constructor"!==e||"function"!==typeof t[e])&&"__proto__"!=e)return t[e]}t.exports=r},"8bbf":function(e,r){e.exports=t},"8c86":function(t,e,r){"use strict";function n(t,e){if(e.length<t)throw new TypeError(t+" argument"+(t>1?"s":"")+" required, but only "+e.length+" present")}r.d(e,"a",(function(){return n}))},"8d74":function(t,e,r){var n=r("4cef"),a=/^\s+/;function o(t){return t?t.slice(0,n(t)+1).replace(a,""):t}t.exports=o},"8de2":function(t,e,r){var n=r("8eeb"),a=r("9934");function o(t){return n(t,a(t))}t.exports=o},"8ea1":function(t,e,r){"use strict";var n="object"==typeof document&&document.all,a="undefined"==typeof n&&void 0!==n;t.exports={all:n,IS_HTMLDDA:a}},"8eeb":function(t,e,r){var n=r("32b3"),a=r("872a");function o(t,e,r,o){var i=!r;r||(r={});var s=-1,c=e.length;while(++s<c){var u=e[s],l=o?o(r[u],t[u],u,r,t):void 0;void 0===l&&(l=t[u]),i?a(r,u,l):n(r,u,l)}return r}t.exports=o},"90e3":function(t,e,r){"use strict";var n=r("e330"),a=0,o=Math.random(),i=n(1..toString);t.exports=function(t){return"Symbol("+(void 0===t?"":t)+")_"+i(++a+o,36)}},9112:function(t,e,r){"use strict";var n=r("83ab"),a=r("9bf2"),o=r("5c6c");t.exports=n?function(t,e,r){return a.f(t,e,o(1,r))}:function(t,e,r){return t[e]=r,t}},"91e9":function(t,e){function r(t,e){return function(r){return t(e(r))}}t.exports=r},9349:function(t,e,r){"use strict";r.d(e,"a",(function(){return o}));r("14d9");var n=r("22f3"),a=r("2fa3");class o{constructor(t,e,r){this.theme=t,this.locale=e,this.map={},this.refresh(r,!0)}destroy(){this.theme=null,this.locale=null,this.map={},this.list=[],this.pinAttr=null}refresh(t,e){var r=this;const o={},i=[];let s=null;const c=[],u=e?new Set:new Set(Object.keys(this.map));return Object(a["b"])(t)&&t.forEach((function(t,l){if(!t||!t.dates)return;const d=t.key?t.key.toString():l.toString(),f=t.order||0,p=Object(a["g"])(JSON.stringify(t));let h=r.map[d];!e&&h&&h.hashcode===p?u.delete(d):(h=new n["a"]({key:d,order:f,hashcode:p,...t},r.theme,r.locale),c.push(h)),h&&h.pinPage&&(s=h),o[d]=h,i.push(h)})),this.map=o,this.list=i,this.pinAttr=s,{adds:c,deletes:Array.from(u)}}}},"93ed":function(t,e,r){var n=r("4245");function a(t){var e=n(this,t)["delete"](t);return this.size-=e?1:0,e}t.exports=a},9404:function(t,e,r){"use strict";r.d(e,"j",(function(){return B})),r.d(e,"m",(function(){return Z})),r.d(e,"e",(function(){return q})),r.d(e,"f",(function(){return G})),r.d(e,"v",(function(){return K}));var n=r("6679"),a=r.n(n);r.d(e,"i",(function(){return a.a}));var o=r("501e"),i=r.n(o);r.d(e,"l",(function(){return i.a}));var s=r("e2a0"),c=r.n(s);r.d(e,"n",(function(){return c.a}));var u=r("dcbe"),l=r.n(u);r.d(e,"h",(function(){return l.a}));var d=r("9520"),f=r.n(d);r.d(e,"k",(function(){return f.a}));var p=r("4cfe"),h=r.n(p);r.d(e,"o",(function(){return h.a}));var v=r("6220"),b=r.n(v),m=r("f678"),g=r.n(m);r.d(e,"a",(function(){return g.a}));var y=r("9b02"),w=r.n(y);r.d(e,"d",(function(){return w.a}));var x=r("0f5c"),D=r.n(x);r.d(e,"u",(function(){return D.a}));var O=r("9e86"),j=r.n(O);r.d(e,"r",(function(){return j.a}));var k=r("f542"),M=r.n(k);r.d(e,"w",(function(){return M.a}));var P=r("95ae"),Y=r.n(P);r.d(e,"b",(function(){return Y.a}));var S=r("3f84"),_=r.n(S);r.d(e,"c",(function(){return _.a}));var E=r("2593"),T=r.n(E);r.d(e,"t",(function(){return T.a}));var I=r("3eea"),C=r.n(I);r.d(e,"s",(function(){return C.a}));var $=r("3852"),A=r.n($),N=r("dd61"),F=r.n(N);r.d(e,"q",(function(){return F.a}));var z=r("a59b"),H=r.n(z);r.d(e,"g",(function(){return H.a}));var L=r("4416"),W=r.n(L);r.d(e,"p",(function(){return W.a}));var V=r("3092"),R=r.n(V);const U=function(t){return Object.prototype.toString.call(t).slice(8,-1)},B=function(t){return b()(t)&&!isNaN(t.getTime())},Z=function(t){return"Object"===U(t)},q=A.a,G=function(t,e){return R()(e,(function(e){return A()(t,e)}))},K=R.a},9419:function(t,e,r){var n=r("24fb");e=n(!1),e.push([t.i,".vc-nav-popover-container{color:var(--white);font-size:var(--text-sm);font-weight:var(--font-semibold);background-color:var(--gray-800);border:1px solid;border-color:var(--gray-700);border-radius:var(--rounded-lg);padding:4px;box-shadow:var(--shadow)}.vc-is-dark .vc-nav-popover-container{color:var(--gray-800);background-color:var(--white);border-color:var(--gray-100)}",""]),t.exports=e},"94ca":function(t,e,r){"use strict";var n=r("d039"),a=r("1626"),o=/#|\.prototype\./,i=function(t,e){var r=c[s(t)];return r===l||r!==u&&(a(e)?n(e):!!e)},s=i.normalize=function(t){return String(t).replace(o,".").toLowerCase()},c=i.data={},u=i.NATIVE="N",l=i.POLYFILL="P";t.exports=i},"950a":function(t,e,r){var n=r("30c9");function a(t,e){return function(r,a){if(null==r)return r;if(!n(r))return t(r,a);var o=r.length,i=e?o:-1,s=Object(r);while(e?i--:++i<o)if(!1===a(s[i],i,s))break;return r}}t.exports=a},9520:function(t,e,r){var n=r("3729"),a=r("1a8c"),o="[object AsyncFunction]",i="[object Function]",s="[object GeneratorFunction]",c="[object Proxy]";function u(t){if(!a(t))return!1;var e=n(t);return e==i||e==s||e==o||e==c}t.exports=u},"95ae":function(t,e,r){var n=r("100e"),a=r("9638"),o=r("9aff"),i=r("9934"),s=Object.prototype,c=s.hasOwnProperty,u=n((function(t,e){t=Object(t);var r=-1,n=e.length,u=n>2?e[2]:void 0;u&&o(e[0],e[1],u)&&(n=1);while(++r<n){var l=e[r],d=i(l),f=-1,p=d.length;while(++f<p){var h=d[f],v=t[h];(void 0===v||a(v,s[h])&&!c.call(t,h))&&(t[h]=l[h])}}return t}));t.exports=u},9638:function(t,e){function r(t,e){return t===e||t!==t&&e!==e}t.exports=r},"966f":function(t,e,r){var n=r("7e64"),a=r("c05f"),o=1,i=2;function s(t,e,r,s){var c=r.length,u=c,l=!s;if(null==t)return!u;t=Object(t);while(c--){var d=r[c];if(l&&d[2]?d[1]!==t[d[0]]:!(d[0]in t))return!1}while(++c<u){d=r[c];var f=d[0],p=t[f],h=d[1];if(l&&d[2]){if(void 0===p&&!(f in t))return!1}else{var v=new n;if(s)var b=s(p,h,f,t,e,v);if(!(void 0===b?a(h,p,o|i,s,v):b))return!1}}return!0}t.exports=s},"96f3":function(t,e){var r=Object.prototype,n=r.hasOwnProperty;function a(t,e){return null!=t&&n.call(t,e)}t.exports=a},"97d3":function(t,e,r){var n=r("48a0"),a=r("30c9");function o(t,e){var r=-1,o=a(t)?Array(t.length):[];return n(t,(function(t,n,a){o[++r]=e(t,n,a)})),o}t.exports=o},9934:function(t,e,r){var n=r("6fcd"),a=r("41c3"),o=r("30c9");function i(t){return o(t)?n(t,!0):a(t)}t.exports=i},"99cd":function(t,e){function r(t){return function(e,r,n){var a=-1,o=Object(e),i=n(e),s=i.length;while(s--){var c=i[t?s:++a];if(!1===r(o[c],c,o))break}return e}}t.exports=r},"99d3":function(t,e,r){(function(t){var n=r("585a"),a=e&&!e.nodeType&&e,o=a&&"object"==typeof t&&t&&!t.nodeType&&t,i=o&&o.exports===a,s=i&&n.process,c=function(){try{var t=o&&o.require&&o.require("util").types;return t||s&&s.binding&&s.binding("util")}catch(e){}}();t.exports=c}).call(this,r("62e4")(t))},"9aff":function(t,e,r){var n=r("9638"),a=r("30c9"),o=r("c098"),i=r("1a8c");function s(t,e,r){if(!i(r))return!1;var s=typeof e;return!!("number"==s?a(r)&&o(e,r.length):"string"==s&&e in r)&&n(r[e],t)}t.exports=s},"9b02":function(t,e,r){var n=r("656b");function a(t,e,r){var a=null==t?void 0:n(t,e);return void 0===a?r:a}t.exports=a},"9bf2":function(t,e,r){"use strict";var n=r("83ab"),a=r("0cfb"),o=r("aed9"),i=r("825a"),s=r("a04b"),c=TypeError,u=Object.defineProperty,l=Object.getOwnPropertyDescriptor,d="enumerable",f="configurable",p="writable";e.f=n?o?function(t,e,r){if(i(t),e=s(e),i(r),"function"===typeof t&&"prototype"===e&&"value"in r&&p in r&&!r[p]){var n=l(t,e);n&&n[p]&&(t[e]=r.value,r={configurable:f in r?r[f]:n[f],enumerable:d in r?r[d]:n[d],writable:!1})}return u(t,e,r)}:u:function(t,e,r){if(i(t),e=s(e),i(r),a)try{return u(t,e,r)}catch(n){}if("get"in r||"set"in r)throw new c("Accessors not supported");return"value"in r&&(t[e]=r.value),t}},"9e69":function(t,e,r){var n=r("2b3e"),a=n.Symbol;t.exports=a},"9e86":function(t,e,r){var n=r("872a"),a=r("242e"),o=r("badf");function i(t,e){var r={};return e=o(e,3),a(t,(function(t,a,o){n(r,a,e(t,a,o))})),r}t.exports=i},a029:function(t,e,r){var n=r("087d"),a=r("2dcb"),o=r("32f4"),i=r("d327"),s=Object.getOwnPropertySymbols,c=s?function(t){var e=[];while(t)n(e,o(t)),t=a(t);return e}:i;t.exports=c},a04b:function(t,e,r){"use strict";var n=r("c04e"),a=r("d9b5");t.exports=function(t){var e=n(t,"string");return a(e)?e:e+""}},a2be:function(t,e,r){var n=r("d612"),a=r("4284"),o=r("c584"),i=1,s=2;function c(t,e,r,c,u,l){var d=r&i,f=t.length,p=e.length;if(f!=p&&!(d&&p>f))return!1;var h=l.get(t),v=l.get(e);if(h&&v)return h==e&&v==t;var b=-1,m=!0,g=r&s?new n:void 0;l.set(t,e),l.set(e,t);while(++b<f){var y=t[b],w=e[b];if(c)var x=d?c(w,y,b,e,t,l):c(y,w,b,t,e,l);if(void 0!==x){if(x)continue;m=!1;break}if(g){if(!a(e,(function(t,e){if(!o(g,e)&&(y===t||u(y,t,r,c,l)))return g.push(e)}))){m=!1;break}}else if(y!==w&&!u(y,w,r,c,l)){m=!1;break}}return l["delete"](t),l["delete"](e),m}t.exports=c},a2db:function(t,e,r){var n=r("9e69"),a=n?n.prototype:void 0,o=a?a.valueOf:void 0;function i(t){return o?Object(o.call(t)):{}}t.exports=i},a3fd:function(t,e,r){var n=r("7948");function a(t,e){return n(e,(function(e){return[e,t[e]]}))}t.exports=a},a454:function(t,e,r){var n=r("72f0"),a=r("3b4a"),o=r("cd9d"),i=a?function(t,e){return a(t,"toString",{configurable:!0,enumerable:!1,value:n(e),writable:!0})}:o;t.exports=i},a524:function(t,e,r){var n=r("4245");function a(t){return n(this,t).has(t)}t.exports=a},a59b:function(t,e){function r(t){return t&&t.length?t[0]:void 0}t.exports=r},a640:function(t,e,r){"use strict";var n=r("d039");t.exports=function(t,e){var r=[][t];return!!r&&n((function(){r.call(null,e||function(){return 1},1)}))}},a994:function(t,e,r){var n=r("7d1f"),a=r("32f4"),o=r("ec69");function i(t){return n(t,o,a)}t.exports=i},ab36:function(t,e,r){"use strict";var n=r("861d"),a=r("9112");t.exports=function(t,e){n(e)&&"cause"in e&&a(t,"cause",e.cause)}},ac41:function(t,e){function r(t){var e=-1,r=Array(t.size);return t.forEach((function(t){r[++e]=t})),r}t.exports=r},aeb0:function(t,e,r){"use strict";var n=r("9bf2").f;t.exports=function(t,e,r){r in t||n(t,r,{configurable:!0,get:function(){return e[r]},set:function(t){e[r]=t}})}},aed9:function(t,e,r){"use strict";var n=r("83ab"),a=r("d039");t.exports=n&&a((function(){return 42!==Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},b047:function(t,e){function r(t){return function(e){return t(e)}}t.exports=r},b0b5:function(t,e,r){var n=r("24fb");e=n(!1),e.push([t.i,".vc-nav-header{display:flex;justify-content:space-between}.vc-nav-arrow{display:flex;justify-content:center;align-items:center;cursor:pointer;-webkit-user-select:none;user-select:none;line-height:var(--leading-snug);border-width:2px;border-style:solid;border-color:transparent;border-radius:var(--rounded)}.vc-nav-arrow.is-left{margin-right:auto}.vc-nav-arrow.is-right{margin-left:auto}.vc-nav-arrow.is-disabled{opacity:.25;pointer-events:none;cursor:not-allowed}.vc-nav-arrow:hover{background-color:var(--gray-900)}.vc-nav-arrow:focus{border-color:var(--accent-600)}.vc-nav-title{color:var(--accent-100);font-weight:var(--font-bold);line-height:var(--leading-snug);padding:4px 8px;border-radius:var(--rounded);border-width:2px;border-style:solid;border-color:transparent;-webkit-user-select:none;user-select:none}.vc-nav-title:hover{background-color:var(--gray-900)}.vc-nav-title:focus{border-color:var(--accent-600)}.vc-nav-items{display:grid;grid-template-columns:repeat(3,1fr);grid-row-gap:2px;grid-column-gap:5px}.vc-nav-item{width:48px;text-align:center;line-height:var(--leading-snug);font-weight:var(--font-semibold);padding:4px 0;cursor:pointer;border-color:transparent;border-width:2px;border-style:solid;border-radius:var(--rounded);-webkit-user-select:none;user-select:none}.vc-nav-item:hover{color:var(--white);background-color:var(--gray-900);box-shadow:var(--shadow-inner)}.vc-nav-item.is-active{color:var(--accent-900);background:var(--accent-100);font-weight:var(--font-bold);box-shadow:var(--shadow)}.vc-nav-item.is-current{color:var(--accent-100);font-weight:var(--bold);border-color:var(--accent-100)}.vc-nav-item:focus{border-color:var(--accent-600)}.vc-nav-item.is-disabled{opacity:.25;pointer-events:none}.vc-is-dark .vc-nav-title{color:var(--gray-900)}.vc-is-dark .vc-nav-title:hover{background-color:var(--gray-200)}.vc-is-dark .vc-nav-title:focus{border-color:var(--accent-400)}.vc-is-dark .vc-nav-arrow:hover{background-color:var(--gray-200)}.vc-is-dark .vc-nav-arrow:focus{border-color:var(--accent-400)}.vc-is-dark .vc-nav-item:hover{color:var(--gray-900);background-color:var(--gray-200);box-shadow:none}.vc-is-dark .vc-nav-item.is-active{color:var(--white);background:var(--accent-500)}.vc-is-dark .vc-nav-item.is-current{color:var(--accent-600);border-color:var(--accent-500)}.vc-is-dark .vc-nav-item:focus{border-color:var(--accent-400)}",""]),t.exports=e},b1d2:function(t,e,r){var n=r("3729"),a=r("1310"),o="[object Date]";function i(t){return a(t)&&n(t)==o}t.exports=i},b1e5:function(t,e,r){var n=r("a994"),a=1,o=Object.prototype,i=o.hasOwnProperty;function s(t,e,r,o,s,c){var u=r&a,l=n(t),d=l.length,f=n(e),p=f.length;if(d!=p&&!u)return!1;var h=d;while(h--){var v=l[h];if(!(u?v in e:i.call(e,v)))return!1}var b=c.get(t),m=c.get(e);if(b&&m)return b==e&&m==t;var g=!0;c.set(t,e),c.set(e,t);var y=u;while(++h<d){v=l[h];var w=t[v],x=e[v];if(o)var D=u?o(x,w,v,e,t,c):o(w,x,v,t,e,c);if(!(void 0===D?w===x||s(w,x,r,o,c):D)){g=!1;break}y||(y="constructor"==v)}if(g&&!y){var O=t.constructor,j=e.constructor;O==j||!("constructor"in t)||!("constructor"in e)||"function"==typeof O&&O instanceof O&&"function"==typeof j&&j instanceof j||(g=!1)}return c["delete"](t),c["delete"](e),g}t.exports=s},b218:function(t,e){var r=9007199254740991;function n(t){return"number"==typeof t&&t>-1&&t%1==0&&t<=r}t.exports=n},b3ff:function(t,e,r){var n=r("24fb");e=n(!1),e.push([t.i,".vc-pane[data-v-74ad501d]{min-width:250px}.vc-header[data-v-74ad501d]{display:flex;justify-content:center;align-items:center;padding:10px 18px 0 18px}.vc-header.align-left[data-v-74ad501d]{justify-content:flex-start}.vc-header.align-right[data-v-74ad501d]{justify-content:flex-end}.vc-title[data-v-74ad501d]{font-size:var(--text-lg);color:var(--gray-800);font-weight:var(--font-semibold);line-height:28px;cursor:pointer;-webkit-user-select:none;user-select:none;white-space:nowrap}.vc-title[data-v-74ad501d]:hover{opacity:.75}.vc-weeknumber[data-v-74ad501d]{position:relative}.vc-weeknumber[data-v-74ad501d],.vc-weeknumber-content[data-v-74ad501d]{display:flex;justify-content:center;align-items:center}.vc-weeknumber-content[data-v-74ad501d]{font-size:var(--text-xs);font-weight:var(--font-medium);font-style:italic;width:28px;height:28px;margin-top:2px;color:var(--gray-500);-webkit-user-select:none;user-select:none}.vc-weeknumber-content.is-left-outside[data-v-74ad501d]{position:absolute;left:var(--weeknumber-offset)}.vc-weeknumber-content.is-right-outside[data-v-74ad501d]{position:absolute;right:var(--weeknumber-offset)}.vc-weeks[data-v-74ad501d]{display:grid;grid-template-columns:repeat(7,1fr);position:relative;-webkit-overflow-scrolling:touch;padding:5px;min-width:250px}.vc-weeks.vc-show-weeknumbers[data-v-74ad501d]{grid-template-columns:auto repeat(7,1fr)}.vc-weeks.vc-show-weeknumbers.is-right[data-v-74ad501d]{grid-template-columns:repeat(7,1fr) auto}.vc-weekday[data-v-74ad501d]{text-align:center;color:var(--gray-500);font-size:var(--text-sm);font-weight:var(--font-bold);line-height:14px;padding-top:4px;padding-bottom:8px;cursor:default;-webkit-user-select:none;user-select:none}.vc-is-dark .vc-header[data-v-74ad501d]{color:var(--gray-200)}.vc-is-dark .vc-title[data-v-74ad501d]{color:var(--gray-100)}.vc-is-dark .vc-weekday[data-v-74ad501d]{color:var(--accent-200)}",""]),t.exports=e},b42e:function(t,e,r){"use strict";var n=Math.ceil,a=Math.floor;t.exports=Math.trunc||function(t){var e=+t;return(e>0?a:n)(e)}},b4b0:function(t,e,r){var n=r("8d74"),a=r("1a8c"),o=r("ffd6"),i=NaN,s=/^[-+]0x[0-9a-f]+$/i,c=/^0b[01]+$/i,u=/^0o[0-7]+$/i,l=parseInt;function d(t){if("number"==typeof t)return t;if(o(t))return i;if(a(t)){var e="function"==typeof t.valueOf?t.valueOf():t;t=a(e)?e+"":e}if("string"!=typeof t)return 0===t?t:+t;t=n(t);var r=c.test(t);return r||u.test(t)?l(t.slice(2),r?2:8):s.test(t)?i:+t}t.exports=d},b4c0:function(t,e,r){var n=r("cb5a");function a(t){var e=this.__data__,r=n(e,t);return r<0?void 0:e[r][1]}t.exports=a},b5a7:function(t,e,r){var n=r("0b07"),a=r("2b3e"),o=n(a,"DataView");t.exports=o},b622:function(t,e,r){"use strict";var n=r("da84"),a=r("5692"),o=r("1a2d"),i=r("90e3"),s=r("04f8"),c=r("fdbf"),u=n.Symbol,l=a("wks"),d=c?u["for"]||u:u&&u.withoutSetter||i;t.exports=function(t){return o(l,t)||(l[t]=s&&o(u,t)?u[t]:d("Symbol."+t)),l[t]}},b760:function(t,e,r){var n=r("872a"),a=r("9638");function o(t,e,r){(void 0!==r&&!a(t[e],r)||void 0===r&&!(e in t))&&n(t,e,r)}t.exports=o},b7f0:function(t,e,r){var n=r("24fb");e=n(!1),e.push([t.i,".vc-select[data-v-7b2eaf0a]{position:relative}.vc-select select[data-v-7b2eaf0a]{flex-grow:1;display:block;-webkit-appearance:none;appearance:none;width:52px;height:30px;font-size:var(--text-base);font-weight:var(--font-medium);text-align:left;background-color:var(--gray-200);border:2px solid;border-color:var(--gray-200);color:var(--gray-900);padding:0 20px 0 8px;border-radius:var(--rounded);line-height:var(--leading-tight);text-indent:0;cursor:pointer;-moz-padding-start:3px;background-image:none}.vc-select select[data-v-7b2eaf0a]:hover{color:var(--gray-600)}.vc-select select[data-v-7b2eaf0a]:focus{outline:0;border-color:var(--accent-400);background-color:var(--white)}.vc-select-arrow[data-v-7b2eaf0a]{display:flex;align-items:center;pointer-events:none;position:absolute;top:0;bottom:0;right:0;padding:0 4px 0 0;color:var(--gray-500)}.vc-select-arrow svg[data-v-7b2eaf0a]{width:16px;height:16px;fill:currentColor}.vc-is-dark select[data-v-7b2eaf0a]{background:var(--gray-700);color:var(--gray-100);border-color:var(--gray-700)}.vc-is-dark select[data-v-7b2eaf0a]:hover{color:var(--gray-400)}.vc-is-dark select[data-v-7b2eaf0a]:focus{border-color:var(--accent-500);background-color:var(--gray-800)}",""]),t.exports=e},b980:function(t,e,r){"use strict";var n=r("d039"),a=r("5c6c");t.exports=!n((function(){var t=new Error("a");return!("stack"in t)||(Object.defineProperty(t,"stack",a(1,7)),7!==t.stack)}))},badf:function(t,e,r){var n=r("642a"),a=r("1838"),o=r("cd9d"),i=r("6747"),s=r("f9ce");function c(t){return"function"==typeof t?t:null==t?o:"object"==typeof t?i(t)?a(t[0],t[1]):n(t):s(t)}t.exports=c},bbc0:function(t,e,r){var n=r("6044"),a="__lodash_hash_undefined__",o=Object.prototype,i=o.hasOwnProperty;function s(t){var e=this.__data__;if(n){var r=e[t];return r===a?void 0:r}return i.call(e,t)?e[t]:void 0}t.exports=s},bfb3:function(t,e,r){var n=r("0840");n.__esModule&&(n=n.default),"string"===typeof n&&(n=[[t.i,n,""]]),n.locals&&(t.exports=n.locals);var a=r("499e").default;a("1d8413e8",n,!0,{sourceMap:!1,shadowMode:!1})},c04e:function(t,e,r){"use strict";var n=r("c65b"),a=r("861d"),o=r("d9b5"),i=r("dc4a"),s=r("485a"),c=r("b622"),u=TypeError,l=c("toPrimitive");t.exports=function(t,e){if(!a(t)||o(t))return t;var r,c=i(t,l);if(c){if(void 0===e&&(e="default"),r=n(c,t,e),!a(r)||o(r))return r;throw new u("Can't convert object to primitive value")}return void 0===e&&(e="number"),s(t,e)}},c05f:function(t,e,r){var n=r("7b97"),a=r("1310");function o(t,e,r,i,s){return t===e||(null==t||null==e||!a(t)&&!a(e)?t!==t&&e!==e:n(t,e,r,i,o,s))}t.exports=o},c098:function(t,e){var r=9007199254740991,n=/^(?:0|[1-9]\d*)$/;function a(t,e){var a=typeof t;return e=null==e?r:e,!!e&&("number"==a||"symbol"!=a&&n.test(t))&&t>-1&&t%1==0&&t<e}t.exports=a},c1c9:function(t,e,r){var n=r("a454"),a=r("f3c1"),o=a(n);t.exports=o},c2b6:function(t,e,r){var n=r("f8af"),a=r("5d89"),o=r("6f6c"),i=r("a2db"),s=r("c8fe"),c="[object Boolean]",u="[object Date]",l="[object Map]",d="[object Number]",f="[object RegExp]",p="[object Set]",h="[object String]",v="[object Symbol]",b="[object ArrayBuffer]",m="[object DataView]",g="[object Float32Array]",y="[object Float64Array]",w="[object Int8Array]",x="[object Int16Array]",D="[object Int32Array]",O="[object Uint8Array]",j="[object Uint8ClampedArray]",k="[object Uint16Array]",M="[object Uint32Array]";function P(t,e,r){var P=t.constructor;switch(e){case b:return n(t);case c:case u:return new P(+t);case m:return a(t,r);case g:case y:case w:case x:case D:case O:case j:case k:case M:return s(t,r);case l:return new P;case d:case h:return new P(t);case f:return o(t);case p:return new P;case v:return i(t)}}t.exports=P},c3fc:function(t,e,r){var n=r("42a2"),a=r("1310"),o="[object Set]";function i(t){return a(t)&&n(t)==o}t.exports=i},c430:function(t,e,r){"use strict";t.exports=!1},c584:function(t,e){function r(t,e){return t.has(e)}t.exports=r},c65b:function(t,e,r){"use strict";var n=r("40d5"),a=Function.prototype.call;t.exports=n?a.bind(a):function(){return a.apply(a,arguments)}},c6b6:function(t,e,r){"use strict";var n=r("e330"),a=n({}.toString),o=n("".slice);t.exports=function(t){return o(a(t),8,-1)}},c6cd:function(t,e,r){"use strict";var n=r("da84"),a=r("6374"),o="__core-js_shared__",i=n[o]||a(o,{});t.exports=i},c6cf:function(t,e,r){var n=r("4d8c"),a=r("2286"),o=r("c1c9");function i(t){return o(a(t,void 0,n),t+"")}t.exports=i},c869:function(t,e,r){var n=r("0b07"),a=r("2b3e"),o=n(a,"Set");t.exports=o},c87c:function(t,e){var r=Object.prototype,n=r.hasOwnProperty;function a(t){var e=t.length,r=new t.constructor(e);return e&&"string"==typeof t[0]&&n.call(t,"index")&&(r.index=t.index,r.input=t.input),r}t.exports=a},c8ba:function(t,e){var r;r=function(){return this}();try{r=r||new Function("return this")()}catch(n){"object"===typeof window&&(r=window)}t.exports=r},c8fe:function(t,e,r){var n=r("f8af");function a(t,e){var r=e?n(t.buffer):t.buffer;return new t.constructor(r,t.byteOffset,t.length)}t.exports=a},ca17:function(t,e,r){"use strict";r("2feb")},ca84:function(t,e,r){"use strict";var n=r("e330"),a=r("1a2d"),o=r("fc6a"),i=r("4d64").indexOf,s=r("d012"),c=n([].push);t.exports=function(t,e){var r,n=o(t),u=0,l=[];for(r in n)!a(s,r)&&a(n,r)&&c(l,r);while(e.length>u)a(n,r=e[u++])&&(~i(l,r)||c(l,r));return l}},cb2d:function(t,e,r){"use strict";var n=r("1626"),a=r("9bf2"),o=r("13d2"),i=r("6374");t.exports=function(t,e,r,s){s||(s={});var c=s.enumerable,u=void 0!==s.name?s.name:e;if(n(r)&&o(r,u,s),s.global)c?t[e]=r:i(e,r);else{try{s.unsafe?t[e]&&(c=!0):delete t[e]}catch(l){}c?t[e]=r:a.f(t,e,{value:r,enumerable:!1,configurable:!s.nonConfigurable,writable:!s.nonWritable})}return t}},cb5a:function(t,e,r){var n=r("9638");function a(t,e){var r=t.length;while(r--)if(n(t[r][0],e))return r;return-1}t.exports=a},cc12:function(t,e,r){"use strict";var n=r("da84"),a=r("861d"),o=n.document,i=a(o)&&a(o.createElement);t.exports=function(t){return i?o.createElement(t):{}}},cc45:function(t,e,r){var n=r("1a2d0"),a=r("b047"),o=r("99d3"),i=o&&o.isMap,s=i?a(i):n;t.exports=s},cd9d:function(t,e){function r(t){return t}t.exports=r},cdce:function(t,e,r){"use strict";var n=r("da84"),a=r("1626"),o=n.WeakMap;t.exports=a(o)&&/native code/.test(String(o))},ce86:function(t,e,r){var n=r("9e69"),a=r("7948"),o=r("6747"),i=r("ffd6"),s=1/0,c=n?n.prototype:void 0,u=c?c.toString:void 0;function l(t){if("string"==typeof t)return t;if(o(t))return a(t,l)+"";if(i(t))return u?u.call(t):"";var e=t+"";return"0"==e&&1/t==-s?"-0":e}t.exports=l},cebd:function(t,e){function r(t){var e=-1,r=Array(t.size);return t.forEach((function(t){r[++e]=[t,t]})),r}t.exports=r},cfe5:function(t,e,r){"use strict";r.d(e,"a",(function(){return c}));r("13d5");var n=r("f7f1"),a=r("2fa3"),o=r("9404"),i=r("29ae");const s=864e5;class c{constructor(t,{order:e=0,locale:r,isFullDay:s}={}){if(this.isDateInfo=!0,this.order=e,this.locale=r instanceof i["b"]?r:new i["b"](r),this.firstDayOfWeek=this.locale.firstDayOfWeek,!Object(o["m"])(t)){const e=this.locale.normalizeDate(t);t=s?{start:e,end:e}:{startOn:e,endOn:e}}let u=null,l=null;if(t.start?u=this.locale.normalizeDate(t.start,{...this.opts,time:"00:00:00"}):t.startOn&&(u=this.locale.normalizeDate(t.startOn,this.opts)),t.end?l=this.locale.normalizeDate(t.end,{...this.opts,time:"23:59:59"}):t.endOn&&(l=this.locale.normalizeDate(t.endOn,this.opts)),u&&l&&u>l){const t=u;u=l,l=t}else u&&t.span>=1&&(l=Object(n["a"])(u,t.span-1));this.start=u,this.startTime=u?u.getTime():NaN,this.end=l,this.endTime=l?l.getTime():NaN,this.isDate=this.startTime&&this.startTime===this.endTime,this.isRange=!this.isDate;const d=Object(a["i"])(t,{},c.patternProps);if(d.assigned&&(this.on={and:d.target}),t.on){const e=(Object(o["h"])(t.on)?t.on:[t.on]).map((function(t){if(Object(o["k"])(t))return t;const e=Object(a["i"])(t,{},c.patternProps);return e.assigned?e.target:null})).filter((function(t){return t}));e.length&&(this.on={...this.on,or:e})}this.isComplex=!!this.on}get opts(){return{order:this.order,locale:this.locale}}toDateInfo(t){return t.isDateInfo?t:new c(t,this.opts)}startOfWeek(t){const e=t.getDay()+1,r=e>=this.firstDayOfWeek?this.firstDayOfWeek-e:-(7-(this.firstDayOfWeek-e));return Object(n["a"])(t,r)}diffInDays(t,e){return Math.round((e-t)/s)}diffInWeeks(t,e){return this.diffInDays(this.startOfWeek(t),this.startOfWeek(e))}diffInYears(t,e){return e.getUTCFullYear()-t.getUTCFullYear()}diffInMonths(t,e){return 12*this.diffInYears(t,e)+(e.getMonth()-t.getMonth())}static get patterns(){return{dailyInterval:{test:function(t,e,r){return r.diffInDays(r.start||new Date,t.date)%e===0}},weeklyInterval:{test:function(t,e,r){return r.diffInWeeks(r.start||new Date,t.date)%e===0}},monthlyInterval:{test:function(t,e,r){return r.diffInMonths(r.start||new Date,t.date)%e===0}},yearlyInterval:{test:function(){return function(t,e,r){return r.diffInYears(r.start||new Date,t.date)%e===0}}},days:{validate:function(t){return Object(o["h"])(t)?t:[parseInt(t,10)]},test:function(t,e){return e.includes(t.day)||e.includes(-t.dayFromEnd)}},weekdays:{validate:function(t){return Object(o["h"])(t)?t:[parseInt(t,10)]},test:function(t,e){return e.includes(t.weekday)}},ordinalWeekdays:{validate:function(t){return Object.keys(t).reduce((function(e,r){const n=t[r];return n?(e[r]=Object(o["h"])(n)?n:[parseInt(n,10)],e):e}),{})},test:function(t,e){return Object.keys(e).map((function(t){return parseInt(t,10)})).find((function(r){return e[r].includes(t.weekday)&&(r===t.weekdayOrdinal||r===-t.weekdayOrdinalFromEnd)}))}},weekends:{validate:function(t){return t},test:function(t){return 1===t.weekday||7===t.weekday}},workweek:{validate:function(t){return t},test:function(t){return t.weekday>=2&&t.weekday<=6}},weeks:{validate:function(t){return Object(o["h"])(t)?t:[parseInt(t,10)]},test:function(t,e){return e.includes(t.week)||e.includes(-t.weekFromEnd)}},months:{validate:function(t){return Object(o["h"])(t)?t:[parseInt(t,10)]},test:function(t,e){return e.includes(t.month)}},years:{validate:function(t){return Object(o["h"])(t)?t:[parseInt(t,10)]},test:function(t,e){return e.includes(t.year)}}}}static get patternProps(){return Object.keys(c.patterns).map((function(t){return{name:t,validate:c.patterns[t].validate}}))}static testConfig(t,e,r){return Object(o["k"])(t)?t(e):Object(o["m"])(t)?Object.keys(t).every((function(n){return c.patterns[n].test(e,t[n],r)})):null}iterateDatesInRange({start:t,end:e},r){if(!t||!e||!Object(o["k"])(r))return null;t=this.locale.normalizeDate(t,{...this.opts,time:"00:00:00"});const a={i:0,date:t,day:this.locale.getDateParts(t),finished:!1};let i=null;for(;!a.finished&&a.date<=e;a.i++)i=r(a),a.date=Object(n["a"])(a.date,1),a.day=this.locale.getDateParts(a.date);return i}shallowIntersectingRange(t){return this.rangeShallowIntersectingRange(this,this.toDateInfo(t))}rangeShallowIntersectingRange(t,e){if(!this.dateShallowIntersectsDate(t,e))return null;const r=t.toRange(),n=e.toRange();let a=null,o=null;return r.start?a=n.start?r.start>n.start?r.start:n.start:r.start:n.start&&(a=n.start),r.end?o=n.end?r.end<n.end?r.end:n.end:r.end:n.end&&(o=n.end),{start:a,end:o}}intersectsDate(t){var e=this;const r=this.toDateInfo(t);if(!this.shallowIntersectsDate(r))return null;if(!this.on)return this;const n=this.rangeShallowIntersectingRange(this,r);let a=!1;return this.iterateDatesInRange(n,(function(t){e.matchesDay(t.day)&&(a=a||r.matchesDay(t.day),t.finished=a)})),a}shallowIntersectsDate(t){return this.dateShallowIntersectsDate(this,this.toDateInfo(t))}dateShallowIntersectsDate(t,e){return t.isDate?e.isDate?t.startTime===e.startTime:this.dateShallowIncludesDate(e,t):e.isDate?this.dateShallowIncludesDate(t,e):!(t.start&&e.end&&t.start>e.end)&&!(t.end&&e.start&&t.end<e.start)}includesDate(t){var e=this;const r=this.toDateInfo(t);if(!this.shallowIncludesDate(r))return!1;if(!this.on)return!0;const n=this.rangeShallowIntersectingRange(this,r);let a=!0;return this.iterateDatesInRange(n,(function(t){e.matchesDay(t.day)&&(a=a&&r.matchesDay(t.day),t.finished=!a)})),a}shallowIncludesDate(t){return this.dateShallowIncludesDate(this,t.isDate?t:new c(t,this.opts))}dateShallowIncludesDate(t,e){return t.isDate?e.isDate?t.startTime===e.startTime:!(!e.startTime||!e.endTime)&&(t.startTime===e.startTime&&t.startTime===e.endTime):e.isDate?!(t.start&&e.start<t.start)&&!(t.end&&e.start>t.end):!(t.start&&(!e.start||e.start<t.start))&&!(t.end&&(!e.end||e.end>t.end))}intersectsDay(t){return this.shallowIntersectsDate(t.range)&&this.matchesDay(t)?this:null}matchesDay(t){var e=this;return!this.on||!(this.on.and&&!c.testConfig(this.on.and,t,this))&&!(this.on.or&&!this.on.or.some((function(r){return c.testConfig(r,t,e)})))}toRange(){return new c({start:this.start,end:this.end},this.opts)}compare(t){if(this.order!==t.order)return this.order-t.order;if(this.isDate!==t.isDate)return this.isDate?1:-1;if(this.isDate)return 0;const e=this.start-t.start;return 0!==e?e:this.end-t.end}}},d012:function(t,e,r){"use strict";t.exports={}},d02c:function(t,e,r){var n=r("5e2e"),a=r("79bc"),o=r("7b83"),i=200;function s(t,e){var r=this.__data__;if(r instanceof n){var s=r.__data__;if(!a||s.length<i-1)return s.push([t,e]),this.size=++r.size,this;r=this.__data__=new o(s)}return r.set(t,e),this.size=r.size,this}t.exports=s},d039:function(t,e,r){"use strict";t.exports=function(t){try{return!!t()}catch(e){return!0}}},d066:function(t,e,r){"use strict";var n=r("da84"),a=r("1626"),o=function(t){return a(t)?t:void 0};t.exports=function(t,e){return arguments.length<2?o(n[t]):n[t]&&n[t][e]}},d1e7:function(t,e,r){"use strict";var n={}.propertyIsEnumerable,a=Object.getOwnPropertyDescriptor,o=a&&!n.call({1:2},1);e.f=o?function(t){var e=a(this,t);return!!e&&e.enumerable}:n},d2bb:function(t,e,r){"use strict";var n=r("7282"),a=r("825a"),o=r("3bbe");t.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var t,e=!1,r={};try{t=n(Object.prototype,"__proto__","set"),t(r,[]),e=r instanceof Array}catch(i){}return function(r,n){return a(r),o(n),e?t(r,n):r.__proto__=n,r}}():void 0)},d327:function(t,e){function r(){return[]}t.exports=r},d370:function(t,e,r){var n=r("253c"),a=r("1310"),o=Object.prototype,i=o.hasOwnProperty,s=o.propertyIsEnumerable,c=n(function(){return arguments}())?n:function(t){return a(t)&&i.call(t,"callee")&&!s.call(t,"callee")};t.exports=c},d58f:function(t,e,r){"use strict";var n=r("59ed"),a=r("7b0b"),o=r("44ad"),i=r("07fa"),s=TypeError,c=function(t){return function(e,r,c,u){n(r);var l=a(e),d=o(l),f=i(l),p=t?f-1:0,h=t?-1:1;if(c<2)while(1){if(p in d){u=d[p],p+=h;break}if(p+=h,t?p<0:f<=p)throw new s("Reduce of empty array with no initial value")}for(;t?p>=0:f>p;p+=h)p in d&&(u=r(u,d[p],p,l));return u}};t.exports={left:c(!1),right:c(!0)}},d612:function(t,e,r){var n=r("7b83"),a=r("7ed2"),o=r("dc0f");function i(t){var e=-1,r=null==t?0:t.length;this.__data__=new n;while(++e<r)this.add(t[e])}i.prototype.add=i.prototype.push=a,i.prototype.has=o,t.exports=i},d798:function(t,e,r){var n=r("24fb");e=n(!1),e.push([t.i,".vc-day-popover-row[data-v-eb5afd1a]{--day-content-transition-time:0.13s ease-in;display:flex;align-items:center;transition:all var(--day-content-transition-time)}.vc-day-popover-row[data-v-eb5afd1a]:not(:first-child){margin-top:3px}.vc-day-popover-row-indicator[data-v-eb5afd1a]{display:flex;justify-content:center;align-items:center;flex-grow:0;width:15px;margin-right:3px}.vc-day-popover-row-indicator span[data-v-eb5afd1a]{transition:all var(--day-content-transition-time)}.vc-day-popover-row-content[data-v-eb5afd1a]{display:flex;align-items:center;flex-wrap:none;flex-grow:1;width:max-content}",""]),t.exports=e},d7ee:function(t,e,r){var n=r("c3fc"),a=r("b047"),o=r("99d3"),i=o&&o.isSet,s=i?a(i):n;t.exports=s},d8e2:function(t,e,r){var n=r("24fb");e=n(!1),e.push([t.i,'.vc-popover-content-wrapper[data-v-03f17c2c]{--popover-horizontal-content-offset:8px;--popover-vertical-content-offset:10px;--popover-slide-translation:15px;--popover-transition-time:0.14s ease-in-out;--popover-caret-horizontal-offset:18px;--popover-caret-vertical-offset:8px;position:absolute;display:block;outline:none;z-index:10}.vc-popover-content-wrapper[data-v-03f17c2c]:not(.is-interactive){pointer-events:none}.vc-popover-content[data-v-03f17c2c]{position:relative;outline:none;z-index:10;box-shadow:var(--shadow-lg)}.vc-popover-content.direction-bottom[data-v-03f17c2c]{margin-top:var(--popover-vertical-content-offset)}.vc-popover-content.direction-top[data-v-03f17c2c]{margin-bottom:var(--popover-vertical-content-offset)}.vc-popover-content.direction-left[data-v-03f17c2c]{margin-right:var(--popover-horizontal-content-offset)}.vc-popover-content.direction-right[data-v-03f17c2c]{margin-left:var(--popover-horizontal-content-offset)}.vc-popover-caret[data-v-03f17c2c]{content:"";position:absolute;display:block;width:12px;height:12px;border-top:inherit;border-left:inherit;background-color:inherit;-webkit-user-select:none;user-select:none;z-index:-1}.vc-popover-caret.direction-bottom[data-v-03f17c2c]{top:0}.vc-popover-caret.direction-bottom.align-left[data-v-03f17c2c]{transform:translateY(-50%) rotate(45deg)}.vc-popover-caret.direction-bottom.align-center[data-v-03f17c2c]{transform:translateX(-50%) translateY(-50%) rotate(45deg)}.vc-popover-caret.direction-bottom.align-right[data-v-03f17c2c]{transform:translateY(-50%) rotate(45deg)}.vc-popover-caret.direction-top[data-v-03f17c2c]{top:100%}.vc-popover-caret.direction-top.align-left[data-v-03f17c2c]{transform:translateY(-50%) rotate(-135deg)}.vc-popover-caret.direction-top.align-center[data-v-03f17c2c]{transform:translateX(-50%) translateY(-50%) rotate(-135deg)}.vc-popover-caret.direction-top.align-right[data-v-03f17c2c]{transform:translateY(-50%) rotate(-135deg)}.vc-popover-caret.direction-left[data-v-03f17c2c]{left:100%}.vc-popover-caret.direction-left.align-top[data-v-03f17c2c]{transform:translateX(-50%) rotate(135deg)}.vc-popover-caret.direction-left.align-middle[data-v-03f17c2c]{transform:translateY(-50%) translateX(-50%) rotate(135deg)}.vc-popover-caret.direction-left.align-bottom[data-v-03f17c2c]{transform:translateX(-50%) rotate(135deg)}.vc-popover-caret.direction-right[data-v-03f17c2c]{left:0}.vc-popover-caret.direction-right.align-top[data-v-03f17c2c]{transform:translateX(-50%) rotate(-45deg)}.vc-popover-caret.direction-right.align-middle[data-v-03f17c2c]{transform:translateY(-50%) translateX(-50%) rotate(-45deg)}.vc-popover-caret.direction-right.align-bottom[data-v-03f17c2c]{transform:translateX(-50%) rotate(-45deg)}.vc-popover-caret.align-left[data-v-03f17c2c]{left:var(--popover-caret-horizontal-offset)}.vc-popover-caret.align-center[data-v-03f17c2c]{left:50%}.vc-popover-caret.align-right[data-v-03f17c2c]{right:var(--popover-caret-horizontal-offset)}.vc-popover-caret.align-top[data-v-03f17c2c]{top:var(--popover-caret-vertical-offset)}.vc-popover-caret.align-middle[data-v-03f17c2c]{top:50%}.vc-popover-caret.align-bottom[data-v-03f17c2c]{bottom:var(--popover-caret-vertical-offset)}.fade-enter-active[data-v-03f17c2c],.fade-leave-active[data-v-03f17c2c],.slide-fade-enter-active[data-v-03f17c2c],.slide-fade-leave-active[data-v-03f17c2c]{transition:all var(--popover-transition-time);pointer-events:none}.fade-enter[data-v-03f17c2c],.fade-leave-to[data-v-03f17c2c],.slide-fade-enter[data-v-03f17c2c],.slide-fade-leave-to[data-v-03f17c2c]{opacity:0}.slide-fade-enter.direction-bottom[data-v-03f17c2c],.slide-fade-leave-to.direction-bottom[data-v-03f17c2c]{transform:translateY(calc(var(--popover-slide-translation)*-1))}.slide-fade-enter.direction-top[data-v-03f17c2c],.slide-fade-leave-to.direction-top[data-v-03f17c2c]{transform:translateY(var(--popover-slide-translation))}.slide-fade-enter.direction-left[data-v-03f17c2c],.slide-fade-leave-to.direction-left[data-v-03f17c2c]{transform:translateX(var(--popover-slide-translation))}.slide-fade-enter.direction-right[data-v-03f17c2c],.slide-fade-leave-to.direction-right[data-v-03f17c2c]{transform:translateX(calc(var(--popover-slide-translation)*-1))}',""]),t.exports=e},d9b5:function(t,e,r){"use strict";var n=r("d066"),a=r("1626"),o=r("3a9b"),i=r("fdbf"),s=Object;t.exports=i?function(t){return"symbol"==typeof t}:function(t){var e=n("Symbol");return a(e)&&o(e.prototype,s(t))}},d9e2:function(t,e,r){"use strict";var n=r("23e7"),a=r("da84"),o=r("2ba4"),i=r("e5cb"),s="WebAssembly",c=a[s],u=7!==new Error("e",{cause:7}).cause,l=function(t,e){var r={};r[t]=i(t,e,u),n({global:!0,constructor:!0,arity:1,forced:u},r)},d=function(t,e){if(c&&c[t]){var r={};r[t]=i(s+"."+t,e,u),n({target:s,stat:!0,constructor:!0,arity:1,forced:u},r)}};l("Error",(function(t){return function(e){return o(t,this,arguments)}})),l("EvalError",(function(t){return function(e){return o(t,this,arguments)}})),l("RangeError",(function(t){return function(e){return o(t,this,arguments)}})),l("ReferenceError",(function(t){return function(e){return o(t,this,arguments)}})),l("SyntaxError",(function(t){return function(e){return o(t,this,arguments)}})),l("TypeError",(function(t){return function(e){return o(t,this,arguments)}})),l("URIError",(function(t){return function(e){return o(t,this,arguments)}})),d("CompileError",(function(t){return function(e){return o(t,this,arguments)}})),d("LinkError",(function(t){return function(e){return o(t,this,arguments)}})),d("RuntimeError",(function(t){return function(e){return o(t,this,arguments)}}))},da03:function(t,e,r){var n=r("2b3e"),a=n["__core-js_shared__"];t.exports=a},da84:function(t,e,r){"use strict";(function(e){var r=function(t){return t&&t.Math===Math&&t};t.exports=r("object"==typeof globalThis&&globalThis)||r("object"==typeof window&&window)||r("object"==typeof self&&self)||r("object"==typeof e&&e)||function(){return this}()||this||Function("return this")()}).call(this,r("c8ba"))},dc0f:function(t,e){function r(t){return this.__data__.has(t)}t.exports=r},dc4a:function(t,e,r){"use strict";var n=r("59ed"),a=r("7234");t.exports=function(t,e){var r=t[e];return a(r)?void 0:n(r)}},dc57:function(t,e){var r=Function.prototype,n=r.toString;function a(t){if(null!=t){try{return n.call(t)}catch(e){}try{return t+""}catch(e){}}return""}t.exports=a},dc8c:function(t,e,r){var n=r("24fb");e=n(!1),e.push([t.i,".vc-container{--white:#fff;--black:#000;--gray-100:#f7fafc;--gray-200:#edf2f7;--gray-300:#e2e8f0;--gray-400:#cbd5e0;--gray-500:#a0aec0;--gray-600:#718096;--gray-700:#4a5568;--gray-800:#2d3748;--gray-900:#1a202c;--red-100:#fff5f5;--red-200:#fed7d7;--red-300:#feb2b2;--red-400:#fc8181;--red-500:#f56565;--red-600:#e53e3e;--red-700:#c53030;--red-800:#9b2c2c;--red-900:#742a2a;--orange-100:#fffaf0;--orange-200:#feebc8;--orange-300:#fbd38d;--orange-400:#f6ad55;--orange-500:#ed8936;--orange-600:#dd6b20;--orange-700:#c05621;--orange-800:#9c4221;--orange-900:#7b341e;--yellow-100:ivory;--yellow-200:#fefcbf;--yellow-300:#faf089;--yellow-400:#f6e05e;--yellow-500:#ecc94b;--yellow-600:#d69e2e;--yellow-700:#b7791f;--yellow-800:#975a16;--yellow-900:#744210;--green-100:#f0fff4;--green-200:#c6f6d5;--green-300:#9ae6b4;--green-400:#68d391;--green-500:#48bb78;--green-600:#38a169;--green-700:#2f855a;--green-800:#276749;--green-900:#22543d;--teal-100:#e6fffa;--teal-200:#b2f5ea;--teal-300:#81e6d9;--teal-400:#4fd1c5;--teal-500:#38b2ac;--teal-600:#319795;--teal-700:#2c7a7b;--teal-800:#285e61;--teal-900:#234e52;--blue-100:#ebf8ff;--blue-200:#bee3f8;--blue-300:#90cdf4;--blue-400:#63b3ed;--blue-500:#4299e1;--blue-600:#3182ce;--blue-700:#2b6cb0;--blue-800:#2c5282;--blue-900:#2a4365;--indigo-100:#ebf4ff;--indigo-200:#c3dafe;--indigo-300:#a3bffa;--indigo-400:#7f9cf5;--indigo-500:#667eea;--indigo-600:#5a67d8;--indigo-700:#4c51bf;--indigo-800:#434190;--indigo-900:#3c366b;--purple-100:#faf5ff;--purple-200:#e9d8fd;--purple-300:#d6bcfa;--purple-400:#b794f4;--purple-500:#9f7aea;--purple-600:#805ad5;--purple-700:#6b46c1;--purple-800:#553c9a;--purple-900:#44337a;--pink-100:#fff5f7;--pink-200:#fed7e2;--pink-300:#fbb6ce;--pink-400:#f687b3;--pink-500:#ed64a6;--pink-600:#d53f8c;--pink-700:#b83280;--pink-800:#97266d;--pink-900:#702459}.vc-container.vc-red{--accent-100:var(--red-100);--accent-200:var(--red-200);--accent-300:var(--red-300);--accent-400:var(--red-400);--accent-500:var(--red-500);--accent-600:var(--red-600);--accent-700:var(--red-700);--accent-800:var(--red-800);--accent-900:var(--red-900)}.vc-container.vc-orange{--accent-100:var(--orange-100);--accent-200:var(--orange-200);--accent-300:var(--orange-300);--accent-400:var(--orange-400);--accent-500:var(--orange-500);--accent-600:var(--orange-600);--accent-700:var(--orange-700);--accent-800:var(--orange-800);--accent-900:var(--orange-900)}.vc-container.vc-yellow{--accent-100:var(--yellow-100);--accent-200:var(--yellow-200);--accent-300:var(--yellow-300);--accent-400:var(--yellow-400);--accent-500:var(--yellow-500);--accent-600:var(--yellow-600);--accent-700:var(--yellow-700);--accent-800:var(--yellow-800);--accent-900:var(--yellow-900)}.vc-container.vc-green{--accent-100:var(--green-100);--accent-200:var(--green-200);--accent-300:var(--green-300);--accent-400:var(--green-400);--accent-500:var(--green-500);--accent-600:var(--green-600);--accent-700:var(--green-700);--accent-800:var(--green-800);--accent-900:var(--green-900)}.vc-container.vc-teal{--accent-100:var(--teal-100);--accent-200:var(--teal-200);--accent-300:var(--teal-300);--accent-400:var(--teal-400);--accent-500:var(--teal-500);--accent-600:var(--teal-600);--accent-700:var(--teal-700);--accent-800:var(--teal-800);--accent-900:var(--teal-900)}.vc-container.vc-blue{--accent-100:var(--blue-100);--accent-200:var(--blue-200);--accent-300:var(--blue-300);--accent-400:var(--blue-400);--accent-500:var(--blue-500);--accent-600:var(--blue-600);--accent-700:var(--blue-700);--accent-800:var(--blue-800);--accent-900:var(--blue-900)}.vc-container.vc-indigo{--accent-100:var(--indigo-100);--accent-200:var(--indigo-200);--accent-300:var(--indigo-300);--accent-400:var(--indigo-400);--accent-500:var(--indigo-500);--accent-600:var(--indigo-600);--accent-700:var(--indigo-700);--accent-800:var(--indigo-800);--accent-900:var(--indigo-900)}.vc-container.vc-purple{--accent-100:var(--purple-100);--accent-200:var(--purple-200);--accent-300:var(--purple-300);--accent-400:var(--purple-400);--accent-500:var(--purple-500);--accent-600:var(--purple-600);--accent-700:var(--purple-700);--accent-800:var(--purple-800);--accent-900:var(--purple-900)}.vc-container.vc-pink{--accent-100:var(--pink-100);--accent-200:var(--pink-200);--accent-300:var(--pink-300);--accent-400:var(--pink-400);--accent-500:var(--pink-500);--accent-600:var(--pink-600);--accent-700:var(--pink-700);--accent-800:var(--pink-800);--accent-900:var(--pink-900)}.vc-container{--font-normal:400;--font-medium:500;--font-semibold:600;--font-bold:700;--text-xs:12px;--text-sm:14px;--text-base:16px;--text-lg:18px;--leading-snug:1.375;--rounded:0.25rem;--rounded-lg:0.5rem;--rounded-full:9999px;--shadow:0 1px 3px 0 rgba(0,0,0,0.1),0 1px 2px 0 rgba(0,0,0,0.06);--shadow-lg:0 10px 15px -3px rgba(0,0,0,0.1),0 4px 6px -2px rgba(0,0,0,0.05);--shadow-inner:inset 0 2px 4px 0 rgba(0,0,0,0.06);--slide-translate:22px;--slide-duration:0.15s;--slide-timing:ease;--day-content-transition-time:0.13s ease-in;--weeknumber-offset:-34px;position:relative;display:inline-flex;width:max-content;height:max-content;font-family:BlinkMacSystemFont,-apple-system,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,Helvetica,Arial,sans-serif;color:var(--gray-900);background-color:var(--white);border:1px solid;border-color:var(--gray-400);border-radius:var(--rounded-lg);-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;-webkit-tap-highlight-color:transparent}.vc-container,.vc-container *{box-sizing:border-box}.vc-container:focus,.vc-container :focus{outline:none}.vc-container [role=button],.vc-container button{cursor:pointer}.vc-container.vc-is-expanded{min-width:100%}.vc-container .vc-container{border:none}.vc-container.vc-is-dark{color:var(--gray-100);background-color:var(--gray-900);border-color:var(--gray-700)}",""]),t.exports=e},dc9e:function(t,e,r){"use strict";r("eb68")},dcbe:function(t,e,r){var n=r("30c9"),a=r("1310");function o(t){return a(t)&&n(t)}t.exports=o},dd61:function(t,e,r){var n=r("7948"),a=r("badf"),o=r("97d3"),i=r("6747");function s(t,e){var r=i(t)?n:o;return r(t,a(e,3))}t.exports=s},e031:function(t,e,r){var n=r("f909"),a=r("1a8c");function o(t,e,r,i,s,c){return a(t)&&a(e)&&(c.set(e,t),n(t,e,void 0,o,c),c["delete"](e)),t}t.exports=o},e0e7:function(t,e,r){var n=r("60ed");function a(t){return n(t)?void 0:t}t.exports=a},e177:function(t,e,r){"use strict";r("55ed")},e24b:function(t,e,r){var n=r("49f4"),a=r("1efc"),o=r("bbc0"),i=r("7a48"),s=r("2524");function c(t){var e=-1,r=null==t?0:t.length;this.clear();while(++e<r){var n=t[e];this.set(n[0],n[1])}}c.prototype.clear=n,c.prototype["delete"]=a,c.prototype.get=o,c.prototype.has=i,c.prototype.set=s,t.exports=c},e2a0:function(t,e,r){var n=r("3729"),a=r("6747"),o=r("1310"),i="[object String]";function s(t){return"string"==typeof t||!a(t)&&o(t)&&n(t)==i}t.exports=s},e2c0:function(t,e,r){var n=r("e2e4"),a=r("d370"),o=r("6747"),i=r("c098"),s=r("b218"),c=r("f4d6");function u(t,e,r){e=n(e,t);var u=-1,l=e.length,d=!1;while(++u<l){var f=c(e[u]);if(!(d=null!=t&&r(t,f)))break;t=t[f]}return d||++u!=l?d:(l=null==t?0:t.length,!!l&&s(l)&&i(f,l)&&(o(t)||a(t)))}t.exports=u},e2e4:function(t,e,r){var n=r("6747"),a=r("f608"),o=r("18d8"),i=r("76dd");function s(t,e){return n(t)?t:a(t,e)?[t]:o(i(t))}t.exports=s},e330:function(t,e,r){"use strict";var n=r("40d5"),a=Function.prototype,o=a.call,i=n&&a.bind.bind(o,o);t.exports=n?i:function(t){return function(){return o.apply(t,arguments)}}},e380:function(t,e,r){var n=r("7b83"),a="Expected a function";function o(t,e){if("function"!=typeof t||null!=e&&"function"!=typeof e)throw new TypeError(a);var r=function(){var n=arguments,a=e?e.apply(this,n):n[0],o=r.cache;if(o.has(a))return o.get(a);var i=t.apply(this,n);return r.cache=o.set(a,i)||o,i};return r.cache=new(o.Cache||n),r}o.Cache=n,t.exports=o},e391:function(t,e,r){"use strict";var n=r("577e");t.exports=function(t,e){return void 0===t?arguments.length<2?"":e:n(t)}},e3f8:function(t,e,r){var n=r("656b");function a(t){return function(e){return n(e,t)}}t.exports=a},e538:function(t,e,r){(function(t){var n=r("2b3e"),a=e&&!e.nodeType&&e,o=a&&"object"==typeof t&&t&&!t.nodeType&&t,i=o&&o.exports===a,s=i?n.Buffer:void 0,c=s?s.allocUnsafe:void 0;function u(t,e){if(e)return t.slice();var r=t.length,n=c?c(r):new t.constructor(r);return t.copy(n),n}t.exports=u}).call(this,r("62e4")(t))},e5cb:function(t,e,r){"use strict";var n=r("d066"),a=r("1a2d"),o=r("9112"),i=r("3a9b"),s=r("d2bb"),c=r("e893"),u=r("aeb0"),l=r("7156"),d=r("e391"),f=r("ab36"),p=r("6f19"),h=r("83ab"),v=r("c430");t.exports=function(t,e,r,b){var m="stackTraceLimit",g=b?2:1,y=t.split("."),w=y[y.length-1],x=n.apply(null,y);if(x){var D=x.prototype;if(!v&&a(D,"cause")&&delete D.cause,!r)return x;var O=n("Error"),j=e((function(t,e){var r=d(b?e:t,void 0),n=b?new x(t):new x;return void 0!==r&&o(n,"message",r),p(n,j,n.stack,2),this&&i(D,this)&&l(n,this,j),arguments.length>g&&f(n,arguments[g]),n}));if(j.prototype=D,"Error"!==w?s?s(j,O):c(j,O,{name:!0}):h&&m in x&&(u(j,x,m),u(j,x,"prepareStackTrace")),c(j,x),!v)try{D.name!==w&&o(D,"name",w),D.constructor=j}catch(k){}return j}}},e893:function(t,e,r){"use strict";var n=r("1a2d"),a=r("56ef"),o=r("06cf"),i=r("9bf2");t.exports=function(t,e,r){for(var s=a(e),c=i.f,u=o.f,l=0;l<s.length;l++){var d=s[l];n(t,d)||r&&n(r,d)||c(t,d,u(e,d))}}},e8b5:function(t,e,r){"use strict";var n=r("c6b6");t.exports=Array.isArray||function(t){return"Array"===n(t)}},eac5:function(t,e){var r=Object.prototype;function n(t){var e=t&&t.constructor,n="function"==typeof e&&e.prototype||r;return t===n}t.exports=n},eb68:function(t,e,r){var n=r("b0b5");n.__esModule&&(n=n.default),"string"===typeof n&&(n=[[t.i,n,""]]),n.locals&&(t.exports=n.locals);var a=r("499e").default;a("06cf7692",n,!0,{sourceMap:!1,shadowMode:!1})},ec47:function(t,e,r){var n=r("a3fd"),a=r("42a2"),o=r("edfa"),i=r("cebd"),s="[object Map]",c="[object Set]";function u(t){return function(e){var r=a(e);return r==s?o(e):r==c?i(e):n(e,t(e))}}t.exports=u},ec69:function(t,e,r){var n=r("6fcd"),a=r("03dd"),o=r("30c9");function i(t){return o(t)?n(t):a(t)}t.exports=i},ec8c:function(t,e){function r(t){var e=[];if(null!=t)for(var r in Object(t))e.push(r);return e}t.exports=r},ed08:function(t,e,r){"use strict";r.r(e),r.d(e,"Locale",(function(){return n["b"]})),r.d(e,"DateInfo",(function(){return a["a"]})),r.d(e,"Attribute",(function(){return o["a"]})),r.d(e,"AttributeStore",(function(){return i["a"]})),r.d(e,"setupCalendar",(function(){return u})),r.d(e,"pad",(function(){return l["m"]})),r.d(e,"evalFn",(function(){return l["f"]})),r.d(e,"mergeEvents",(function(){return l["h"]})),r.d(e,"pageIsValid",(function(){return l["r"]})),r.d(e,"pageIsBeforePage",(function(){return l["o"]})),r.d(e,"pageIsAfterPage",(function(){return l["n"]})),r.d(e,"pageIsBetweenPages",(function(){return l["p"]})),r.d(e,"pageIsEqualToPage",(function(){return l["q"]})),r.d(e,"addPages",(function(){return l["a"]})),r.d(e,"pageRangeToArray",(function(){return l["s"]})),r.d(e,"datesAreEqual",(function(){return l["d"]})),r.d(e,"arrayHasItems",(function(){return l["b"]})),r.d(e,"mixinOptionalProps",(function(){return l["i"]})),r.d(e,"on",(function(){return l["k"]})),r.d(e,"off",(function(){return l["j"]})),r.d(e,"elementContains",(function(){return l["e"]})),r.d(e,"onSpaceOrEnter",(function(){return l["l"]})),r.d(e,"createGuid",(function(){return l["c"]})),r.d(e,"hash",(function(){return l["g"]})),r.d(e,"addHorizontalSwipeHandler",(function(){return d["a"]}));var n=r("29ae"),a=r("cfe5"),o=r("22f3"),i=r("9349"),s=r("51ec"),c=r("1315"),u=function(t){const e=Object(s["b"])(t);return Object(c["a"])(e.screens,!0),e},l=r("2fa3"),d=r("0733")},edfa:function(t,e){function r(t){var e=-1,r=Array(t.size);return t.forEach((function(t,n){r[++e]=[n,t]})),r}t.exports=r},ef5d:function(t,e){function r(t){return function(e){return null==e?void 0:e[t]}}t.exports=r},efb6:function(t,e,r){var n=r("5e2e");function a(){this.__data__=new n,this.size=0}t.exports=a},f15d:function(t,e,r){"use strict";var n=r("9404");const a={ar:{dow:7,L:"D/‏M/‏YYYY"},bg:{dow:2,L:"D.MM.YYYY"},ca:{dow:2,L:"DD/MM/YYYY"},"zh-CN":{dow:2,L:"YYYY/MM/DD"},"zh-TW":{dow:1,L:"YYYY/MM/DD"},hr:{dow:2,L:"DD.MM.YYYY"},cs:{dow:2,L:"DD.MM.YYYY"},da:{dow:2,L:"DD.MM.YYYY"},nl:{dow:2,L:"DD-MM-YYYY"},"en-US":{dow:1,L:"MM/DD/YYYY"},"en-AU":{dow:2,L:"DD/MM/YYYY"},"en-CA":{dow:1,L:"YYYY-MM-DD"},"en-GB":{dow:2,L:"DD/MM/YYYY"},"en-IE":{dow:2,L:"DD-MM-YYYY"},"en-NZ":{dow:2,L:"DD/MM/YYYY"},"en-ZA":{dow:1,L:"YYYY/MM/DD"},eo:{dow:2,L:"YYYY-MM-DD"},et:{dow:2,L:"DD.MM.YYYY"},fi:{dow:2,L:"DD.MM.YYYY"},fr:{dow:2,L:"DD/MM/YYYY"},"fr-CA":{dow:1,L:"YYYY-MM-DD"},"fr-CH":{dow:2,L:"DD.MM.YYYY"},de:{dow:2,L:"DD.MM.YYYY"},he:{dow:1,L:"DD.MM.YYYY"},id:{dow:2,L:"DD/MM/YYYY"},it:{dow:2,L:"DD/MM/YYYY"},ja:{dow:1,L:"YYYY年M月D日"},ko:{dow:1,L:"YYYY.MM.DD"},lv:{dow:2,L:"DD.MM.YYYY"},lt:{dow:2,L:"DD.MM.YYYY"},mk:{dow:2,L:"D.MM.YYYY"},nb:{dow:2,L:"D. MMMM YYYY"},nn:{dow:2,L:"D. MMMM YYYY"},pl:{dow:2,L:"DD.MM.YYYY"},pt:{dow:2,L:"DD/MM/YYYY"},ro:{dow:2,L:"DD.MM.YYYY"},ru:{dow:2,L:"DD.MM.YYYY"},sk:{dow:2,L:"DD.MM.YYYY"},"es-ES":{dow:2,L:"DD/MM/YYYY"},"es-MX":{dow:2,L:"DD/MM/YYYY"},sv:{dow:2,L:"YYYY-MM-DD"},th:{dow:1,L:"DD/MM/YYYY"},tr:{dow:2,L:"DD.MM.YYYY"},uk:{dow:2,L:"DD.MM.YYYY"},vi:{dow:2,L:"DD/MM/YYYY"}};a.en=a["en-US"],a.es=a["es-ES"],a.no=a.nb,a.zh=a["zh-CN"],Object(n["w"])(a).forEach((function([t,{dow:e,L:r}]){a[t]={id:t,firstDayOfWeek:e,masks:{L:r}}})),e["a"]=a},f3c1:function(t,e){var r=800,n=16,a=Date.now;function o(t){var e=0,o=0;return function(){var i=a(),s=n-(i-o);if(o=i,s>0){if(++e>=r)return arguments[0]}else e=0;return t.apply(void 0,arguments)}}t.exports=o},f4d6:function(t,e,r){var n=r("ffd6"),a=1/0;function o(t){if("string"==typeof t||n(t))return t;var e=t+"";return"0"==e&&1/t==-a?"-0":e}t.exports=o},f542:function(t,e,r){var n=r("ec47"),a=r("ec69"),o=n(a);t.exports=o},f5df:function(t,e,r){"use strict";var n=r("00ee"),a=r("1626"),o=r("c6b6"),i=r("b622"),s=i("toStringTag"),c=Object,u="Arguments"===o(function(){return arguments}()),l=function(t,e){try{return t[e]}catch(r){}};t.exports=n?o:function(t){var e,r,n;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(r=l(e=c(t),s))?r:u?o(e):"Object"===(n=o(e))&&a(e.callee)?"Arguments":n}},f608:function(t,e,r){var n=r("6747"),a=r("ffd6"),o=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,i=/^\w*$/;function s(t,e){if(n(t))return!1;var r=typeof t;return!("number"!=r&&"symbol"!=r&&"boolean"!=r&&null!=t&&!a(t))||(i.test(t)||!o.test(t)||null!=e&&t in Object(e))}t.exports=s},f678:function(t,e,r){var n=r("8384"),a=r("b4b0");function o(t,e,r){return void 0===r&&(r=e,e=void 0),void 0!==r&&(r=a(r),r=r===r?r:0),void 0!==e&&(e=a(e),e=e===e?e:0),n(a(t),e,r)}t.exports=o},f772:function(t,e,r){"use strict";var n=r("5692"),a=r("90e3"),o=n("keys");t.exports=function(t){return o[t]||(o[t]=a(t))}},f7f1:function(t,e,r){"use strict";r.d(e,"a",(function(){return i}));var n=r("fe1f"),a=r("fd3a"),o=r("8c86");function i(t,e){Object(o["a"])(2,arguments);var r=Object(a["a"])(t),i=Object(n["a"])(e);return isNaN(i)?new Date(NaN):i?(r.setDate(r.getDate()+i),r):r}},f8af:function(t,e,r){var n=r("2474");function a(t){var e=new t.constructor(t.byteLength);return new n(e).set(new n(t)),e}t.exports=a},f909:function(t,e,r){var n=r("7e64"),a=r("b760"),o=r("72af"),i=r("4f50"),s=r("1a8c"),c=r("9934"),u=r("8adb");function l(t,e,r,d,f){t!==e&&o(e,(function(o,c){if(f||(f=new n),s(o))i(t,e,c,r,l,d,f);else{var p=d?d(u(t,c),o,c+"",t,e,f):void 0;void 0===p&&(p=o),a(t,c,p)}}),c)}t.exports=l},f954:function(t,e,r){"use strict";r("8518")},f9ce:function(t,e,r){var n=r("ef5d"),a=r("e3f8"),o=r("f608"),i=r("f4d6");function s(t){return o(t)?n(i(t)):a(t)}t.exports=s},fa21:function(t,e,r){var n=r("7530"),a=r("2dcb"),o=r("eac5");function i(t){return"function"!=typeof t.constructor||o(t)?{}:n(a(t))}t.exports=i},fb15:function(t,e,r){"use strict";if(r.r(e),r.d(e,"Calendar",(function(){return o["c"]})),r.d(e,"CalendarNav",(function(){return o["d"]})),r.d(e,"DatePicker",(function(){return o["f"]})),r.d(e,"Popover",(function(){return o["h"]})),r.d(e,"Locale",(function(){return o["g"]})),r.d(e,"DateInfo",(function(){return o["e"]})),r.d(e,"Attribute",(function(){return o["a"]})),r.d(e,"AttributeStore",(function(){return o["b"]})),r.d(e,"setupCalendar",(function(){return o["D"]})),r.d(e,"pad",(function(){return o["w"]})),r.d(e,"evalFn",(function(){return o["p"]})),r.d(e,"mergeEvents",(function(){return o["r"]})),r.d(e,"pageIsValid",(function(){return o["B"]})),r.d(e,"pageIsBeforePage",(function(){return o["y"]})),r.d(e,"pageIsAfterPage",(function(){return o["x"]})),r.d(e,"pageIsBetweenPages",(function(){return o["z"]})),r.d(e,"pageIsEqualToPage",(function(){return o["A"]})),r.d(e,"addPages",(function(){return o["j"]})),r.d(e,"pageRangeToArray",(function(){return o["C"]})),r.d(e,"datesAreEqual",(function(){return o["m"]})),r.d(e,"arrayHasItems",(function(){return o["k"]})),r.d(e,"mixinOptionalProps",(function(){return o["s"]})),r.d(e,"on",(function(){return o["u"]})),r.d(e,"off",(function(){return o["t"]})),r.d(e,"elementContains",(function(){return o["o"]})),r.d(e,"onSpaceOrEnter",(function(){return o["v"]})),r.d(e,"createGuid",(function(){return o["l"]})),r.d(e,"hash",(function(){return o["q"]})),r.d(e,"addHorizontalSwipeHandler",(function(){return o["i"]})),"undefined"!==typeof window){var n=window.document.currentScript,a=n&&n.src.match(/(.+\/)[^/]+\.js(\?.*)?$/);a&&(r.p=a[1])}var o=r("34e9");e["default"]=o["n"]},fba5:function(t,e,r){var n=r("cb5a");function a(t){return n(this.__data__,t)>-1}t.exports=a},fc6a:function(t,e,r){"use strict";var n=r("44ad"),a=r("1d80");t.exports=function(t){return n(a(t))}},fd3a:function(t,e,r){"use strict";r.d(e,"a",(function(){return o}));var n=r("53ca"),a=r("8c86");function o(t){Object(a["a"])(1,arguments);var e=Object.prototype.toString.call(t);return t instanceof Date||"object"===Object(n["a"])(t)&&"[object Date]"===e?new Date(t.getTime()):"number"===typeof t||"[object Number]"===e?new Date(t):("string"!==typeof t&&"[object String]"!==e||"undefined"===typeof console||(console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments"),console.warn((new Error).stack)),new Date(NaN))}},fdbf:function(t,e,r){"use strict";var n=r("04f8");t.exports=n&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},fe1f:function(t,e,r){"use strict";function n(t){if(null===t||!0===t||!1===t)return NaN;var e=Number(t);return isNaN(e)?e:e<0?Math.ceil(e):Math.floor(e)}r.d(e,"a",(function(){return n}))},ffd6:function(t,e,r){var n=r("3729"),a=r("1310"),o="[object Symbol]";function i(t){return"symbol"==typeof t||a(t)&&n(t)==o}t.exports=i}})}));
//# sourceMappingURL=v-calendar.umd.min.js.map

/***/ }),

/***/ 951:
/***/ (function(__unused_webpack_module, exports) {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
// runtime helper for setting properties on components
// in a tree-shakable way
exports.A = (sfc, props) => {
    const target = sfc.__vccOpts || sfc;
    for (const [key, val] of props) {
        target[key] = val;
    }
    return target;
};


/***/ }),

/***/ 99:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

(function(t,e){ true?module.exports=e(__webpack_require__(878)):0})("undefined"!==typeof self?self:this,(function(t){return function(t){var e={};function r(n){if(e[n])return e[n].exports;var o=e[n]={i:n,l:!1,exports:{}};return t[n].call(o.exports,o,o.exports,r),o.l=!0,o.exports}return r.m=t,r.c=e,r.d=function(t,e,n){r.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:n})},r.r=function(t){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},r.t=function(t,e){if(1&e&&(t=r(t)),8&e)return t;if(4&e&&"object"===typeof t&&t&&t.__esModule)return t;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var o in t)r.d(n,o,function(e){return t[e]}.bind(null,o));return n},r.n=function(t){var e=t&&t.__esModule?function(){return t["default"]}:function(){return t};return r.d(e,"a",e),e},r.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},r.p="",r(r.s="fb15")}({"091b":function(t,e,r){var n=r("24fb");e=n(!1),e.push([t.i,".vue-slider-dot{position:absolute;-webkit-transition:all 0s;transition:all 0s;z-index:5}.vue-slider-dot:focus{outline:none}.vue-slider-dot-tooltip{position:absolute;visibility:hidden}.vue-slider-dot-hover:hover .vue-slider-dot-tooltip,.vue-slider-dot-tooltip-show{visibility:visible}.vue-slider-dot-tooltip-top{top:-10px;left:50%;-webkit-transform:translate(-50%,-100%);transform:translate(-50%,-100%)}.vue-slider-dot-tooltip-bottom{bottom:-10px;left:50%;-webkit-transform:translate(-50%,100%);transform:translate(-50%,100%)}.vue-slider-dot-tooltip-left{left:-10px;top:50%;-webkit-transform:translate(-100%,-50%);transform:translate(-100%,-50%)}.vue-slider-dot-tooltip-right{right:-10px;top:50%;-webkit-transform:translate(100%,-50%);transform:translate(100%,-50%)}",""]),t.exports=e},"24fb":function(t,e,r){"use strict";function n(t,e){var r=t[1]||"",n=t[3];if(!n)return r;if(e&&"function"===typeof btoa){var i=o(n),a=n.sources.map((function(t){return"/*# sourceURL=".concat(n.sourceRoot||"").concat(t," */")}));return[r].concat(a).concat([i]).join("\n")}return[r].join("\n")}function o(t){var e=btoa(unescape(encodeURIComponent(JSON.stringify(t)))),r="sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(e);return"/*# ".concat(r," */")}t.exports=function(t){var e=[];return e.toString=function(){return this.map((function(e){var r=n(e,t);return e[2]?"@media ".concat(e[2]," {").concat(r,"}"):r})).join("")},e.i=function(t,r,n){"string"===typeof t&&(t=[[null,t,""]]);var o={};if(n)for(var i=0;i<this.length;i++){var a=this[i][0];null!=a&&(o[a]=!0)}for(var s=0;s<t.length;s++){var u=[].concat(t[s]);n&&o[u[0]]||(r&&(u[2]?u[2]="".concat(r," and ").concat(u[2]):u[2]=r),e.push(u))}},e}},2638:function(t,e,r){"use strict";function n(){return n=Object.assign||function(t){for(var e,r=1;r<arguments.length;r++)for(var n in e=arguments[r],e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t},n.apply(this,arguments)}var o=["attrs","props","domProps"],i=["class","style","directives"],a=["on","nativeOn"],s=function(t){return t.reduce((function(t,e){for(var r in e)if(t[r])if(-1!==o.indexOf(r))t[r]=n({},t[r],e[r]);else if(-1!==i.indexOf(r)){var s=t[r]instanceof Array?t[r]:[t[r]],l=e[r]instanceof Array?e[r]:[e[r]];t[r]=s.concat(l)}else if(-1!==a.indexOf(r))for(var c in e[r])if(t[r][c]){var d=t[r][c]instanceof Array?t[r][c]:[t[r][c]],f=e[r][c]instanceof Array?e[r][c]:[e[r][c]];t[r][c]=d.concat(f)}else t[r][c]=e[r][c];else if("hook"==r)for(var h in e[r])t[r][h]=t[r][h]?u(t[r][h],e[r][h]):e[r][h];else t[r]=e[r];else t[r]=e[r];return t}),{})},u=function(t,e){return function(){t&&t.apply(this,arguments),e&&e.apply(this,arguments)}};t.exports=s},"499e":function(t,e,r){"use strict";function n(t,e){for(var r=[],n={},o=0;o<e.length;o++){var i=e[o],a=i[0],s=i[1],u=i[2],l=i[3],c={id:t+":"+o,css:s,media:u,sourceMap:l};n[a]?n[a].parts.push(c):r.push(n[a]={id:a,parts:[c]})}return r}r.r(e),r.d(e,"default",(function(){return p}));var o="undefined"!==typeof document;if("undefined"!==typeof DEBUG&&DEBUG&&!o)throw new Error("vue-style-loader cannot be used in a non-browser environment. Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.");var i={},a=o&&(document.head||document.getElementsByTagName("head")[0]),s=null,u=0,l=!1,c=function(){},d=null,f="data-vue-ssr-id",h="undefined"!==typeof navigator&&/msie [6-9]\b/.test(navigator.userAgent.toLowerCase());function p(t,e,r,o){l=r,d=o||{};var a=n(t,e);return y(a),function(e){for(var r=[],o=0;o<a.length;o++){var s=a[o],u=i[s.id];u.refs--,r.push(u)}e?(a=n(t,e),y(a)):a=[];for(o=0;o<r.length;o++){u=r[o];if(0===u.refs){for(var l=0;l<u.parts.length;l++)u.parts[l]();delete i[u.id]}}}}function y(t){for(var e=0;e<t.length;e++){var r=t[e],n=i[r.id];if(n){n.refs++;for(var o=0;o<n.parts.length;o++)n.parts[o](r.parts[o]);for(;o<r.parts.length;o++)n.parts.push(m(r.parts[o]));n.parts.length>r.parts.length&&(n.parts.length=r.parts.length)}else{var a=[];for(o=0;o<r.parts.length;o++)a.push(m(r.parts[o]));i[r.id]={id:r.id,refs:1,parts:a}}}}function v(){var t=document.createElement("style");return t.type="text/css",a.appendChild(t),t}function m(t){var e,r,n=document.querySelector("style["+f+'~="'+t.id+'"]');if(n){if(l)return c;n.parentNode.removeChild(n)}if(h){var o=u++;n=s||(s=v()),e=g.bind(null,n,o,!1),r=g.bind(null,n,o,!0)}else n=v(),e=k.bind(null,n),r=function(){n.parentNode.removeChild(n)};return e(t),function(n){if(n){if(n.css===t.css&&n.media===t.media&&n.sourceMap===t.sourceMap)return;e(t=n)}else r()}}var b=function(){var t=[];return function(e,r){return t[e]=r,t.filter(Boolean).join("\n")}}();function g(t,e,r,n){var o=r?"":n.css;if(t.styleSheet)t.styleSheet.cssText=b(e,o);else{var i=document.createTextNode(o),a=t.childNodes;a[e]&&t.removeChild(a[e]),a.length?t.insertBefore(i,a[e]):t.appendChild(i)}}function k(t,e){var r=e.css,n=e.media,o=e.sourceMap;if(n&&t.setAttribute("media",n),d.ssrId&&t.setAttribute(f,e.id),o&&(r+="\n/*# sourceURL="+o.sources[0]+" */",r+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(o))))+" */"),t.styleSheet)t.styleSheet.cssText=r;else{while(t.firstChild)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(r))}}},"4abb":function(t,e,r){var n=r("7a57");"string"===typeof n&&(n=[[t.i,n,""]]),n.locals&&(t.exports=n.locals);var o=r("499e").default;o("b2af7572",n,!0,{sourceMap:!1,shadowMode:!1})},"4ed8":function(t,e,r){var n=r("091b");"string"===typeof n&&(n=[[t.i,n,""]]),n.locals&&(t.exports=n.locals);var o=r("499e").default;o("2f6bee1a",n,!0,{sourceMap:!1,shadowMode:!1})},"556c":function(t,e,r){var n=r("eef2");"string"===typeof n&&(n=[[t.i,n,""]]),n.locals&&(t.exports=n.locals);var o=r("499e").default;o("1209fd47",n,!0,{sourceMap:!1,shadowMode:!1})},"65d9":function(t,e,r){"use strict";
/**
  * vue-class-component v7.0.1
  * (c) 2015-present Evan You
  * @license MIT
  */function n(t){return t&&"object"===typeof t&&"default"in t?t["default"]:t}Object.defineProperty(e,"__esModule",{value:!0});var o=n(r("8bbf")),i="undefined"!==typeof Reflect&&Reflect.defineMetadata&&Reflect.getOwnMetadataKeys;function a(t,e){s(t,e),Object.getOwnPropertyNames(e.prototype).forEach((function(r){s(t.prototype,e.prototype,r)})),Object.getOwnPropertyNames(e).forEach((function(r){s(t,e,r)}))}function s(t,e,r){var n=r?Reflect.getOwnMetadataKeys(e,r):Reflect.getOwnMetadataKeys(e);n.forEach((function(n){var o=r?Reflect.getOwnMetadata(n,e,r):Reflect.getOwnMetadata(n,e);r?Reflect.defineMetadata(n,o,t,r):Reflect.defineMetadata(n,o,t)}))}var u={__proto__:[]},l=u instanceof Array;function c(t){return function(e,r,n){var o="function"===typeof e?e:e.constructor;o.__decorators__||(o.__decorators__=[]),"number"!==typeof n&&(n=void 0),o.__decorators__.push((function(e){return t(e,r,n)}))}}function d(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];return o.extend({mixins:t})}function f(t){var e=typeof t;return null==t||"object"!==e&&"function"!==e}function h(t,e){var r=e.prototype._init;e.prototype._init=function(){var e=this,r=Object.getOwnPropertyNames(t);if(t.$options.props)for(var n in t.$options.props)t.hasOwnProperty(n)||r.push(n);r.forEach((function(r){"_"!==r.charAt(0)&&Object.defineProperty(e,r,{get:function(){return t[r]},set:function(e){t[r]=e},configurable:!0})}))};var n=new e;e.prototype._init=r;var o={};return Object.keys(n).forEach((function(t){void 0!==n[t]&&(o[t]=n[t])})),o}var p=["data","beforeCreate","created","beforeMount","mounted","beforeDestroy","destroyed","beforeUpdate","updated","activated","deactivated","render","errorCaptured","serverPrefetch"];function y(t,e){void 0===e&&(e={}),e.name=e.name||t._componentTag||t.name;var r=t.prototype;Object.getOwnPropertyNames(r).forEach((function(t){if("constructor"!==t)if(p.indexOf(t)>-1)e[t]=r[t];else{var n=Object.getOwnPropertyDescriptor(r,t);void 0!==n.value?"function"===typeof n.value?(e.methods||(e.methods={}))[t]=n.value:(e.mixins||(e.mixins=[])).push({data:function(){var e;return e={},e[t]=n.value,e}}):(n.get||n.set)&&((e.computed||(e.computed={}))[t]={get:n.get,set:n.set})}})),(e.mixins||(e.mixins=[])).push({data:function(){return h(this,t)}});var n=t.__decorators__;n&&(n.forEach((function(t){return t(e)})),delete t.__decorators__);var s=Object.getPrototypeOf(t.prototype),u=s instanceof o?s.constructor:o,l=u.extend(e);return v(l,t,u),i&&a(l,t),l}function v(t,e,r){Object.getOwnPropertyNames(e).forEach((function(n){if("prototype"!==n){var o=Object.getOwnPropertyDescriptor(t,n);if(!o||o.configurable){var i=Object.getOwnPropertyDescriptor(e,n);if(!l){if("cid"===n)return;var a=Object.getOwnPropertyDescriptor(r,n);if(!f(i.value)&&a&&a.value===i.value)return}0,Object.defineProperty(t,n,i)}}}))}function m(t){return"function"===typeof t?y(t):function(e){return y(e,t)}}m.registerHooks=function(t){p.push.apply(p,t)},e.default=m,e.createDecorator=c,e.mixins=d},"7a57":function(t,e,r){var n=r("24fb");e=n(!1),e.push([t.i,".vue-slider{position:relative;-webkit-box-sizing:content-box;box-sizing:content-box;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;display:block;-webkit-tap-highlight-color:rgba(0,0,0,0)}.vue-slider-rail{position:relative;width:100%;height:100%;-webkit-transition-property:width,height,left,right,top,bottom;transition-property:width,height,left,right,top,bottom}.vue-slider-process{position:absolute;z-index:1}",""]),t.exports=e},8875:function(t,e,r){var n,o,i;(function(r,a){o=[],n=a,i="function"===typeof n?n.apply(e,o):n,void 0===i||(t.exports=i)})("undefined"!==typeof self&&self,(function(){function t(){var e=Object.getOwnPropertyDescriptor(document,"currentScript");if(!e&&"currentScript"in document&&document.currentScript)return document.currentScript;if(e&&e.get!==t&&document.currentScript)return document.currentScript;try{throw new Error}catch(h){var r,n,o,i=/.*at [^(]*\((.*):(.+):(.+)\)$/gi,a=/@([^@]*):(\d+):(\d+)\s*$/gi,s=i.exec(h.stack)||a.exec(h.stack),u=s&&s[1]||!1,l=s&&s[2]||!1,c=document.location.href.replace(document.location.hash,""),d=document.getElementsByTagName("script");u===c&&(r=document.documentElement.outerHTML,n=new RegExp("(?:[^\\n]+?\\n){0,"+(l-2)+"}[^<]*<script>([\\d\\D]*?)<\\/script>[\\d\\D]*","i"),o=r.replace(n,"$1").trim());for(var f=0;f<d.length;f++){if("interactive"===d[f].readyState)return d[f];if(d[f].src===u)return d[f];if(u===c&&d[f].innerHTML&&d[f].innerHTML.trim()===o)return d[f]}return null}}return t}))},"8bbf":function(e,r){e.exports=t},eef2:function(t,e,r){var n=r("24fb");e=n(!1),e.push([t.i,".vue-slider-marks{position:relative;width:100%;height:100%}.vue-slider-mark{position:absolute;z-index:1}.vue-slider-ltr .vue-slider-mark,.vue-slider-rtl .vue-slider-mark{width:0;height:100%;top:50%}.vue-slider-ltr .vue-slider-mark-step,.vue-slider-rtl .vue-slider-mark-step{top:0}.vue-slider-ltr .vue-slider-mark-label,.vue-slider-rtl .vue-slider-mark-label{top:100%;margin-top:10px}.vue-slider-ltr .vue-slider-mark{-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}.vue-slider-ltr .vue-slider-mark-step{left:0}.vue-slider-ltr .vue-slider-mark-label{left:50%;-webkit-transform:translateX(-50%);transform:translateX(-50%)}.vue-slider-rtl .vue-slider-mark{-webkit-transform:translate(50%,-50%);transform:translate(50%,-50%)}.vue-slider-rtl .vue-slider-mark-step{right:0}.vue-slider-rtl .vue-slider-mark-label{right:50%;-webkit-transform:translateX(50%);transform:translateX(50%)}.vue-slider-btt .vue-slider-mark,.vue-slider-ttb .vue-slider-mark{width:100%;height:0;left:50%}.vue-slider-btt .vue-slider-mark-step,.vue-slider-ttb .vue-slider-mark-step{left:0}.vue-slider-btt .vue-slider-mark-label,.vue-slider-ttb .vue-slider-mark-label{left:100%;margin-left:10px}.vue-slider-btt .vue-slider-mark{-webkit-transform:translate(-50%,50%);transform:translate(-50%,50%)}.vue-slider-btt .vue-slider-mark-step{top:0}.vue-slider-btt .vue-slider-mark-label{top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%)}.vue-slider-ttb .vue-slider-mark{-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}.vue-slider-ttb .vue-slider-mark-step{bottom:0}.vue-slider-ttb .vue-slider-mark-label{bottom:50%;-webkit-transform:translateY(50%);transform:translateY(50%)}.vue-slider-mark-label,.vue-slider-mark-step{position:absolute}",""]),t.exports=e},fb15:function(t,e,r){"use strict";if(r.r(e),r.d(e,"ERROR_TYPE",(function(){return J})),r.d(e,"VueSliderMark",(function(){return U})),r.d(e,"VueSliderDot",(function(){return j})),"undefined"!==typeof window){var n=window.document.currentScript,o=r("8875");n=o(),"currentScript"in document||Object.defineProperty(document,"currentScript",{get:o});var i=n&&n.src.match(/(.+\/)[^/]+\.js(\?.*)?$/);i&&(r.p=i[1])}var a=r("2638"),s=r.n(a);function u(t,e,r,n){var o,i=arguments.length,a=i<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"===typeof Reflect&&"function"===typeof Reflect.decorate)a=Reflect.decorate(t,e,r,n);else for(var s=t.length-1;s>=0;s--)(o=t[s])&&(a=(i<3?o(a):i>3?o(e,r,a):o(e,r))||a);return i>3&&a&&Object.defineProperty(e,r,a),a}var l=r("8bbf"),c=r.n(l),d=r("65d9"),f=r.n(d);function h(t,e){return void 0===e&&(e={}),Object(d["createDecorator"])((function(r,n){(r.props||(r.props={}))[n]=e,r.model={prop:n,event:t||n}}))}function p(t){return void 0===t&&(t={}),Object(d["createDecorator"])((function(e,r){(e.props||(e.props={}))[r]=t}))}function y(t,e){void 0===e&&(e={});var r=e.deep,n=void 0!==r&&r,o=e.immediate,i=void 0!==o&&o;return Object(d["createDecorator"])((function(e,r){"object"!==typeof e.watch&&(e.watch=Object.create(null));var o=e.watch;"object"!==typeof o[t]||Array.isArray(o[t])?"undefined"===typeof o[t]&&(o[t]=[]):o[t]=[o[t]],o[t].push({handler:r,deep:n,immediate:i})}))}r("4ed8");function v(t){return v="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"===typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},v(t)}function m(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function b(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function g(t,e,r){return e&&b(t.prototype,e),r&&b(t,r),t}function k(t,e){if("function"!==typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&O(t,e)}function O(t,e){return O=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t},O(t,e)}function x(t){var e=P();return function(){var r,n=D(t);if(e){var o=D(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return w(this,r)}}function w(t,e){return!e||"object"!==v(e)&&"function"!==typeof e?S(t):e}function S(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function P(){if("undefined"===typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"===typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(t){return!1}}function D(t){return D=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)},D(t)}var R=function(){var t=function(t){k(r,t);var e=x(r);function r(){return m(this,r),e.apply(this,arguments)}return g(r,[{key:"dragStart",value:function(t){if(this.disabled)return!1;this.$emit("drag-start")}},{key:"render",value:function(){var t=arguments[0];return t("div",{ref:"dot",class:this.dotClasses,attrs:{"aria-valuetext":"number"===typeof this.tooltipValue?this.tooltipValue.toString():this.tooltipValue},on:{mousedown:this.dragStart,touchstart:this.dragStart}},[this.$slots.dot||t("div",{class:this.handleClasses,style:this.dotStyle}),"none"!==this.tooltip?t("div",{class:this.tooltipClasses},[this.$slots.tooltip||t("div",{class:this.tooltipInnerClasses,style:this.tooltipStyle},[t("span",{class:"vue-slider-dot-tooltip-text"},[this.tooltipValue])])]):null])}},{key:"dotClasses",get:function(){return["vue-slider-dot",{"vue-slider-dot-hover":"hover"===this.tooltip||"active"===this.tooltip,"vue-slider-dot-disabled":this.disabled,"vue-slider-dot-focus":this.focus}]}},{key:"handleClasses",get:function(){return["vue-slider-dot-handle",{"vue-slider-dot-handle-disabled":this.disabled,"vue-slider-dot-handle-focus":this.focus}]}},{key:"tooltipClasses",get:function(){return["vue-slider-dot-tooltip",["vue-slider-dot-tooltip-".concat(this.tooltipPlacement)],{"vue-slider-dot-tooltip-show":this.showTooltip}]}},{key:"tooltipInnerClasses",get:function(){return["vue-slider-dot-tooltip-inner",["vue-slider-dot-tooltip-inner-".concat(this.tooltipPlacement)],{"vue-slider-dot-tooltip-inner-disabled":this.disabled,"vue-slider-dot-tooltip-inner-focus":this.focus}]}},{key:"showTooltip",get:function(){switch(this.tooltip){case"always":return!0;case"none":return!1;case"focus":case"active":return!!this.focus;default:return!1}}},{key:"tooltipValue",get:function(){return this.tooltipFormatter?"string"===typeof this.tooltipFormatter?this.tooltipFormatter.replace(/\{value\}/,String(this.value)):this.tooltipFormatter(this.value):this.value}}]),r}(c.a);return u([p({default:0})],t.prototype,"value",void 0),u([p()],t.prototype,"tooltip",void 0),u([p()],t.prototype,"dotStyle",void 0),u([p()],t.prototype,"tooltipStyle",void 0),u([p({type:String,validator:function(t){return["top","right","bottom","left"].indexOf(t)>-1},required:!0})],t.prototype,"tooltipPlacement",void 0),u([p({type:[String,Function]})],t.prototype,"tooltipFormatter",void 0),u([p({type:Boolean,default:!1})],t.prototype,"focus",void 0),u([p({default:!1})],t.prototype,"disabled",void 0),t=u([f()({name:"VueSliderDot"})],t),t}(),j=R;r("556c");function E(t){return E="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"===typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},E(t)}function A(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function V(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function M(t,e,r){return e&&V(t.prototype,e),r&&V(t,r),t}function _(t,e){if("function"!==typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&C(t,e)}function C(t,e){return C=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t},C(t,e)}function I(t){var e=B();return function(){var r,n=N(t);if(e){var o=N(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return L(this,r)}}function L(t,e){return!e||"object"!==E(e)&&"function"!==typeof e?T(t):e}function T(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function B(){if("undefined"===typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"===typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(t){return!1}}function N(t){return N=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)},N(t)}var z,H=function(){var t=function(t){_(r,t);var e=I(r);function r(){return A(this,r),e.apply(this,arguments)}return M(r,[{key:"labelClickHandle",value:function(t){t.stopPropagation(),this.$emit("pressLabel",this.mark.pos)}},{key:"render",value:function(){var t=arguments[0],e=this.mark;return t("div",{class:this.marksClasses},[this.$slots.step||t("div",{class:this.stepClasses,style:[this.stepStyle||{},e.style||{},e.active&&this.stepActiveStyle||{},e.active&&e.activeStyle||{}]}),this.hideLabel?null:this.$slots.label||t("div",{class:this.labelClasses,style:[this.labelStyle||{},e.labelStyle||{},e.active&&this.labelActiveStyle||{},e.active&&e.labelActiveStyle||{}],on:{click:this.labelClickHandle}},[e.label])])}},{key:"marksClasses",get:function(){return["vue-slider-mark",{"vue-slider-mark-active":this.mark.active}]}},{key:"stepClasses",get:function(){return["vue-slider-mark-step",{"vue-slider-mark-step-active":this.mark.active}]}},{key:"labelClasses",get:function(){return["vue-slider-mark-label",{"vue-slider-mark-label-active":this.mark.active}]}}]),r}(c.a);return u([p({required:!0})],t.prototype,"mark",void 0),u([p(Boolean)],t.prototype,"hideLabel",void 0),u([p()],t.prototype,"stepStyle",void 0),u([p()],t.prototype,"stepActiveStyle",void 0),u([p()],t.prototype,"labelStyle",void 0),u([p()],t.prototype,"labelActiveStyle",void 0),t=u([f()({name:"VueSlideMark"})],t),t}(),U=H,F=function(t){return"number"===typeof t?"".concat(t,"px"):t},$=function(t){var e=document.documentElement,r=document.body,n=t.getBoundingClientRect(),o={y:n.top+(window.pageYOffset||e.scrollTop)-(e.clientTop||r.clientTop||0),x:n.left+(window.pageXOffset||e.scrollLeft)-(e.clientLeft||r.clientLeft||0)};return o},W=function(t,e,r){var n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,o="targetTouches"in t?t.targetTouches[0]:t,i=$(e),a={x:o.pageX-i.x,y:o.pageY-i.y};return{x:r?e.offsetWidth*n-a.x:a.x,y:r?e.offsetHeight*n-a.y:a.y}};(function(t){t[t["PAGE_UP"]=33]="PAGE_UP",t[t["PAGE_DOWN"]=34]="PAGE_DOWN",t[t["END"]=35]="END",t[t["HOME"]=36]="HOME",t[t["LEFT"]=37]="LEFT",t[t["UP"]=38]="UP",t[t["RIGHT"]=39]="RIGHT",t[t["DOWN"]=40]="DOWN"})(z||(z={}));var G=function(t,e){if(e.hook){var r=e.hook(t);if("function"===typeof r)return r;if(!r)return null}switch(t.keyCode){case z.UP:return function(t){return"ttb"===e.direction?t-1:t+1};case z.RIGHT:return function(t){return"rtl"===e.direction?t-1:t+1};case z.DOWN:return function(t){return"ttb"===e.direction?t+1:t-1};case z.LEFT:return function(t){return"rtl"===e.direction?t+1:t-1};case z.END:return function(){return e.max};case z.HOME:return function(){return e.min};case z.PAGE_UP:return function(t){return t+10};case z.PAGE_DOWN:return function(t){return t-10};default:return null}};function X(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function q(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function K(t,e,r){return e&&q(t.prototype,e),r&&q(t,r),t}var Y,J,Q=function(){function t(e){X(this,t),this.num=e}return K(t,[{key:"decimal",value:function(t,e){var r=this.num,n=this.getDecimalLen(r),o=this.getDecimalLen(t),i=0;switch(e){case"+":i=this.getExponent(n,o),this.num=(this.safeRoundUp(r,i)+this.safeRoundUp(t,i))/i;break;case"-":i=this.getExponent(n,o),this.num=(this.safeRoundUp(r,i)-this.safeRoundUp(t,i))/i;break;case"*":this.num=this.safeRoundUp(this.safeRoundUp(r,this.getExponent(n)),this.safeRoundUp(t,this.getExponent(o)))/this.getExponent(n+o);break;case"/":i=this.getExponent(n,o),this.num=this.safeRoundUp(r,i)/this.safeRoundUp(t,i);break;case"%":i=this.getExponent(n,o),this.num=this.safeRoundUp(r,i)%this.safeRoundUp(t,i)/i;break}return this}},{key:"plus",value:function(t){return this.decimal(t,"+")}},{key:"minus",value:function(t){return this.decimal(t,"-")}},{key:"multiply",value:function(t){return this.decimal(t,"*")}},{key:"divide",value:function(t){return this.decimal(t,"/")}},{key:"remainder",value:function(t){return this.decimal(t,"%")}},{key:"toNumber",value:function(){return this.num}},{key:"getDecimalLen",value:function(t){var e="".concat(t).split("e");return("".concat(e[0]).split(".")[1]||"").length-(e[1]?+e[1]:0)}},{key:"getExponent",value:function(t,e){return Math.pow(10,void 0!==e?Math.max(t,e):t)}},{key:"safeRoundUp",value:function(t,e){return Math.round(t*e)}}]),t}();function Z(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)}return r}function tt(t){for(var e=1;e<arguments.length;e++){var r=null!=arguments[e]?arguments[e]:{};e%2?Z(Object(r),!0).forEach((function(e){pt(t,e,r[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(r)):Z(Object(r)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(r,e))}))}return t}function et(t,e){return ot(t)||nt(t,e)||st(t,e)||rt()}function rt(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function nt(t,e){if("undefined"!==typeof Symbol&&Symbol.iterator in Object(t)){var r=[],n=!0,o=!1,i=void 0;try{for(var a,s=t[Symbol.iterator]();!(n=(a=s.next()).done);n=!0)if(r.push(a.value),e&&r.length===e)break}catch(u){o=!0,i=u}finally{try{n||null==s["return"]||s["return"]()}finally{if(o)throw i}}return r}}function ot(t){if(Array.isArray(t))return t}function it(t){return lt(t)||ut(t)||st(t)||at()}function at(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function st(t,e){if(t){if("string"===typeof t)return ct(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);return"Object"===r&&t.constructor&&(r=t.constructor.name),"Map"===r||"Set"===r?Array.from(t):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?ct(t,e):void 0}}function ut(t){if("undefined"!==typeof Symbol&&Symbol.iterator in Object(t))return Array.from(t)}function lt(t){if(Array.isArray(t))return ct(t)}function ct(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}function dt(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function ft(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function ht(t,e,r){return e&&ft(t.prototype,e),r&&ft(t,r),t}function pt(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}(function(t){t[t["VALUE"]=1]="VALUE",t[t["INTERVAL"]=2]="INTERVAL",t[t["MIN"]=3]="MIN",t[t["MAX"]=4]="MAX",t[t["ORDER"]=5]="ORDER"})(J||(J={}));var yt=(Y={},pt(Y,J.VALUE,'The type of the "value" is illegal'),pt(Y,J.INTERVAL,'The prop "interval" is invalid, "(max - min)" must be divisible by "interval"'),pt(Y,J.MIN,'The "value" must be greater than or equal to the "min".'),pt(Y,J.MAX,'The "value" must be less than or equal to the "max".'),pt(Y,J.ORDER,'When "order" is false, the parameters "minRange", "maxRange", "fixed", "enabled" are invalid.'),Y),vt=function(){function t(e){dt(this,t),this.dotsPos=[],this.dotsValue=[],this.cacheRangeDir={},this.data=e.data,this.max=e.max,this.min=e.min,this.interval=e.interval,this.order=e.order,this.marks=e.marks,this.included=e.included,this.process=e.process,this.adsorb=e.adsorb,this.dotOptions=e.dotOptions,this.onError=e.onError,this.order?(this.minRange=e.minRange||0,this.maxRange=e.maxRange||0,this.enableCross=e.enableCross,this.fixed=e.fixed):((e.minRange||e.maxRange||!e.enableCross||e.fixed)&&this.emitError(J.ORDER),this.minRange=0,this.maxRange=0,this.enableCross=!0,this.fixed=!1),this.setValue(e.value)}return ht(t,[{key:"setValue",value:function(t){var e=this;this.setDotsValue(Array.isArray(t)?this.order?it(t).sort((function(t,r){return e.getIndexByValue(t)-e.getIndexByValue(r)})):it(t):[t],!0)}},{key:"setDotsValue",value:function(t,e){this.dotsValue=t,e&&this.syncDotsPos()}},{key:"setDotsPos",value:function(t){var e=this,r=this.order?it(t).sort((function(t,e){return t-e})):t;this.dotsPos=r,this.setDotsValue(r.map((function(t){return e.getValueByPos(t)})),this.adsorb)}},{key:"getValueByPos",value:function(t){var e=this.parsePos(t);if(this.included){var r=100;this.markList.forEach((function(n){var o=Math.abs(n.pos-t);o<r&&(r=o,e=n.value)}))}return e}},{key:"syncDotsPos",value:function(){var t=this;this.dotsPos=this.dotsValue.map((function(e){return t.parseValue(e)}))}},{key:"getRecentDot",value:function(t){var e=this,r=this.dotsPos.filter((function(t,r){return!(e.getDotOption(r)&&e.getDotOption(r).disabled)})).map((function(e){return Math.abs(e-t)}));return r.indexOf(Math.min.apply(Math,it(r)))}},{key:"getIndexByValue",value:function(t){return this.data?this.data.indexOf(t):new Q(+t).minus(this.min).divide(this.interval).toNumber()}},{key:"getValueByIndex",value:function(t){return t<0?t=0:t>this.total&&(t=this.total),this.data?this.data[t]:new Q(t).multiply(this.interval).plus(this.min).toNumber()}},{key:"setDotPos",value:function(t,e){t=this.getValidPos(t,e).pos;var r=t-this.dotsPos[e];if(r){var n=new Array(this.dotsPos.length);this.fixed?n=this.getFixedChangePosArr(r,e):this.minRange||this.maxRange?n=this.getLimitRangeChangePosArr(t,r,e):n[e]=r,this.setDotsPos(this.dotsPos.map((function(t,e){return t+(n[e]||0)})))}}},{key:"getFixedChangePosArr",value:function(t,e){var r=this;return this.dotsPos.forEach((function(n,o){if(o!==e){var i=r.getValidPos(n+t,o),a=i.pos,s=i.inRange;s||(t=Math.min(Math.abs(a-n),Math.abs(t))*(t<0?-1:1))}})),this.dotsPos.map((function(e){return t}))}},{key:"getLimitRangeChangePosArr",value:function(t,e,r){var n=this,o=[{index:r,changePos:e}],i=e;return[this.minRange,this.maxRange].forEach((function(a,s){if(!a)return!1;var u=0===s,l=e>0,c=0;c=u?l?1:-1:l?-1:1;var d=function(t,e){var r=Math.abs(t-e);return u?r<n.minRangeDir:r>n.maxRangeDir},f=r+c,h=n.dotsPos[f],p=t;while(n.isPos(h)&&d(h,p)){var y=n.getValidPos(h+i,f),v=y.pos;o.push({index:f,changePos:v-h}),f+=c,p=v,h=n.dotsPos[f]}})),this.dotsPos.map((function(t,e){var r=o.filter((function(t){return t.index===e}));return r.length?r[0].changePos:0}))}},{key:"isPos",value:function(t){return"number"===typeof t}},{key:"getValidPos",value:function(t,e){var r=this.valuePosRange[e],n=!0;return t<r[0]?(t=r[0],n=!1):t>r[1]&&(t=r[1],n=!1),{pos:t,inRange:n}}},{key:"parseValue",value:function(t){if(this.data)t=this.data.indexOf(t);else if("number"===typeof t||"string"===typeof t){if(t=+t,t<this.min)return this.emitError(J.MIN),0;if(t>this.max)return this.emitError(J.MAX),0;if("number"!==typeof t||t!==t)return this.emitError(J.VALUE),0;t=new Q(t).minus(this.min).divide(this.interval).toNumber()}var e=new Q(t).multiply(this.gap).toNumber();return e<0?0:e>100?100:e}},{key:"parsePos",value:function(t){var e=Math.round(t/this.gap);return this.getValueByIndex(e)}},{key:"isActiveByPos",value:function(t){return this.processArray.some((function(e){var r=et(e,2),n=r[0],o=r[1];return t>=n&&t<=o}))}},{key:"getValues",value:function(){if(this.data)return this.data;for(var t=[],e=0;e<=this.total;e++)t.push(new Q(e).multiply(this.interval).plus(this.min).toNumber());return t}},{key:"getRangeDir",value:function(t){return t?new Q(t).divide(new Q(this.data?this.data.length-1:this.max).minus(this.data?0:this.min).toNumber()).multiply(100).toNumber():100}},{key:"emitError",value:function(t){this.onError&&this.onError(t,yt[t])}},{key:"getDotOption",value:function(t){return Array.isArray(this.dotOptions)?this.dotOptions[t]:this.dotOptions}},{key:"getDotRange",value:function(t,e,r){if(!this.dotOptions)return r;var n=this.getDotOption(t);return n&&void 0!==n[e]?this.parseValue(n[e]):r}},{key:"markList",get:function(){var t=this;if(!this.marks)return[];var e=function(e,r){var n=t.parseValue(e);return tt({pos:n,value:e,label:e,active:t.isActiveByPos(n)},r)};return!0===this.marks?this.getValues().map((function(t){return e(t)})):"[object Object]"===Object.prototype.toString.call(this.marks)?Object.keys(this.marks).sort((function(t,e){return+t-+e})).map((function(r){var n=t.marks[r];return e(r,"string"!==typeof n?n:{label:n})})):Array.isArray(this.marks)?this.marks.map((function(t){return e(t)})):"function"===typeof this.marks?this.getValues().map((function(e){return{value:e,result:t.marks(e)}})).filter((function(t){var e=t.result;return!!e})).map((function(t){var r=t.value,n=t.result;return e(r,n)})):[]}},{key:"processArray",get:function(){if(this.process){if("function"===typeof this.process)return this.process(this.dotsPos);if(1===this.dotsPos.length)return[[0,this.dotsPos[0]]];if(this.dotsPos.length>1)return[[Math.min.apply(Math,it(this.dotsPos)),Math.max.apply(Math,it(this.dotsPos))]]}return[]}},{key:"total",get:function(){var t=0;return t=this.data?this.data.length-1:new Q(this.max).minus(this.min).divide(this.interval).toNumber(),t-Math.floor(t)!==0?(this.emitError(J.INTERVAL),0):t}},{key:"gap",get:function(){return 100/this.total}},{key:"minRangeDir",get:function(){return this.cacheRangeDir[this.minRange]?this.cacheRangeDir[this.minRange]:this.cacheRangeDir[this.minRange]=this.getRangeDir(this.minRange)}},{key:"maxRangeDir",get:function(){return this.cacheRangeDir[this.maxRange]?this.cacheRangeDir[this.maxRange]:this.cacheRangeDir[this.maxRange]=this.getRangeDir(this.maxRange)}},{key:"valuePosRange",get:function(){var t=this,e=this.dotsPos,r=[];return e.forEach((function(n,o){r.push([Math.max(t.minRange?t.minRangeDir*o:0,t.enableCross?0:e[o-1]||0,t.getDotRange(o,"min",0)),Math.min(t.minRange?100-t.minRangeDir*(e.length-1-o):100,t.enableCross?100:e[o+1]||100,t.getDotRange(o,"max",100))])})),r}},{key:"dotsIndex",get:function(){var t=this;return this.dotsValue.map((function(e){return t.getIndexByValue(e)}))}}]),t}();function mt(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function bt(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function gt(t,e,r){return e&&bt(t.prototype,e),r&&bt(t,r),t}var kt=function(){function t(e){mt(this,t),this.states=0,this.map=e}return gt(t,[{key:"add",value:function(t){this.states|=t}},{key:"delete",value:function(t){this.states&=~t}},{key:"toggle",value:function(t){this.has(t)?this.delete(t):this.add(t)}},{key:"has",value:function(t){return!!(this.states&t)}}]),t}();r("4abb");function Ot(t,e){return St(t)||wt(t,e)||At(t,e)||xt()}function xt(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function wt(t,e){if("undefined"!==typeof Symbol&&Symbol.iterator in Object(t)){var r=[],n=!0,o=!1,i=void 0;try{for(var a,s=t[Symbol.iterator]();!(n=(a=s.next()).done);n=!0)if(r.push(a.value),e&&r.length===e)break}catch(u){o=!0,i=u}finally{try{n||null==s["return"]||s["return"]()}finally{if(o)throw i}}return r}}function St(t){if(Array.isArray(t))return t}function Pt(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)}return r}function Dt(t){for(var e=1;e<arguments.length;e++){var r=null!=arguments[e]?arguments[e]:{};e%2?Pt(Object(r),!0).forEach((function(e){Rt(t,e,r[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(r)):Pt(Object(r)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(r,e))}))}return t}function Rt(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}function jt(t){return Mt(t)||Vt(t)||At(t)||Et()}function Et(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function At(t,e){if(t){if("string"===typeof t)return _t(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);return"Object"===r&&t.constructor&&(r=t.constructor.name),"Map"===r||"Set"===r?Array.from(t):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?_t(t,e):void 0}}function Vt(t){if("undefined"!==typeof Symbol&&Symbol.iterator in Object(t))return Array.from(t)}function Mt(t){if(Array.isArray(t))return _t(t)}function _t(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}function Ct(t){return Ct="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"===typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},Ct(t)}function It(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function Lt(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function Tt(t,e,r){return e&&Lt(t.prototype,e),r&&Lt(t,r),t}function Bt(t,e){if("function"!==typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&Nt(t,e)}function Nt(t,e){return Nt=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t},Nt(t,e)}function zt(t){var e=Ft();return function(){var r,n=$t(t);if(e){var o=$t(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return Ht(this,r)}}function Ht(t,e){return!e||"object"!==Ct(e)&&"function"!==typeof e?Ut(t):e}function Ut(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function Ft(){if("undefined"===typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"===typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(t){return!1}}function $t(t){return $t=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)},$t(t)}var Wt={None:0,Drag:2,Focus:4},Gt=4,Xt=function(){var t=function(t){Bt(r,t);var e=zt(r);function r(){var t;return It(this,r),t=e.apply(this,arguments),t.states=new kt(Wt),t.scale=1,t.focusDotIndex=0,t}return Tt(r,[{key:"isObjectData",value:function(t){return!!t&&"[object Object]"===Object.prototype.toString.call(t)}},{key:"isObjectArrayData",value:function(t){return!!t&&Array.isArray(t)&&t.length>0&&"object"===Ct(t[0])}},{key:"onValueChanged",value:function(){this.control&&!this.states.has(Wt.Drag)&&this.isNotSync&&(this.control.setValue(this.value),this.syncValueByPos())}},{key:"created",value:function(){this.initControl()}},{key:"mounted",value:function(){this.bindEvent()}},{key:"beforeDestroy",value:function(){this.unbindEvent()}},{key:"bindEvent",value:function(){document.addEventListener("touchmove",this.dragMove,{passive:!1}),document.addEventListener("touchend",this.dragEnd,{passive:!1}),document.addEventListener("mousedown",this.blurHandle),document.addEventListener("mousemove",this.dragMove,{passive:!1}),document.addEventListener("mouseup",this.dragEnd),document.addEventListener("mouseleave",this.dragEnd),document.addEventListener("keydown",this.keydownHandle)}},{key:"unbindEvent",value:function(){document.removeEventListener("touchmove",this.dragMove),document.removeEventListener("touchend",this.dragEnd),document.removeEventListener("mousedown",this.blurHandle),document.removeEventListener("mousemove",this.dragMove),document.removeEventListener("mouseup",this.dragEnd),document.removeEventListener("mouseleave",this.dragEnd),document.removeEventListener("keydown",this.keydownHandle)}},{key:"setScale",value:function(){var t=new Q(Math.floor(this.isHorizontal?this.$refs.rail.offsetWidth:this.$refs.rail.offsetHeight));void 0!==this.zoom&&t.multiply(this.zoom),t.divide(100),this.scale=t.toNumber()}},{key:"initControl",value:function(){var t=this;this.control=new vt({value:this.value,data:this.sliderData,enableCross:this.enableCross,fixed:this.fixed,max:this.max,min:this.min,interval:this.interval,minRange:this.minRange,maxRange:this.maxRange,order:this.order,marks:this.sliderMarks,included:this.included,process:this.process,adsorb:this.adsorb,dotOptions:this.dotOptions,onError:this.emitError}),this.syncValueByPos(),["data","enableCross","fixed","max","min","interval","minRange","maxRange","order","marks","process","adsorb","included","dotOptions"].forEach((function(e){t.$watch(e,(function(r){if("data"===e&&Array.isArray(t.control.data)&&Array.isArray(r)&&t.control.data.length===r.length&&r.every((function(e,r){return e===t.control.data[r]})))return!1;switch(e){case"data":case"dataLabel":case"dataValue":t.control.data=t.sliderData;break;case"mark":t.control.marks=t.sliderMarks;break;default:t.control[e]=r}["data","max","min","interval"].indexOf(e)>-1&&t.control.syncDotsPos()}))}))}},{key:"syncValueByPos",value:function(){var t=this.control.dotsValue;this.isDiff(t,Array.isArray(this.value)?this.value:[this.value])&&this.$emit("change",1===t.length?t[0]:jt(t),this.focusDotIndex)}},{key:"isDiff",value:function(t,e){return t.length!==e.length||t.some((function(t,r){return t!==e[r]}))}},{key:"emitError",value:function(t,e){this.silent||console.error("[VueSlider error]: ".concat(e)),this.$emit("error",t,e)}},{key:"dragStartOnProcess",value:function(t){if(this.dragOnClick){this.setScale();var e=this.getPosByEvent(t),r=this.control.getRecentDot(e);if(this.dots[r].disabled)return;this.dragStart(r),this.control.setDotPos(e,this.focusDotIndex),this.lazy||this.syncValueByPos()}}},{key:"dragStart",value:function(t){this.focusDotIndex=t,this.setScale(),this.states.add(Wt.Drag),this.states.add(Wt.Focus),this.$emit("drag-start",this.focusDotIndex)}},{key:"dragMove",value:function(t){if(!this.states.has(Wt.Drag))return!1;t.preventDefault();var e=this.getPosByEvent(t);this.isCrossDot(e),this.control.setDotPos(e,this.focusDotIndex),this.lazy||this.syncValueByPos();var r=this.control.dotsValue;this.$emit("dragging",1===r.length?r[0]:jt(r),this.focusDotIndex)}},{key:"isCrossDot",value:function(t){if(this.canSort){var e=this.focusDotIndex,r=t;if(r>this.dragRange[1]?(r=this.dragRange[1],this.focusDotIndex++):r<this.dragRange[0]&&(r=this.dragRange[0],this.focusDotIndex--),e!==this.focusDotIndex){var n=this.$refs["dot-".concat(this.focusDotIndex)];n&&n.$el&&n.$el.focus(),this.control.setDotPos(r,e)}}}},{key:"dragEnd",value:function(t){var e=this;if(!this.states.has(Wt.Drag))return!1;setTimeout((function(){e.lazy&&e.syncValueByPos(),e.included&&e.isNotSync?e.control.setValue(e.value):e.control.syncDotsPos(),e.states.delete(Wt.Drag),e.useKeyboard&&!("targetTouches"in t)||e.states.delete(Wt.Focus),e.$emit("drag-end",e.focusDotIndex)}))}},{key:"blurHandle",value:function(t){if(!this.states.has(Wt.Focus)||!this.$refs.container||this.$refs.container.contains(t.target))return!1;this.states.delete(Wt.Focus)}},{key:"clickHandle",value:function(t){if(!this.clickable||this.disabled)return!1;if(!this.states.has(Wt.Drag)){this.setScale();var e=this.getPosByEvent(t);this.setValueByPos(e)}}},{key:"focus",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;this.states.add(Wt.Focus),this.focusDotIndex=t}},{key:"blur",value:function(){this.states.delete(Wt.Focus)}},{key:"getValue",value:function(){var t=this.control.dotsValue;return 1===t.length?t[0]:t}},{key:"getIndex",value:function(){var t=this.control.dotsIndex;return 1===t.length?t[0]:t}},{key:"setValue",value:function(t){this.control.setValue(Array.isArray(t)?jt(t):[t]),this.syncValueByPos()}},{key:"setIndex",value:function(t){var e=this,r=Array.isArray(t)?t.map((function(t){return e.control.getValueByIndex(t)})):this.control.getValueByIndex(t);this.setValue(r)}},{key:"setValueByPos",value:function(t){var e=this,r=this.control.getRecentDot(t);if(this.disabled||this.dots[r].disabled)return!1;this.focusDotIndex=r,this.control.setDotPos(t,r),this.syncValueByPos(),this.useKeyboard&&this.states.add(Wt.Focus),setTimeout((function(){e.included&&e.isNotSync?e.control.setValue(e.value):e.control.syncDotsPos()}))}},{key:"keydownHandle",value:function(t){var e=this;if(!this.useKeyboard||!this.states.has(Wt.Focus))return!1;var r=this.included&&this.marks,n=G(t,{direction:this.direction,max:r?this.control.markList.length-1:this.control.total,min:0,hook:this.keydownHook});if(n){t.preventDefault();var o=-1,i=0;r?(this.control.markList.some((function(t,r){return t.value===e.control.dotsValue[e.focusDotIndex]&&(o=n(r),!0)})),o<0?o=0:o>this.control.markList.length-1&&(o=this.control.markList.length-1),i=this.control.markList[o].pos):(o=n(this.control.getIndexByValue(this.control.dotsValue[this.focusDotIndex])),i=this.control.parseValue(this.control.getValueByIndex(o))),this.isCrossDot(i),this.control.setDotPos(i,this.focusDotIndex),this.syncValueByPos()}}},{key:"getPosByEvent",value:function(t){return W(t,this.$refs.rail,this.isReverse,this.zoom)[this.isHorizontal?"x":"y"]/this.scale}},{key:"renderSlot",value:function(t,e,r,n){var o=this.$createElement,i=this.$scopedSlots[t];return i?n?i(e):o("template",{slot:t},[i(e)]):r}},{key:"render",value:function(){var t=this,e=arguments[0];return e("div",s()([{ref:"container",class:this.containerClasses,style:this.containerStyles,on:{click:this.clickHandle,touchstart:this.dragStartOnProcess,mousedown:this.dragStartOnProcess}},this.$attrs]),[e("div",{ref:"rail",class:"vue-slider-rail",style:this.railStyle},[this.processArray.map((function(r,n){return t.renderSlot("process",r,e("div",{class:"vue-slider-process",key:"process-".concat(n),style:r.style}),!0)})),this.sliderMarks?e("div",{class:"vue-slider-marks"},[this.control.markList.map((function(r,n){var o;return t.renderSlot("mark",r,e("vue-slider-mark",{key:"mark-".concat(n),attrs:{mark:r,hideLabel:t.hideLabel,stepStyle:t.stepStyle,stepActiveStyle:t.stepActiveStyle,labelStyle:t.labelStyle,labelActiveStyle:t.labelActiveStyle},style:(o={},Rt(o,t.isHorizontal?"height":"width","100%"),Rt(o,t.isHorizontal?"width":"height",t.tailSize),Rt(o,t.mainDirection,"".concat(r.pos,"%")),o),on:{pressLabel:function(e){return t.clickable&&t.setValueByPos(e)}}},[t.renderSlot("step",r,null),t.renderSlot("label",r,null)]),!0)}))]):null,this.dots.map((function(r,n){var o;return e("vue-slider-dot",{ref:"dot-".concat(n),key:"dot-".concat(n),attrs:Dt({value:r.value,disabled:r.disabled,focus:r.focus,"dot-style":[r.style,r.disabled?r.disabledStyle:null,r.focus?r.focusStyle:null],tooltip:r.tooltip||t.tooltip,"tooltip-style":[t.tooltipStyle,r.tooltipStyle,r.disabled?r.tooltipDisabledStyle:null,r.focus?r.tooltipFocusStyle:null],"tooltip-formatter":Array.isArray(t.sliderTooltipFormatter)?t.sliderTooltipFormatter[n]:t.sliderTooltipFormatter,"tooltip-placement":t.tooltipDirections[n],role:"slider","aria-valuenow":r.value,"aria-valuemin":t.min,"aria-valuemax":t.max,"aria-orientation":t.isHorizontal?"horizontal":"vertical",tabindex:"0"},t.dotAttrs),style:[t.dotBaseStyle,(o={},Rt(o,t.mainDirection,"".concat(r.pos,"%")),Rt(o,"transition","".concat(t.mainDirection," ").concat(t.animateTime,"s")),o)],on:{"drag-start":function(){return t.dragStart(n)}},nativeOn:{focus:function(){return!r.disabled&&t.focus(n)},blur:function(){return t.blur()}}},[t.renderSlot("dot",r,null),t.renderSlot("tooltip",r,null)])})),this.renderSlot("default",{value:this.getValue()},null,!0)])])}},{key:"tailSize",get:function(){return F((this.isHorizontal?this.height:this.width)||Gt)}},{key:"containerClasses",get:function(){return["vue-slider",["vue-slider-".concat(this.direction)],{"vue-slider-disabled":this.disabled}]}},{key:"containerStyles",get:function(){var t=Array.isArray(this.dotSize)?this.dotSize:[this.dotSize,this.dotSize],e=Ot(t,2),r=e[0],n=e[1],o=this.width?F(this.width):this.isHorizontal?"auto":F(Gt),i=this.height?F(this.height):this.isHorizontal?F(Gt):"auto";return{padding:this.contained?"".concat(n/2,"px ").concat(r/2,"px"):this.isHorizontal?"".concat(n/2,"px 0"):"0 ".concat(r/2,"px"),width:o,height:i}}},{key:"processArray",get:function(){var t=this;return this.control.processArray.map((function(e,r){var n,o=Ot(e,3),i=o[0],a=o[1],s=o[2];if(i>a){var u=[a,i];i=u[0],a=u[1]}var l=t.isHorizontal?"width":"height";return{start:i,end:a,index:r,style:Dt(Dt((n={},Rt(n,t.isHorizontal?"height":"width","100%"),Rt(n,t.isHorizontal?"top":"left",0),Rt(n,t.mainDirection,"".concat(i,"%")),Rt(n,l,"".concat(a-i,"%")),Rt(n,"transitionProperty","".concat(l,",").concat(t.mainDirection)),Rt(n,"transitionDuration","".concat(t.animateTime,"s")),n),t.processStyle),s)}}))}},{key:"dotBaseStyle",get:function(){var t,e=Array.isArray(this.dotSize)?this.dotSize:[this.dotSize,this.dotSize],r=Ot(e,2),n=r[0],o=r[1];return t=this.isHorizontal?Rt({transform:"translate(".concat(this.isReverse?"50%":"-50%",", -50%)"),"-WebkitTransform":"translate(".concat(this.isReverse?"50%":"-50%",", -50%)"),top:"50%"},"ltr"===this.direction?"left":"right","0"):Rt({transform:"translate(-50%, ".concat(this.isReverse?"50%":"-50%",")"),"-WebkitTransform":"translate(-50%, ".concat(this.isReverse?"50%":"-50%",")"),left:"50%"},"btt"===this.direction?"bottom":"top","0"),Dt({width:"".concat(n,"px"),height:"".concat(o,"px")},t)}},{key:"mainDirection",get:function(){switch(this.direction){case"ltr":return"left";case"rtl":return"right";case"btt":return"bottom";case"ttb":return"top"}}},{key:"isHorizontal",get:function(){return"ltr"===this.direction||"rtl"===this.direction}},{key:"isReverse",get:function(){return"rtl"===this.direction||"btt"===this.direction}},{key:"tooltipDirections",get:function(){var t=this.tooltipPlacement||(this.isHorizontal?"top":"left");return Array.isArray(t)?t:this.dots.map((function(){return t}))}},{key:"dots",get:function(){var t=this;return this.control.dotsPos.map((function(e,r){return Dt({pos:e,index:r,value:t.control.dotsValue[r],focus:t.states.has(Wt.Focus)&&t.focusDotIndex===r,disabled:t.disabled,style:t.dotStyle},(Array.isArray(t.dotOptions)?t.dotOptions[r]:t.dotOptions)||{})}))}},{key:"animateTime",get:function(){return this.states.has(Wt.Drag)?0:this.duration}},{key:"canSort",get:function(){return this.order&&!this.minRange&&!this.maxRange&&!this.fixed&&this.enableCross}},{key:"sliderData",get:function(){var t=this;return this.isObjectArrayData(this.data)?this.data.map((function(e){return e[t.dataValue]})):this.isObjectData(this.data)?Object.keys(this.data):this.data}},{key:"sliderMarks",get:function(){var t=this;return this.marks?this.marks:this.isObjectArrayData(this.data)?function(e){var r={label:e};return t.data.some((function(n){return n[t.dataValue]===e&&(r.label=n[t.dataLabel],!0)})),r}:this.isObjectData(this.data)?this.data:void 0}},{key:"sliderTooltipFormatter",get:function(){var t=this;if(this.tooltipFormatter)return this.tooltipFormatter;if(this.isObjectArrayData(this.data))return function(e){var r=""+e;return t.data.some((function(n){return n[t.dataValue]===e&&(r=n[t.dataLabel],!0)})),r};if(this.isObjectData(this.data)){var e=this.data;return function(t){return e[t]}}}},{key:"isNotSync",get:function(){var t=this.control.dotsValue;return Array.isArray(this.value)?this.value.length!==t.length||this.value.some((function(e,r){return e!==t[r]})):this.value!==t[0]}},{key:"dragRange",get:function(){var t=this.dots[this.focusDotIndex-1],e=this.dots[this.focusDotIndex+1];return[t?t.pos:-1/0,e?e.pos:1/0]}}]),r}(c.a);return u([h("change",{default:0})],t.prototype,"value",void 0),u([p({type:Boolean,default:!1})],t.prototype,"silent",void 0),u([p({default:"ltr",validator:function(t){return["ltr","rtl","ttb","btt"].indexOf(t)>-1}})],t.prototype,"direction",void 0),u([p({type:[Number,String]})],t.prototype,"width",void 0),u([p({type:[Number,String]})],t.prototype,"height",void 0),u([p({default:14})],t.prototype,"dotSize",void 0),u([p({default:!1})],t.prototype,"contained",void 0),u([p({type:Number,default:0})],t.prototype,"min",void 0),u([p({type:Number,default:100})],t.prototype,"max",void 0),u([p({type:Number,default:1})],t.prototype,"interval",void 0),u([p({type:Boolean,default:!1})],t.prototype,"disabled",void 0),u([p({type:Boolean,default:!0})],t.prototype,"clickable",void 0),u([p({type:Boolean,default:!1})],t.prototype,"dragOnClick",void 0),u([p({type:Number,default:.5})],t.prototype,"duration",void 0),u([p({type:[Object,Array]})],t.prototype,"data",void 0),u([p({type:String,default:"value"})],t.prototype,"dataValue",void 0),u([p({type:String,default:"label"})],t.prototype,"dataLabel",void 0),u([p({type:Boolean,default:!1})],t.prototype,"lazy",void 0),u([p({type:String,validator:function(t){return["none","always","focus","hover","active"].indexOf(t)>-1},default:"active"})],t.prototype,"tooltip",void 0),u([p({type:[String,Array],validator:function(t){return(Array.isArray(t)?t:[t]).every((function(t){return["top","right","bottom","left"].indexOf(t)>-1}))}})],t.prototype,"tooltipPlacement",void 0),u([p({type:[String,Array,Function]})],t.prototype,"tooltipFormatter",void 0),u([p({type:Boolean,default:!0})],t.prototype,"useKeyboard",void 0),u([p(Function)],t.prototype,"keydownHook",void 0),u([p({type:Boolean,default:!0})],t.prototype,"enableCross",void 0),u([p({type:Boolean,default:!1})],t.prototype,"fixed",void 0),u([p({type:Boolean,default:!0})],t.prototype,"order",void 0),u([p(Number)],t.prototype,"minRange",void 0),u([p(Number)],t.prototype,"maxRange",void 0),u([p({type:[Boolean,Object,Array,Function],default:!1})],t.prototype,"marks",void 0),u([p({type:[Boolean,Function],default:!0})],t.prototype,"process",void 0),u([p({type:[Number]})],t.prototype,"zoom",void 0),u([p(Boolean)],t.prototype,"included",void 0),u([p(Boolean)],t.prototype,"adsorb",void 0),u([p(Boolean)],t.prototype,"hideLabel",void 0),u([p()],t.prototype,"dotOptions",void 0),u([p()],t.prototype,"dotAttrs",void 0),u([p()],t.prototype,"railStyle",void 0),u([p()],t.prototype,"processStyle",void 0),u([p()],t.prototype,"dotStyle",void 0),u([p()],t.prototype,"tooltipStyle",void 0),u([p()],t.prototype,"stepStyle",void 0),u([p()],t.prototype,"stepActiveStyle",void 0),u([p()],t.prototype,"labelStyle",void 0),u([p()],t.prototype,"labelActiveStyle",void 0),u([y("value")],t.prototype,"onValueChanged",null),t=u([f()({name:"VueSlider",data:function(){return{control:null}},components:{VueSliderDot:j,VueSliderMark:U}})],t),t}(),qt=Xt;qt.VueSliderMark=U,qt.VueSliderDot=j;var Kt=qt;e["default"]=Kt}})["default"]}));
//# sourceMappingURL=vue-slider-component.umd.min.js.map

/***/ }),

/***/ 669:
/***/ (function(module) {

"use strict";
module.exports = jQuery;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	!function() {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
!function() {
"use strict";

// NAMESPACE OBJECT: ./node_modules/axios/lib/platform/common/utils.js
var common_utils_namespaceObject = {};
__webpack_require__.r(common_utils_namespaceObject);
__webpack_require__.d(common_utils_namespaceObject, {
  hasBrowserEnv: function() { return hasBrowserEnv; },
  hasStandardBrowserEnv: function() { return hasStandardBrowserEnv; },
  hasStandardBrowserWebWorkerEnv: function() { return hasStandardBrowserWebWorkerEnv; }
});

// EXTERNAL MODULE: ./node_modules/@vue/compat/dist/vue.esm-bundler.js
var vue_esm_bundler = __webpack_require__(878);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js??clonedRuleSet-3.use!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./node_modules/import-glob/index.js!./resources/scripts/frontend/App.vue?vue&type=template&id=444f8492

var _hoisted_1 = {
  class: "container"
};
var _hoisted_2 = {
  key: 0,
  class: "tw-flex tw-flex-col sm:tw-flex-row sm:tw-mx-0 tw-max-w-full"
};
var _hoisted_3 = {
  class: "flex items-center search-container mb-10"
};
var _hoisted_4 = {
  class: "tw-mb-5 search"
};
var _hoisted_5 = {
  class: "text-xl mb-2 font-bold dark:text-white text-align:center"
};
var _hoisted_6 = ["placeholder"];
var _hoisted_7 = {
  class: "filter-container"
};
var _hoisted_8 = {
  class: "checkbox-container"
};
var _hoisted_9 = {
  class: "tw-mb-3 filter-title"
};
var _hoisted_10 = {
  class: "tw-list-none tw-p-0 mb-7"
};
var _hoisted_11 = ["onUpdate:modelValue", "value"];
var _hoisted_12 = {
  class: "tw-ml-5"
};
var _hoisted_13 = {
  class: "dropdown-container"
};
var _hoisted_14 = {
  class: "tw-mb-3 filter-title"
};
var _hoisted_15 = ["onUpdate:modelValue"];
var _hoisted_16 = {
  disabled: "",
  selected: ""
};
var _hoisted_17 = ["value"];
var _hoisted_18 = (0,vue_esm_bundler.createElementVNode)("h1", {
  class: "text-4xl font-extrabold dark:text-white mb-8"
}, "Suggested Courses", -1);
var _hoisted_19 = {
  class: ""
};
var _hoisted_20 = {
  key: 0,
  class: "loader"
};
var _hoisted_21 = {
  key: 1
};
var _hoisted_22 = {
  class: "tw-flex tw-justify-between tw-mt-5"
};
var _hoisted_23 = ["value"];
var _hoisted_24 = (0,vue_esm_bundler.createStaticVNode)("<option value=\"3\">3</option><option value=\"6\">6</option><option value=\"12\">12</option><option value=\"24\">24</option><option value=\"48\">48</option><option value=\"96\">96</option>", 6);
var _hoisted_30 = [_hoisted_24];
function render(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_hits = (0,vue_esm_bundler.resolveComponent)("hits");
  var _component_pagination = (0,vue_esm_bundler.resolveComponent)("pagination");
  return (0,vue_esm_bundler.openBlock)(), (0,vue_esm_bundler.createElementBlock)("div", _hoisted_1, [$data.resultText && $data.isResult ? ((0,vue_esm_bundler.openBlock)(), (0,vue_esm_bundler.createElementBlock)("div", _hoisted_2, (0,vue_esm_bundler.toDisplayString)($data.resultText), 1)) : (0,vue_esm_bundler.createCommentVNode)("", true), (0,vue_esm_bundler.createElementVNode)("div", _hoisted_3, [(0,vue_esm_bundler.createElementVNode)("div", _hoisted_4, [(0,vue_esm_bundler.createElementVNode)("h4", _hoisted_5, (0,vue_esm_bundler.toDisplayString)(_ctx.$t('Search by keyword')), 1), (0,vue_esm_bundler.withDirectives)((0,vue_esm_bundler.createElementVNode)("input", {
    "onUpdate:modelValue": _cache[0] || (_cache[0] = function ($event) {
      return $data.searchString = $event;
    }),
    placeholder: _ctx.$t('Enter keyword'),
    class: "tw-w-full search-input",
    type: "text"
  }, null, 8, _hoisted_6), [[vue_esm_bundler.vModelText, $data.searchString]])])]), (0,vue_esm_bundler.createElementVNode)("div", _hoisted_7, [(0,vue_esm_bundler.createElementVNode)("div", _hoisted_8, [((0,vue_esm_bundler.openBlock)(true), (0,vue_esm_bundler.createElementBlock)(vue_esm_bundler.Fragment, null, (0,vue_esm_bundler.renderList)($data.filterFields, function (filterField, index) {
    return (0,vue_esm_bundler.openBlock)(), (0,vue_esm_bundler.createElementBlock)(vue_esm_bundler.Fragment, null, [['checkbox', 'radio'].includes(filterField.type) ? ((0,vue_esm_bundler.openBlock)(), (0,vue_esm_bundler.createElementBlock)("div", {
      key: 'checkbox-' + index,
      class: (0,vue_esm_bundler.normalizeClass)({
        'tw-col-span-3': filterField.type === 'multiselect'
      })
    }, [(0,vue_esm_bundler.createElementVNode)("h4", _hoisted_9, (0,vue_esm_bundler.toDisplayString)(filterField.title), 1), (0,vue_esm_bundler.createElementVNode)("ul", _hoisted_10, [((0,vue_esm_bundler.openBlock)(true), (0,vue_esm_bundler.createElementBlock)(vue_esm_bundler.Fragment, null, (0,vue_esm_bundler.renderList)(filterField.values, function (value, key) {
      return (0,vue_esm_bundler.openBlock)(), (0,vue_esm_bundler.createElementBlock)("li", {
        key: key,
        class: "tw-flex tw-items-center"
      }, [(0,vue_esm_bundler.withDirectives)((0,vue_esm_bundler.createElementVNode)("input", {
        "onUpdate:modelValue": function onUpdateModelValue($event) {
          return $data.filterValues[filterField.field] = $event;
        },
        value: key,
        type: "checkbox",
        onChange: _cache[1] || (_cache[1] = function ($event) {
          return $options.search();
        })
      }, null, 40, _hoisted_11), [[vue_esm_bundler.vModelCheckbox, $data.filterValues[filterField.field]]]), (0,vue_esm_bundler.createElementVNode)("span", _hoisted_12, (0,vue_esm_bundler.toDisplayString)(value), 1)]);
    }), 128))])], 2)) : (0,vue_esm_bundler.createCommentVNode)("", true)], 64);
  }), 256))]), (0,vue_esm_bundler.createElementVNode)("div", _hoisted_13, [((0,vue_esm_bundler.openBlock)(true), (0,vue_esm_bundler.createElementBlock)(vue_esm_bundler.Fragment, null, (0,vue_esm_bundler.renderList)($data.filterFields, function (filterField, index) {
    return (0,vue_esm_bundler.openBlock)(), (0,vue_esm_bundler.createElementBlock)(vue_esm_bundler.Fragment, null, [filterField.type === 'dropdown' ? ((0,vue_esm_bundler.openBlock)(), (0,vue_esm_bundler.createElementBlock)("div", {
      key: 'dropdown-' + index
    }, [(0,vue_esm_bundler.createElementVNode)("h4", _hoisted_14, (0,vue_esm_bundler.toDisplayString)(filterField.title), 1), (0,vue_esm_bundler.withDirectives)((0,vue_esm_bundler.createElementVNode)("select", {
      "onUpdate:modelValue": function onUpdateModelValue($event) {
        return $data.filterValues[filterField.field] = $event;
      },
      id: "dropdown-filters",
      class: "mb-7 bg-gray-50 border border-black-300 text-gray-900 text-sm focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500",
      placeholder: "asfsaf",
      onChange: _cache[2] || (_cache[2] = function ($event) {
        return $options.search();
      })
    }, [(0,vue_esm_bundler.createElementVNode)("option", _hoisted_16, "Choose a " + (0,vue_esm_bundler.toDisplayString)(filterField.title), 1), ((0,vue_esm_bundler.openBlock)(true), (0,vue_esm_bundler.createElementBlock)(vue_esm_bundler.Fragment, null, (0,vue_esm_bundler.renderList)(filterField.values, function (value, key) {
      return (0,vue_esm_bundler.openBlock)(), (0,vue_esm_bundler.createElementBlock)("option", {
        key: key,
        value: key,
        class: "dropdown-option"
      }, (0,vue_esm_bundler.toDisplayString)(value), 9, _hoisted_17);
    }), 128))], 40, _hoisted_15), [[vue_esm_bundler.vModelSelect, $data.filterValues[filterField.field]]])])) : (0,vue_esm_bundler.createCommentVNode)("", true)], 64);
  }), 256))])]), _hoisted_18, (0,vue_esm_bundler.createElementVNode)("div", _hoisted_19, [$data.loading ? ((0,vue_esm_bundler.openBlock)(), (0,vue_esm_bundler.createElementBlock)("div", _hoisted_20, (0,vue_esm_bundler.toDisplayString)(_ctx.$t('Loading...')), 1)) : (0,vue_esm_bundler.createCommentVNode)("", true), $data.meilisearchFail ? ((0,vue_esm_bundler.openBlock)(), (0,vue_esm_bundler.createElementBlock)("span", _hoisted_21, (0,vue_esm_bundler.toDisplayString)(_ctx.$t('There is a problem with search engine. Try using default wordpress search at top of the page...')), 1)) : ((0,vue_esm_bundler.openBlock)(), (0,vue_esm_bundler.createBlock)(_component_hits, {
    key: 2,
    "display-fields": $data.displayFields,
    hits: $data.hits
  }, null, 8, ["display-fields", "hits"]))]), (0,vue_esm_bundler.createElementVNode)("div", _hoisted_22, [(0,vue_esm_bundler.createElementVNode)("select", {
    value: $data.limit,
    class: "tw-w-20-important",
    onInput: _cache[3] || (_cache[3] = function ($event) {
      return $data.limit = Number($event.target.value);
    })
  }, _hoisted_30, 40, _hoisted_23), (0,vue_esm_bundler.createVNode)(_component_pagination, {
    limit: $data.limit,
    "nb-hits": $data.nbHits,
    offset: $data.offset,
    onUpdateOffset: _cache[4] || (_cache[4] = function ($event) {
      return $options.updateOffset($event);
    })
  }, null, 8, ["limit", "nb-hits", "offset"])])]);
}
;// CONCATENATED MODULE: ./resources/scripts/frontend/App.vue?vue&type=template&id=444f8492

// EXTERNAL MODULE: ./node_modules/vue-slider-component/dist/vue-slider-component.umd.min.js
var vue_slider_component_umd_min = __webpack_require__(99);
var vue_slider_component_umd_min_default = /*#__PURE__*/__webpack_require__.n(vue_slider_component_umd_min);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js??clonedRuleSet-3.use!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./node_modules/import-glob/index.js!./resources/scripts/frontend/components/DatePicker.vue?vue&type=template&id=6d242049&scoped=true

var _withScopeId = function _withScopeId(n) {
  return _pushScopeId("data-v-6d242049"), n = n(), _popScopeId(), n;
};
var DatePickervue_type_template_id_6d242049_scoped_true_hoisted_1 = {
  class: "tw-flex tw-flex-row"
};
var DatePickervue_type_template_id_6d242049_scoped_true_hoisted_2 = ["value"];
var DatePickervue_type_template_id_6d242049_scoped_true_hoisted_3 = ["value"];
function DatePickervue_type_template_id_6d242049_scoped_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_v_date_picker = (0,vue_esm_bundler.resolveComponent)("v-date-picker");
  return (0,vue_esm_bundler.openBlock)(), (0,vue_esm_bundler.createBlock)(_component_v_date_picker, {
    onInput: _cache[0] || (_cache[0] = function ($event) {
      return $options.dateChanged($event);
    }),
    popover: {
      visibility: 'click'
    },
    masks: {
      input: 'DD.MM.YYYY'
    },
    modelValue: $data.date,
    "onUpdate:modelValue": _cache[1] || (_cache[1] = function ($event) {
      return $data.date = $event;
    }),
    "is-range": ""
  }, {
    default: (0,vue_esm_bundler.withCtx)(function (_ref) {
      var inputValue = _ref.inputValue,
        inputEvents = _ref.inputEvents;
      return [(0,vue_esm_bundler.createElementVNode)("div", DatePickervue_type_template_id_6d242049_scoped_true_hoisted_1, [(0,vue_esm_bundler.createElementVNode)("input", (0,vue_esm_bundler.mergeProps)({
        value: inputValue.start
      }, (0,vue_esm_bundler.toHandlers)(inputEvents.start, true), {
        placeholder: "From",
        type: "text"
      }), null, 16, DatePickervue_type_template_id_6d242049_scoped_true_hoisted_2), (0,vue_esm_bundler.createElementVNode)("input", (0,vue_esm_bundler.mergeProps)({
        value: inputValue.end
      }, (0,vue_esm_bundler.toHandlers)(inputEvents.end, true), {
        placeholder: "To",
        type: "text"
      }), null, 16, DatePickervue_type_template_id_6d242049_scoped_true_hoisted_3)])];
    }),
    _: 1
  }, 8, ["masks", "modelValue"]);
}
;// CONCATENATED MODULE: ./resources/scripts/frontend/components/DatePicker.vue?vue&type=template&id=6d242049&scoped=true

// EXTERNAL MODULE: ./node_modules/v-calendar/lib/v-calendar.umd.min.js
var v_calendar_umd_min = __webpack_require__(310);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js??clonedRuleSet-3.use!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./node_modules/import-glob/index.js!./resources/scripts/frontend/components/DatePicker.vue?vue&type=script&lang=js

/* harmony default export */ var DatePickervue_type_script_lang_js = ({
  name: "DatePicker",
  data: function data() {
    return {
      date: {
        start: null,
        end: null
      },
      masks: {
        input: 'DD.MM.YYYY'
      }
    };
  },
  components: {
    VDatePicker: v_calendar_umd_min.DatePicker
  },
  methods: {
    dateChanged: function dateChanged(date) {
      this.$emit('input', date);
    }
  }
});
;// CONCATENATED MODULE: ./resources/scripts/frontend/components/DatePicker.vue?vue&type=script&lang=js
 
// EXTERNAL MODULE: ./node_modules/vue-loader/dist/exportHelper.js
var exportHelper = __webpack_require__(951);
;// CONCATENATED MODULE: ./resources/scripts/frontend/components/DatePicker.vue




;


const __exports__ = /*#__PURE__*/(0,exportHelper/* default */.A)(DatePickervue_type_script_lang_js, [['render',DatePickervue_type_template_id_6d242049_scoped_true_render],['__scopeId',"data-v-6d242049"]])

/* harmony default export */ var DatePicker = (__exports__);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js??clonedRuleSet-3.use!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./node_modules/import-glob/index.js!./resources/scripts/frontend/components/Pagination.vue?vue&type=template&id=9dfc2760

var Paginationvue_type_template_id_9dfc2760_hoisted_1 = {
  class: "tw-px-4 tw-py-3 tw-flex tw-items-center tw-justify-between tw-border-t sm:tw-px-6"
};
var Paginationvue_type_template_id_9dfc2760_hoisted_2 = {
  class: "tw-flex-1 tw-flex tw-justify-between sm:tw-hidden"
};
var Paginationvue_type_template_id_9dfc2760_hoisted_3 = {
  class: "tw-relative tw-inline-flex tw-items-center tw-px-4 tw-py-2 tw-border tw-border-solid tw-text-sm tw-font-medium",
  href: "#"
};
var Paginationvue_type_template_id_9dfc2760_hoisted_4 = {
  class: "tw-ml-3 tw-relative tw-inline-flex tw-items-center tw-px-4 tw-py-2 tw-border tw-border-solid tw-text-sm tw-font-medium",
  href: "#"
};
var Paginationvue_type_template_id_9dfc2760_hoisted_5 = {
  class: "tw-hidden sm:tw-flex-1 sm:tw-flex sm:tw-items-center sm:tw-justify-between"
};
var Paginationvue_type_template_id_9dfc2760_hoisted_6 = {
  class: "tw-text-sm tw-mr-5"
};
var Paginationvue_type_template_id_9dfc2760_hoisted_7 = {
  class: "tw-font-medium"
};
var Paginationvue_type_template_id_9dfc2760_hoisted_8 = {
  class: "tw-font-medium"
};
var Paginationvue_type_template_id_9dfc2760_hoisted_9 = {
  class: "tw-font-medium"
};
var Paginationvue_type_template_id_9dfc2760_hoisted_10 = {
  "aria-label": "Pagination",
  class: "tw-relative z-0 tw-inline-flex tw-shadow-sm tw--space-x-px"
};
var Paginationvue_type_template_id_9dfc2760_hoisted_11 = ["disabled"];
var Paginationvue_type_template_id_9dfc2760_hoisted_12 = (0,vue_esm_bundler.createElementVNode)("span", {
  class: "tw-sr-only"
}, "Previous", -1);
var Paginationvue_type_template_id_9dfc2760_hoisted_13 = (0,vue_esm_bundler.createElementVNode)("svg", {
  "aria-hidden": "true",
  class: "tw-h-5 tw-w-5",
  fill: "currentColor",
  viewBox: "0 0 20 20",
  xmlns: "http://www.w3.org/2000/svg"
}, [(0,vue_esm_bundler.createElementVNode)("path", {
  "clip-rule": "evenodd",
  d: "M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z",
  "fill-rule": "evenodd"
})], -1);
var Paginationvue_type_template_id_9dfc2760_hoisted_14 = [Paginationvue_type_template_id_9dfc2760_hoisted_12, Paginationvue_type_template_id_9dfc2760_hoisted_13];
var Paginationvue_type_template_id_9dfc2760_hoisted_15 = {
  class: "current-page-button tw-relative tw-inline-flex tw-items-center tw-px-4 tw-py-2 tw-border tw-border-solid tw-text-sm tw-font-medium"
};
var Paginationvue_type_template_id_9dfc2760_hoisted_16 = ["disabled"];
var Paginationvue_type_template_id_9dfc2760_hoisted_17 = (0,vue_esm_bundler.createElementVNode)("span", {
  class: "tw-sr-only"
}, "Next", -1);
var Paginationvue_type_template_id_9dfc2760_hoisted_18 = (0,vue_esm_bundler.createElementVNode)("svg", {
  "aria-hidden": "true",
  class: "h-5 w-5",
  fill: "currentColor",
  viewBox: "0 0 20 20",
  xmlns: "http://www.w3.org/2000/svg"
}, [(0,vue_esm_bundler.createElementVNode)("path", {
  "clip-rule": "evenodd",
  d: "M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z",
  "fill-rule": "evenodd"
})], -1);
var Paginationvue_type_template_id_9dfc2760_hoisted_19 = [Paginationvue_type_template_id_9dfc2760_hoisted_17, Paginationvue_type_template_id_9dfc2760_hoisted_18];
function Paginationvue_type_template_id_9dfc2760_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,vue_esm_bundler.openBlock)(), (0,vue_esm_bundler.createElementBlock)("div", Paginationvue_type_template_id_9dfc2760_hoisted_1, [(0,vue_esm_bundler.createElementVNode)("div", Paginationvue_type_template_id_9dfc2760_hoisted_2, [(0,vue_esm_bundler.createElementVNode)("a", Paginationvue_type_template_id_9dfc2760_hoisted_3, (0,vue_esm_bundler.toDisplayString)(_ctx.$t('Previous')), 1), (0,vue_esm_bundler.createElementVNode)("a", Paginationvue_type_template_id_9dfc2760_hoisted_4, (0,vue_esm_bundler.toDisplayString)(_ctx.$t('Next')), 1)]), (0,vue_esm_bundler.createElementVNode)("div", Paginationvue_type_template_id_9dfc2760_hoisted_5, [(0,vue_esm_bundler.createElementVNode)("div", null, [(0,vue_esm_bundler.createElementVNode)("p", Paginationvue_type_template_id_9dfc2760_hoisted_6, [(0,vue_esm_bundler.createTextVNode)((0,vue_esm_bundler.toDisplayString)(_ctx.$t('Showing')) + " ", 1), (0,vue_esm_bundler.createElementVNode)("span", Paginationvue_type_template_id_9dfc2760_hoisted_7, (0,vue_esm_bundler.toDisplayString)($props.offset + 1), 1), (0,vue_esm_bundler.createTextVNode)(" " + (0,vue_esm_bundler.toDisplayString)(_ctx.$t('to')) + " ", 1), (0,vue_esm_bundler.createElementVNode)("span", Paginationvue_type_template_id_9dfc2760_hoisted_8, (0,vue_esm_bundler.toDisplayString)($options.to), 1), (0,vue_esm_bundler.createTextVNode)(" " + (0,vue_esm_bundler.toDisplayString)(_ctx.$t('of')) + " ", 1), (0,vue_esm_bundler.createElementVNode)("span", Paginationvue_type_template_id_9dfc2760_hoisted_9, (0,vue_esm_bundler.toDisplayString)($props.nbHits), 1), (0,vue_esm_bundler.createTextVNode)(" " + (0,vue_esm_bundler.toDisplayString)(_ctx.$t('results')), 1)])]), (0,vue_esm_bundler.createElementVNode)("div", null, [(0,vue_esm_bundler.createElementVNode)("nav", Paginationvue_type_template_id_9dfc2760_hoisted_10, [$props.nbHits > $props.limit * 3 ? ((0,vue_esm_bundler.openBlock)(), (0,vue_esm_bundler.createElementBlock)("button", {
    key: 0,
    disabled: $options.showingFirstPage,
    class: "tw-relative tw-inline-flex tw-items-center tw-px-2 tw-py-2 tw-border tw-border-solid tw-text-sm tw-font-medium",
    onClick: _cache[0] || (_cache[0] = function ($event) {
      return $options.updateOffset($options.currentPage - 1);
    })
  }, Paginationvue_type_template_id_9dfc2760_hoisted_14, 8, Paginationvue_type_template_id_9dfc2760_hoisted_11)) : (0,vue_esm_bundler.createCommentVNode)("", true), $options.hasSecondPreviousPage ? ((0,vue_esm_bundler.openBlock)(), (0,vue_esm_bundler.createElementBlock)("button", {
    key: 1,
    class: "tw-relative tw-inline-flex tw-items-center tw-px-4 tw-py-2 tw-border tw-border-solid tw-text-sm tw-font-medium",
    onClick: _cache[1] || (_cache[1] = function ($event) {
      return $options.updateOffset($options.currentPage - 2);
    })
  }, (0,vue_esm_bundler.toDisplayString)($options.currentPage - 2), 1)) : (0,vue_esm_bundler.createCommentVNode)("", true), $options.hasPreviousPage ? ((0,vue_esm_bundler.openBlock)(), (0,vue_esm_bundler.createElementBlock)("button", {
    key: 2,
    class: "tw-relative tw-inline-flex tw-items-center tw-px-4 tw-py-2 tw-border tw-border-solid tw-text-sm tw-font-medium",
    onClick: _cache[2] || (_cache[2] = function ($event) {
      return $options.updateOffset($options.currentPage - 1);
    })
  }, (0,vue_esm_bundler.toDisplayString)($options.currentPage - 1), 1)) : (0,vue_esm_bundler.createCommentVNode)("", true), (0,vue_esm_bundler.createElementVNode)("button", Paginationvue_type_template_id_9dfc2760_hoisted_15, (0,vue_esm_bundler.toDisplayString)($options.currentPage), 1), $options.hasNextPage ? ((0,vue_esm_bundler.openBlock)(), (0,vue_esm_bundler.createElementBlock)("button", {
    key: 3,
    class: "tw-relative tw-inline-flex tw-items-center tw-px-4 tw-py-2 tw-border tw-border-solid tw-text-sm tw-font-medium",
    onClick: _cache[3] || (_cache[3] = function ($event) {
      return $options.updateOffset($options.currentPage + 1);
    })
  }, (0,vue_esm_bundler.toDisplayString)($options.currentPage + 1), 1)) : (0,vue_esm_bundler.createCommentVNode)("", true), $options.hasSecondNextPage ? ((0,vue_esm_bundler.openBlock)(), (0,vue_esm_bundler.createElementBlock)("button", {
    key: 4,
    class: "tw-relative tw-inline-flex tw-items-center tw-px-4 tw-py-2 tw-border tw-border-solid tw-text-sm tw-font-medium",
    onClick: _cache[4] || (_cache[4] = function ($event) {
      return $options.updateOffset($options.currentPage + 2);
    })
  }, (0,vue_esm_bundler.toDisplayString)($options.currentPage + 2), 1)) : (0,vue_esm_bundler.createCommentVNode)("", true), $props.nbHits > $props.limit * 3 ? ((0,vue_esm_bundler.openBlock)(), (0,vue_esm_bundler.createElementBlock)("button", {
    key: 5,
    disabled: $options.showingLastPage,
    class: "tw-relative tw-inline-flex tw-items-center tw-px-2 tw-py-2 tw-border tw-border-solid tw-text-sm tw-font-medium",
    onClick: _cache[5] || (_cache[5] = function ($event) {
      return $options.updateOffset($options.currentPage + 1);
    })
  }, Paginationvue_type_template_id_9dfc2760_hoisted_19, 8, Paginationvue_type_template_id_9dfc2760_hoisted_16)) : (0,vue_esm_bundler.createCommentVNode)("", true)])])])]);
}
;// CONCATENATED MODULE: ./resources/scripts/frontend/components/Pagination.vue?vue&type=template&id=9dfc2760

;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js??clonedRuleSet-3.use!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./node_modules/import-glob/index.js!./resources/scripts/frontend/components/Pagination.vue?vue&type=script&lang=js
/* harmony default export */ var Paginationvue_type_script_lang_js = ({
  name: "Pagination",
  components: {},
  props: {
    limit: {
      type: Number,
      required: true
    },
    offset: {
      type: Number,
      required: true
    },
    nbHits: {
      type: Number,
      required: true
    }
  },
  computed: {
    to: function to() {
      if (this.showingLastPage) {
        return this.nbHits;
      }
      return this.limit + this.offset;
    },
    showingLastPage: function showingLastPage() {
      return this.nbHits < this.limit + this.offset;
    },
    showingFirstPage: function showingFirstPage() {
      return this.offset === 0;
    },
    currentPage: function currentPage() {
      var currentPage = Math.ceil(this.offset / this.limit) + 1;
      if (currentPage === 0) {
        return 1;
      }
      return currentPage;
    },
    hasSecondPreviousPage: function hasSecondPreviousPage() {
      return this.currentPage > 2 && this.showingLastPage;
    },
    hasPreviousPage: function hasPreviousPage() {
      return this.currentPage > 1;
    },
    hasNextPage: function hasNextPage() {
      return this.nbHits > this.limit * this.currentPage;
    },
    hasSecondNextPage: function hasSecondNextPage() {
      return this.currentPage === 1 && this.nbHits > this.limit * (this.currentPage + 1);
    }
  },
  methods: {
    updateOffset: function updateOffset(page) {
      var offset = (page - 1) * this.limit;
      this.$emit('update-offset', offset);
    }
  }
});
;// CONCATENATED MODULE: ./resources/scripts/frontend/components/Pagination.vue?vue&type=script&lang=js
 
;// CONCATENATED MODULE: ./resources/scripts/frontend/components/Pagination.vue




;
const Pagination_exports_ = /*#__PURE__*/(0,exportHelper/* default */.A)(Paginationvue_type_script_lang_js, [['render',Paginationvue_type_template_id_9dfc2760_render]])

/* harmony default export */ var Pagination = (Pagination_exports_);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js??clonedRuleSet-3.use!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./node_modules/import-glob/index.js!./resources/scripts/frontend/components/Hits.vue?vue&type=template&id=566b371b

var Hitsvue_type_template_id_566b371b_hoisted_1 = {
  class: "tw-grid tw-grid-cols-1 sm:tw-grid-cols-2 lg:tw-grid-cols-3 tw-gap-3"
};
var Hitsvue_type_template_id_566b371b_hoisted_2 = {
  key: 0
};
function Hitsvue_type_template_id_566b371b_render(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_hit = (0,vue_esm_bundler.resolveComponent)("hit");
  return (0,vue_esm_bundler.openBlock)(), (0,vue_esm_bundler.createElementBlock)("div", null, [(0,vue_esm_bundler.createElementVNode)("div", Hitsvue_type_template_id_566b371b_hoisted_1, [((0,vue_esm_bundler.openBlock)(true), (0,vue_esm_bundler.createElementBlock)(vue_esm_bundler.Fragment, null, (0,vue_esm_bundler.renderList)($props.hits, function (hit) {
    return (0,vue_esm_bundler.openBlock)(), (0,vue_esm_bundler.createBlock)(_component_hit, {
      "display-fields": $props.displayFields,
      key: hit.id,
      hit: hit
    }, null, 8, ["display-fields", "hit"]);
  }), 128)), !$props.hits.length ? ((0,vue_esm_bundler.openBlock)(), (0,vue_esm_bundler.createElementBlock)("span", Hitsvue_type_template_id_566b371b_hoisted_2, (0,vue_esm_bundler.toDisplayString)(_ctx.$t('No items found')), 1)) : (0,vue_esm_bundler.createCommentVNode)("", true)])]);
}
;// CONCATENATED MODULE: ./resources/scripts/frontend/components/Hits.vue?vue&type=template&id=566b371b

;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js??clonedRuleSet-3.use!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./node_modules/import-glob/index.js!./resources/scripts/frontend/components/Hit.vue?vue&type=template&id=42166ea4

var Hitvue_type_template_id_42166ea4_hoisted_1 = {
  class: "flex flex-col relative max-w-sm bg-white border border-gray- shadow dark:bg-gray-800 dark:border-gray-700 mb-3 card-hov card-container"
};
var Hitvue_type_template_id_42166ea4_hoisted_2 = ["alt", "src"];
var Hitvue_type_template_id_42166ea4_hoisted_3 = {
  class: "absolute top-0 right-0 bg-gray-800 text-white p-2 text-s rounded-bl-lg topic"
};
var Hitvue_type_template_id_42166ea4_hoisted_4 = {
  class: "flex flex-col justify-between grow card-info"
};
var Hitvue_type_template_id_42166ea4_hoisted_5 = {
  class: "p-5 flex flex-col justify-between grow card-data"
};
var Hitvue_type_template_id_42166ea4_hoisted_6 = {
  class: "flex items-center min-h-12 mb-1"
};
var Hitvue_type_template_id_42166ea4_hoisted_7 = (0,vue_esm_bundler.createElementVNode)("svg", {
  "aria-hidden": "true",
  class: "mr-2 w-6 h-6 text-gray-800 dark:text-white mr-2 w-10 flex-shrink-0",
  fill: "none",
  height: "24",
  viewBox: "0 0 24 24",
  width: "24",
  xmlns: "http://www.w3.org/2000/svg"
}, [(0,vue_esm_bundler.createElementVNode)("path", {
  d: "M6 4h12M6 4v16M6 4H5m13 0v16m0-16h1m-1 16H6m12 0h1M6 20H5M9 7h1v1H9V7Zm5 0h1v1h-1V7Zm-5 4h1v1H9v-1Zm5 0h1v1h-1v-1Zm-3 4h2a1 1 0 0 1 1 1v4h-4v-4a1 1 0 0 1 1-1Z",
  stroke: "currentColor",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  "stroke-width": "2"
})], -1);
var Hitvue_type_template_id_42166ea4_hoisted_8 = ["href"];
var Hitvue_type_template_id_42166ea4_hoisted_9 = {
  class: "flex items-start mb-1"
};
var Hitvue_type_template_id_42166ea4_hoisted_10 = (0,vue_esm_bundler.createElementVNode)("svg", {
  "aria-hidden": "true",
  class: "w-6 h-6 text-gray-800 dark:text-white mr-2",
  fill: "none",
  height: "24",
  viewBox: "0 0 24 24",
  width: "24",
  xmlns: "http://www.w3.org/2000/svg"
}, [(0,vue_esm_bundler.createElementVNode)("path", {
  d: "M7 9h5m3 0h2M7 12h2m3 0h5M5 5h14a1 1 0 0 1 1 1v9a1 1 0 0 1-1 1h-6.616a1 1 0 0 0-.67.257l-2.88 2.592A.5.5 0 0 1 8 18.477V17a1 1 0 0 0-1-1H5a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1Z",
  stroke: "currentColor",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  "stroke-width": "2"
})], -1);
var Hitvue_type_template_id_42166ea4_hoisted_11 = ["href"];
var Hitvue_type_template_id_42166ea4_hoisted_12 = {
  class: "flex items-start mb-2"
};
var Hitvue_type_template_id_42166ea4_hoisted_13 = (0,vue_esm_bundler.createElementVNode)("svg", {
  "aria-hidden": "true",
  class: "w-6 h-6 text-gray-800 dark:text-white mr-2 flex-shrink-0",
  fill: "none",
  height: "24",
  viewBox: "0 0 24 24",
  width: "24",
  xmlns: "http://www.w3.org/2000/svg"
}, [(0,vue_esm_bundler.createElementVNode)("path", {
  d: "M12 8v4l3 3m6-3a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z",
  stroke: "currentColor",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  "stroke-width": "2"
})], -1);
var Hitvue_type_template_id_42166ea4_hoisted_14 = ["href"];
var Hitvue_type_template_id_42166ea4_hoisted_15 = (0,vue_esm_bundler.createElementVNode)("div", null, [(0,vue_esm_bundler.createElementVNode)("h5", {
  class: "p-2 text-s rounded-bl-lg"
}, [(0,vue_esm_bundler.createElementVNode)("span", null, "Application status: Open")])], -1);
var Hitvue_type_template_id_42166ea4_hoisted_16 = {
  key: 0,
  class: "mt-3"
};
function Hitvue_type_template_id_42166ea4_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,vue_esm_bundler.openBlock)(), (0,vue_esm_bundler.createElementBlock)("div", Hitvue_type_template_id_42166ea4_hoisted_1, [(0,vue_esm_bundler.createElementVNode)("div", null, [(0,vue_esm_bundler.createElementVNode)("img", {
    alt: $data.altimg,
    src: $props.hit.featured_image || $data.altimg,
    class: "w-full h-auto mb-1 max-h-10"
  }, null, 8, Hitvue_type_template_id_42166ea4_hoisted_2), (0,vue_esm_bundler.createElementVNode)("div", Hitvue_type_template_id_42166ea4_hoisted_3, [(0,vue_esm_bundler.createElementVNode)("span", null, (0,vue_esm_bundler.toDisplayString)($props.hit.education_subject), 1)])]), (0,vue_esm_bundler.createElementVNode)("div", Hitvue_type_template_id_42166ea4_hoisted_4, [(0,vue_esm_bundler.createElementVNode)("h4", {
    class: "text-xl font-extrabold dark:text-white mb-2 cursor-pointer px-3 mt-3",
    onClick: _cache[0] || (_cache[0] = function () {
      return $options.navigate && $options.navigate.apply($options, arguments);
    })
  }, (0,vue_esm_bundler.toDisplayString)($props.hit.post_title), 1), (0,vue_esm_bundler.createElementVNode)("div", Hitvue_type_template_id_42166ea4_hoisted_5, [(0,vue_esm_bundler.createElementVNode)("div", null, [(0,vue_esm_bundler.createElementVNode)("div", Hitvue_type_template_id_42166ea4_hoisted_6, [Hitvue_type_template_id_42166ea4_hoisted_7, (0,vue_esm_bundler.createElementVNode)("a", {
    href: $props.hit.guid,
    class: "text-gray-600 text-base"
  }, (0,vue_esm_bundler.toDisplayString)($props.hit.provided_by), 9, Hitvue_type_template_id_42166ea4_hoisted_8)]), (0,vue_esm_bundler.createElementVNode)("div", Hitvue_type_template_id_42166ea4_hoisted_9, [Hitvue_type_template_id_42166ea4_hoisted_10, (0,vue_esm_bundler.createElementVNode)("a", {
    href: $props.hit.guid,
    class: "text-gray-600 text-base"
  }, (0,vue_esm_bundler.toDisplayString)($props.hit.language), 9, Hitvue_type_template_id_42166ea4_hoisted_11)]), (0,vue_esm_bundler.createElementVNode)("div", Hitvue_type_template_id_42166ea4_hoisted_12, [Hitvue_type_template_id_42166ea4_hoisted_13, (0,vue_esm_bundler.createElementVNode)("a", {
    href: $props.hit.guid,
    class: "text-gray-600 text-base"
  }, (0,vue_esm_bundler.toDisplayString)($props.hit.workload_in_hours), 9, Hitvue_type_template_id_42166ea4_hoisted_14)])]), Hitvue_type_template_id_42166ea4_hoisted_15])]), $options.visibleFields.length ? ((0,vue_esm_bundler.openBlock)(), (0,vue_esm_bundler.createElementBlock)("ul", Hitvue_type_template_id_42166ea4_hoisted_16, [((0,vue_esm_bundler.openBlock)(true), (0,vue_esm_bundler.createElementBlock)(vue_esm_bundler.Fragment, null, (0,vue_esm_bundler.renderList)($options.visibleFields, function (value) {
    return (0,vue_esm_bundler.openBlock)(), (0,vue_esm_bundler.createElementBlock)("li", {
      key: value,
      class: "text-gray-600"
    }, (0,vue_esm_bundler.toDisplayString)(value), 1);
  }), 128))])) : (0,vue_esm_bundler.createCommentVNode)("", true)]);
}
;// CONCATENATED MODULE: ./resources/scripts/frontend/components/Hit.vue?vue&type=template&id=42166ea4

;// CONCATENATED MODULE: ./resources/images/altimg.png
/* harmony default export */ var altimg = (__webpack_require__.p + "images/altimg.e19ae1aa95.png");
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js??clonedRuleSet-3.use!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./node_modules/import-glob/index.js!./resources/scripts/frontend/components/Hit.vue?vue&type=script&lang=js

/* harmony default export */ var Hitvue_type_script_lang_js = ({
  name: "Hit",
  props: {
    hit: {
      type: Object,
      required: true
    },
    displayFields: {
      type: Array,
      required: false,
      default: function _default() {
        return [];
      }
    }
  },
  computed: {
    visibleFields: function visibleFields() {
      var values = [];
      for (var property in this.hit) {
        if (this.displayFields.includes(property) && this.hit[property]) {
          values.push(this.hit[property]);
        }
      }
      return values;
    }
  },
  data: function data() {
    return {
      altimg: altimg
    };
  },
  methods: {
    navigate: function navigate() {
      if (this.hit.guid) {
        window.location.href = this.hit.guid;
      }
    }
  }
});
;// CONCATENATED MODULE: ./resources/scripts/frontend/components/Hit.vue?vue&type=script&lang=js
 
;// CONCATENATED MODULE: ./resources/scripts/frontend/components/Hit.vue




;
const Hit_exports_ = /*#__PURE__*/(0,exportHelper/* default */.A)(Hitvue_type_script_lang_js, [['render',Hitvue_type_template_id_42166ea4_render]])

/* harmony default export */ var Hit = (Hit_exports_);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js??clonedRuleSet-3.use!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./node_modules/import-glob/index.js!./resources/scripts/frontend/components/Hits.vue?vue&type=script&lang=js

/* harmony default export */ var Hitsvue_type_script_lang_js = ({
  name: "Hits",
  components: {
    Hit: Hit
  },
  props: {
    hits: {
      type: Array,
      required: true
    },
    displayFields: {
      type: Array,
      required: false,
      default: function _default() {
        return [];
      }
    }
  }
});
;// CONCATENATED MODULE: ./resources/scripts/frontend/components/Hits.vue?vue&type=script&lang=js
 
;// CONCATENATED MODULE: ./resources/scripts/frontend/components/Hits.vue




;
const Hits_exports_ = /*#__PURE__*/(0,exportHelper/* default */.A)(Hitsvue_type_script_lang_js, [['render',Hitsvue_type_template_id_566b371b_render]])

/* harmony default export */ var Hits = (Hits_exports_);
// EXTERNAL MODULE: ./node_modules/lodash/debounce.js
var debounce = __webpack_require__(730);
var debounce_default = /*#__PURE__*/__webpack_require__.n(debounce);
// EXTERNAL MODULE: ./node_modules/meilisearch/dist/bundles/meilisearch.umd.js
var meilisearch_umd = __webpack_require__(779);
;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/bind.js


function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/utils.js




// utils is a library of generic helper functions non-specific to axios

const {toString: utils_toString} = Object.prototype;
const {getPrototypeOf} = Object;

const kindOf = (cache => thing => {
    const str = utils_toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(Object.create(null));

const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type
}

const typeOfTest = type => thing => typeof thing === type;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 *
 * @returns {boolean} True if value is an Array, otherwise false
 */
const {isArray} = Array;

/**
 * Determine if a value is undefined
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if the value is undefined, otherwise false
 */
const isUndefined = typeOfTest('undefined');

/**
 * Determine if a value is a Buffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
const isArrayBuffer = kindOfTest('ArrayBuffer');


/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  let result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a String, otherwise false
 */
const isString = typeOfTest('string');

/**
 * Determine if a value is a Function
 *
 * @param {*} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
const isFunction = typeOfTest('function');

/**
 * Determine if a value is a Number
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Number, otherwise false
 */
const isNumber = typeOfTest('number');

/**
 * Determine if a value is an Object
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an Object, otherwise false
 */
const isObject = (thing) => thing !== null && typeof thing === 'object';

/**
 * Determine if a value is a Boolean
 *
 * @param {*} thing The value to test
 * @returns {boolean} True if value is a Boolean, otherwise false
 */
const isBoolean = thing => thing === true || thing === false;

/**
 * Determine if a value is a plain Object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a plain Object, otherwise false
 */
const isPlainObject = (val) => {
  if (kindOf(val) !== 'object') {
    return false;
  }

  const prototype = getPrototypeOf(val);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
}

/**
 * Determine if a value is a Date
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Date, otherwise false
 */
const isDate = kindOfTest('Date');

/**
 * Determine if a value is a File
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFile = kindOfTest('File');

/**
 * Determine if a value is a Blob
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Blob, otherwise false
 */
const isBlob = kindOfTest('Blob');

/**
 * Determine if a value is a FileList
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFileList = kindOfTest('FileList');

/**
 * Determine if a value is a Stream
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Stream, otherwise false
 */
const isStream = (val) => isObject(val) && isFunction(val.pipe);

/**
 * Determine if a value is a FormData
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an FormData, otherwise false
 */
const isFormData = (thing) => {
  let kind;
  return thing && (
    (typeof FormData === 'function' && thing instanceof FormData) || (
      isFunction(thing.append) && (
        (kind = kindOf(thing)) === 'formdata' ||
        // detect form-data instance
        (kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]')
      )
    )
  )
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
const isURLSearchParams = kindOfTest('URLSearchParams');

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 *
 * @returns {String} The String freed of excess whitespace
 */
const trim = (str) => str.trim ?
  str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 *
 * @param {Boolean} [allOwnKeys = false]
 * @returns {any}
 */
function forEach(obj, fn, {allOwnKeys = false} = {}) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  let i;
  let l;

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;

    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}

function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}

const _global = (() => {
  /*eslint no-undef:0*/
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : (typeof window !== 'undefined' ? window : global)
})();

const isContextDefined = (context) => !isUndefined(context) && context !== _global;

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 *
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  const {caseless} = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  }

  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 *
 * @param {Boolean} [allOwnKeys]
 * @returns {Object} The resulting value of object a
 */
const extend = (a, b, thisArg, {allOwnKeys}= {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, {allOwnKeys});
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 *
 * @returns {string} content value without BOM
 */
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 *
 * @returns {void}
 */
const inherits = (constructor, superConstructor, props, descriptors) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, 'super', {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
}

/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function|Boolean} [filter]
 * @param {Function} [propFilter]
 *
 * @returns {Object}
 */
const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};

  destObj = destObj || {};
  // eslint-disable-next-line no-eq-null,eqeqeq
  if (sourceObj == null) return destObj;

  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

  return destObj;
}

/**
 * Determines whether a string ends with the characters of a specified string
 *
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 *
 * @returns {boolean}
 */
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
}


/**
 * Returns new array from array like object or null if failed
 *
 * @param {*} [thing]
 *
 * @returns {?Array}
 */
const toArray = (thing) => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i = thing.length;
  if (!isNumber(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
}

/**
 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
 * thing passed in is an instance of Uint8Array
 *
 * @param {TypedArray}
 *
 * @returns {Array}
 */
// eslint-disable-next-line func-names
const isTypedArray = (TypedArray => {
  // eslint-disable-next-line func-names
  return thing => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));

/**
 * For each entry in the object, call the function with the key and value.
 *
 * @param {Object<any, any>} obj - The object to iterate over.
 * @param {Function} fn - The function to call for each entry.
 *
 * @returns {void}
 */
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];

  const iterator = generator.call(obj);

  let result;

  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
}

/**
 * It takes a regular expression and a string, and returns an array of all the matches
 *
 * @param {string} regExp - The regular expression to match against.
 * @param {string} str - The string to search.
 *
 * @returns {Array<boolean>}
 */
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];

  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }

  return arr;
}

/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
const isHTMLForm = kindOfTest('HTMLFormElement');

const toCamelCase = str => {
  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};

/* Creating a function that will check if an object has a property. */
const utils_hasOwnProperty = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);

/**
 * Determine if a value is a RegExp object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a RegExp object, otherwise false
 */
const isRegExp = kindOfTest('RegExp');

const reduceDescriptors = (obj, reducer) => {
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};

  forEach(descriptors, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });

  Object.defineProperties(obj, reducedDescriptors);
}

/**
 * Makes all methods read-only
 * @param {Object} obj
 */

const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    // skip restricted props in strict mode
    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {
      return false;
    }

    const value = obj[name];

    if (!isFunction(value)) return;

    descriptor.enumerable = false;

    if ('writable' in descriptor) {
      descriptor.writable = false;
      return;
    }

    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error('Can not rewrite read-only method \'' + name + '\'');
      };
    }
  });
}

const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};

  const define = (arr) => {
    arr.forEach(value => {
      obj[value] = true;
    });
  }

  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));

  return obj;
}

const noop = () => {}

const toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
}

const ALPHA = 'abcdefghijklmnopqrstuvwxyz'

const DIGIT = '0123456789';

const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
}

const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = '';
  const {length} = alphabet;
  while (size--) {
    str += alphabet[Math.random() * length|0]
  }

  return str;
}

/**
 * If the thing is a FormData object, return true, otherwise return false.
 *
 * @param {unknown} thing - The thing to check.
 *
 * @returns {boolean}
 */
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator]);
}

const toJSONObject = (obj) => {
  const stack = new Array(10);

  const visit = (source, i) => {

    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }

      if(!('toJSON' in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};

        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });

        stack[i] = undefined;

        return target;
      }
    }

    return source;
  }

  return visit(obj, 0);
}

const isAsyncFn = kindOfTest('AsyncFunction');

const isThenable = (thing) =>
  thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);

/* harmony default export */ var utils = ({
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty: utils_hasOwnProperty,
  hasOwnProp: utils_hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
});

;// CONCATENATED MODULE: ./node_modules/axios/lib/core/AxiosError.js




/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 *
 * @returns {Error} The created error.
 */
function AxiosError(message, code, config, request, response) {
  Error.call(this);

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = (new Error()).stack;
  }

  this.message = message;
  this.name = 'AxiosError';
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}

utils.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});

const AxiosError_prototype = AxiosError.prototype;
const descriptors = {};

[
  'ERR_BAD_OPTION_VALUE',
  'ERR_BAD_OPTION',
  'ECONNABORTED',
  'ETIMEDOUT',
  'ERR_NETWORK',
  'ERR_FR_TOO_MANY_REDIRECTS',
  'ERR_DEPRECATED',
  'ERR_BAD_RESPONSE',
  'ERR_BAD_REQUEST',
  'ERR_CANCELED',
  'ERR_NOT_SUPPORT',
  'ERR_INVALID_URL'
// eslint-disable-next-line func-names
].forEach(code => {
  descriptors[code] = {value: code};
});

Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(AxiosError_prototype, 'isAxiosError', {value: true});

// eslint-disable-next-line func-names
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(AxiosError_prototype);

  utils.toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  }, prop => {
    return prop !== 'isAxiosError';
  });

  AxiosError.call(axiosError, error.message, code, config, request, response);

  axiosError.cause = error;

  axiosError.name = error.name;

  customProps && Object.assign(axiosError, customProps);

  return axiosError;
};

/* harmony default export */ var core_AxiosError = (AxiosError);

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/null.js
// eslint-disable-next-line strict
/* harmony default export */ var helpers_null = (null);

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/toFormData.js




// temporary hotfix to avoid circular references until AxiosURLSearchParams is refactored


/**
 * Determines if the given thing is a array or js object.
 *
 * @param {string} thing - The object or array to be visited.
 *
 * @returns {boolean}
 */
function isVisitable(thing) {
  return utils.isPlainObject(thing) || utils.isArray(thing);
}

/**
 * It removes the brackets from the end of a string
 *
 * @param {string} key - The key of the parameter.
 *
 * @returns {string} the key without the brackets.
 */
function removeBrackets(key) {
  return utils.endsWith(key, '[]') ? key.slice(0, -2) : key;
}

/**
 * It takes a path, a key, and a boolean, and returns a string
 *
 * @param {string} path - The path to the current key.
 * @param {string} key - The key of the current object being iterated over.
 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
 *
 * @returns {string} The path to the current key.
 */
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i) {
    // eslint-disable-next-line no-param-reassign
    token = removeBrackets(token);
    return !dots && i ? '[' + token + ']' : token;
  }).join(dots ? '.' : '');
}

/**
 * If the array is an array and none of its elements are visitable, then it's a flat array.
 *
 * @param {Array<any>} arr - The array to check
 *
 * @returns {boolean}
 */
function isFlatArray(arr) {
  return utils.isArray(arr) && !arr.some(isVisitable);
}

const predicates = utils.toFlatObject(utils, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});

/**
 * Convert a data object to FormData
 *
 * @param {Object} obj
 * @param {?Object} [formData]
 * @param {?Object} [options]
 * @param {Function} [options.visitor]
 * @param {Boolean} [options.metaTokens = true]
 * @param {Boolean} [options.dots = false]
 * @param {?Boolean} [options.indexes = false]
 *
 * @returns {Object}
 **/

/**
 * It converts an object into a FormData object
 *
 * @param {Object<any, any>} obj - The object to convert to form data.
 * @param {string} formData - The FormData object to append to.
 * @param {Object<string, any>} options
 *
 * @returns
 */
function toFormData(obj, formData, options) {
  if (!utils.isObject(obj)) {
    throw new TypeError('target must be an object');
  }

  // eslint-disable-next-line no-param-reassign
  formData = formData || new (helpers_null || FormData)();

  // eslint-disable-next-line no-param-reassign
  options = utils.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    return !utils.isUndefined(source[option]);
  });

  const metaTokens = options.metaTokens;
  // eslint-disable-next-line no-use-before-define
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
  const useBlob = _Blob && utils.isSpecCompliantForm(formData);

  if (!utils.isFunction(visitor)) {
    throw new TypeError('visitor must be a function');
  }

  function convertValue(value) {
    if (value === null) return '';

    if (utils.isDate(value)) {
      return value.toISOString();
    }

    if (!useBlob && utils.isBlob(value)) {
      throw new core_AxiosError('Blob is not supported. Use a Buffer instead.');
    }

    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
    }

    return value;
  }

  /**
   * Default visitor.
   *
   * @param {*} value
   * @param {String|Number} key
   * @param {Array<String|Number>} path
   * @this {FormData}
   *
   * @returns {boolean} return true to visit the each prop of the value recursively
   */
  function defaultVisitor(value, key, path) {
    let arr = value;

    if (value && !path && typeof value === 'object') {
      if (utils.endsWith(key, '{}')) {
        // eslint-disable-next-line no-param-reassign
        key = metaTokens ? key : key.slice(0, -2);
        // eslint-disable-next-line no-param-reassign
        value = JSON.stringify(value);
      } else if (
        (utils.isArray(value) && isFlatArray(value)) ||
        ((utils.isFileList(value) || utils.endsWith(key, '[]')) && (arr = utils.toArray(value))
        )) {
        // eslint-disable-next-line no-param-reassign
        key = removeBrackets(key);

        arr.forEach(function each(el, index) {
          !(utils.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),
            convertValue(el)
          );
        });
        return false;
      }
    }

    if (isVisitable(value)) {
      return true;
    }

    formData.append(renderKey(path, key, dots), convertValue(value));

    return false;
  }

  const stack = [];

  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });

  function build(value, path) {
    if (utils.isUndefined(value)) return;

    if (stack.indexOf(value) !== -1) {
      throw Error('Circular reference detected in ' + path.join('.'));
    }

    stack.push(value);

    utils.forEach(value, function each(el, key) {
      const result = !(utils.isUndefined(el) || el === null) && visitor.call(
        formData, el, utils.isString(key) ? key.trim() : key, path, exposedHelpers
      );

      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });

    stack.pop();
  }

  if (!utils.isObject(obj)) {
    throw new TypeError('data must be an object');
  }

  build(obj);

  return formData;
}

/* harmony default export */ var helpers_toFormData = (toFormData);

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/AxiosURLSearchParams.js




/**
 * It encodes a string by replacing all characters that are not in the unreserved set with
 * their percent-encoded equivalents
 *
 * @param {string} str - The string to encode.
 *
 * @returns {string} The encoded string.
 */
function encode(str) {
  const charMap = {
    '!': '%21',
    "'": '%27',
    '(': '%28',
    ')': '%29',
    '~': '%7E',
    '%20': '+',
    '%00': '\x00'
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}

/**
 * It takes a params object and converts it to a FormData object
 *
 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
 *
 * @returns {void}
 */
function AxiosURLSearchParams(params, options) {
  this._pairs = [];

  params && helpers_toFormData(params, this, options);
}

const AxiosURLSearchParams_prototype = AxiosURLSearchParams.prototype;

AxiosURLSearchParams_prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};

AxiosURLSearchParams_prototype.toString = function toString(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;

  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + '=' + _encode(pair[1]);
  }, '').join('&');
};

/* harmony default export */ var helpers_AxiosURLSearchParams = (AxiosURLSearchParams);

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/buildURL.js





/**
 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
 * URI encoded counterparts
 *
 * @param {string} val The value to be encoded.
 *
 * @returns {string} The encoded value.
 */
function buildURL_encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @param {?object} options
 *
 * @returns {string} The formatted url
 */
function buildURL(url, params, options) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }
  
  const _encode = options && options.encode || buildURL_encode;

  const serializeFn = options && options.serialize;

  let serializedParams;

  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils.isURLSearchParams(params) ?
      params.toString() :
      new helpers_AxiosURLSearchParams(params, options).toString(_encode);
  }

  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");

    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/core/InterceptorManager.js




class InterceptorManager {
  constructor() {
    this.handlers = [];
  }

  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }

  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }

  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }

  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}

/* harmony default export */ var core_InterceptorManager = (InterceptorManager);

;// CONCATENATED MODULE: ./node_modules/axios/lib/defaults/transitional.js


/* harmony default export */ var defaults_transitional = ({
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
});

;// CONCATENATED MODULE: ./node_modules/axios/lib/platform/browser/classes/URLSearchParams.js



/* harmony default export */ var classes_URLSearchParams = (typeof URLSearchParams !== 'undefined' ? URLSearchParams : helpers_AxiosURLSearchParams);

;// CONCATENATED MODULE: ./node_modules/axios/lib/platform/browser/classes/FormData.js


/* harmony default export */ var classes_FormData = (typeof FormData !== 'undefined' ? FormData : null);

;// CONCATENATED MODULE: ./node_modules/axios/lib/platform/browser/classes/Blob.js


/* harmony default export */ var classes_Blob = (typeof Blob !== 'undefined' ? Blob : null);

;// CONCATENATED MODULE: ./node_modules/axios/lib/platform/browser/index.js




/* harmony default export */ var browser = ({
  isBrowser: true,
  classes: {
    URLSearchParams: classes_URLSearchParams,
    FormData: classes_FormData,
    Blob: classes_Blob
  },
  protocols: ['http', 'https', 'file', 'blob', 'url', 'data']
});

;// CONCATENATED MODULE: ./node_modules/axios/lib/platform/common/utils.js
const hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 *
 * @returns {boolean}
 */
const hasStandardBrowserEnv = (
  (product) => {
    return hasBrowserEnv && ['ReactNative', 'NativeScript', 'NS'].indexOf(product) < 0
  })(typeof navigator !== 'undefined' && navigator.product);

/**
 * Determine if we're running in a standard browser webWorker environment
 *
 * Although the `isStandardBrowserEnv` method indicates that
 * `allows axios to run in a web worker`, the WebWorker will still be
 * filtered out due to its judgment standard
 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
 * This leads to a problem when axios post `FormData` in webWorker
 */
const hasStandardBrowserWebWorkerEnv = (() => {
  return (
    typeof WorkerGlobalScope !== 'undefined' &&
    // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope &&
    typeof self.importScripts === 'function'
  );
})();



;// CONCATENATED MODULE: ./node_modules/axios/lib/platform/index.js



/* harmony default export */ var platform = ({
  ...common_utils_namespaceObject,
  ...browser
});

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/toURLEncodedForm.js






function toURLEncodedForm(data, options) {
  return helpers_toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform.isNode && utils.isBuffer(value)) {
        this.append(key, value.toString('base64'));
        return false;
      }

      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/formDataToJSON.js




/**
 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
 *
 * @param {string} name - The name of the property to get.
 *
 * @returns An array of strings.
 */
function parsePropPath(name) {
  // foo[x][y][z]
  // foo.x.y.z
  // foo-x-y-z
  // foo x y z
  return utils.matchAll(/\w+|\[(\w*)]/g, name).map(match => {
    return match[0] === '[]' ? '' : match[1] || match[0];
  });
}

/**
 * Convert an array to an object.
 *
 * @param {Array<any>} arr - The array to convert to an object.
 *
 * @returns An object with the same keys and values as the array.
 */
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}

/**
 * It takes a FormData object and returns a JavaScript object
 *
 * @param {string} formData The FormData object to convert to JSON.
 *
 * @returns {Object<string, any> | null} The converted object.
 */
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];

    if (name === '__proto__') return true;

    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils.isArray(target) ? target.length : name;

    if (isLast) {
      if (utils.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }

      return !isNumericKey;
    }

    if (!target[name] || !utils.isObject(target[name])) {
      target[name] = [];
    }

    const result = buildPath(path, value, target[name], index);

    if (result && utils.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }

    return !isNumericKey;
  }

  if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {
    const obj = {};

    utils.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });

    return obj;
  }

  return null;
}

/* harmony default export */ var helpers_formDataToJSON = (formDataToJSON);

;// CONCATENATED MODULE: ./node_modules/axios/lib/defaults/index.js










/**
 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
 * of the input
 *
 * @param {any} rawValue - The value to be stringified.
 * @param {Function} parser - A function that parses a string into a JavaScript object.
 * @param {Function} encoder - A function that takes a value and returns a string.
 *
 * @returns {string} A stringified version of the rawValue.
 */
function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

const defaults = {

  transitional: defaults_transitional,

  adapter: ['xhr', 'http'],

  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || '';
    const hasJSONContentType = contentType.indexOf('application/json') > -1;
    const isObjectPayload = utils.isObject(data);

    if (isObjectPayload && utils.isHTMLForm(data)) {
      data = new FormData(data);
    }

    const isFormData = utils.isFormData(data);

    if (isFormData) {
      return hasJSONContentType ? JSON.stringify(helpers_formDataToJSON(data)) : data;
    }

    if (utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
      return data.toString();
    }

    let isFileList;

    if (isObjectPayload) {
      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }

      if ((isFileList = utils.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
        const _FormData = this.env && this.env.FormData;

        return helpers_toFormData(
          isFileList ? {'files[]': data} : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }

    if (isObjectPayload || hasJSONContentType ) {
      headers.setContentType('application/json', false);
      return stringifySafely(data);
    }

    return data;
  }],

  transformResponse: [function transformResponse(data) {
    const transitional = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    const JSONRequested = this.responseType === 'json';

    if (data && utils.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {
      const silentJSONParsing = transitional && transitional.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;

      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw core_AxiosError.from(e, core_AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },

  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*',
      'Content-Type': undefined
    }
  }
};

utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (method) => {
  defaults.headers[method] = {};
});

/* harmony default export */ var lib_defaults = (defaults);

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/parseHeaders.js




// RawAxiosHeaders whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
const ignoreDuplicateOf = utils.toObjectSet([
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
]);

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} rawHeaders Headers needing to be parsed
 *
 * @returns {Object} Headers parsed into an object
 */
/* harmony default export */ var parseHeaders = (rawHeaders => {
  const parsed = {};
  let key;
  let val;
  let i;

  rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
    i = line.indexOf(':');
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();

    if (!key || (parsed[key] && ignoreDuplicateOf[key])) {
      return;
    }

    if (key === 'set-cookie') {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
    }
  });

  return parsed;
});

;// CONCATENATED MODULE: ./node_modules/axios/lib/core/AxiosHeaders.js





const $internals = Symbol('internals');

function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}

function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }

  return utils.isArray(value) ? value.map(normalizeValue) : String(value);
}

function parseTokens(str) {
  const tokens = Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;

  while ((match = tokensRE.exec(str))) {
    tokens[match[1]] = match[2];
  }

  return tokens;
}

const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());

function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
  if (utils.isFunction(filter)) {
    return filter.call(this, value, header);
  }

  if (isHeaderNameFilter) {
    value = header;
  }

  if (!utils.isString(value)) return;

  if (utils.isString(filter)) {
    return value.indexOf(filter) !== -1;
  }

  if (utils.isRegExp(filter)) {
    return filter.test(value);
  }
}

function formatHeader(header) {
  return header.trim()
    .toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
      return char.toUpperCase() + str;
    });
}

function buildAccessors(obj, header) {
  const accessorName = utils.toCamelCase(' ' + header);

  ['get', 'set', 'has'].forEach(methodName => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}

class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }

  set(header, valueOrRewrite, rewrite) {
    const self = this;

    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);

      if (!lHeader) {
        throw new Error('header name must be a non-empty string');
      }

      const key = utils.findKey(self, lHeader);

      if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {
        self[key || _header] = normalizeValue(_value);
      }
    }

    const setHeaders = (headers, _rewrite) =>
      utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));

    if (utils.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite)
    } else if(utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }

    return this;
  }

  get(header, parser) {
    header = normalizeHeader(header);

    if (header) {
      const key = utils.findKey(this, header);

      if (key) {
        const value = this[key];

        if (!parser) {
          return value;
        }

        if (parser === true) {
          return parseTokens(value);
        }

        if (utils.isFunction(parser)) {
          return parser.call(this, value, key);
        }

        if (utils.isRegExp(parser)) {
          return parser.exec(value);
        }

        throw new TypeError('parser must be boolean|regexp|function');
      }
    }
  }

  has(header, matcher) {
    header = normalizeHeader(header);

    if (header) {
      const key = utils.findKey(this, header);

      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }

    return false;
  }

  delete(header, matcher) {
    const self = this;
    let deleted = false;

    function deleteHeader(_header) {
      _header = normalizeHeader(_header);

      if (_header) {
        const key = utils.findKey(self, _header);

        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
          delete self[key];

          deleted = true;
        }
      }
    }

    if (utils.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }

    return deleted;
  }

  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;

    while (i--) {
      const key = keys[i];
      if(!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }

    return deleted;
  }

  normalize(format) {
    const self = this;
    const headers = {};

    utils.forEach(this, (value, header) => {
      const key = utils.findKey(headers, header);

      if (key) {
        self[key] = normalizeValue(value);
        delete self[header];
        return;
      }

      const normalized = format ? formatHeader(header) : String(header).trim();

      if (normalized !== header) {
        delete self[header];
      }

      self[normalized] = normalizeValue(value);

      headers[normalized] = true;
    });

    return this;
  }

  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }

  toJSON(asStrings) {
    const obj = Object.create(null);

    utils.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(', ') : value);
    });

    return obj;
  }

  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }

  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\n');
  }

  get [Symbol.toStringTag]() {
    return 'AxiosHeaders';
  }

  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }

  static concat(first, ...targets) {
    const computed = new this(first);

    targets.forEach((target) => computed.set(target));

    return computed;
  }

  static accessor(header) {
    const internals = this[$internals] = (this[$internals] = {
      accessors: {}
    });

    const accessors = internals.accessors;
    const prototype = this.prototype;

    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);

      if (!accessors[lHeader]) {
        buildAccessors(prototype, _header);
        accessors[lHeader] = true;
      }
    }

    utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);

    return this;
  }
}

AxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);

// reserved names hotfix
utils.reduceDescriptors(AxiosHeaders.prototype, ({value}, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  }
});

utils.freezeMethods(AxiosHeaders);

/* harmony default export */ var core_AxiosHeaders = (AxiosHeaders);

;// CONCATENATED MODULE: ./node_modules/axios/lib/core/transformData.js






/**
 * Transform the data for a request or a response
 *
 * @param {Array|Function} fns A single function or Array of functions
 * @param {?Object} response The response object
 *
 * @returns {*} The resulting transformed data
 */
function transformData(fns, response) {
  const config = this || lib_defaults;
  const context = response || config;
  const headers = core_AxiosHeaders.from(context.headers);
  let data = context.data;

  utils.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
  });

  headers.normalize();

  return data;
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/cancel/isCancel.js


function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/cancel/CanceledError.js





/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @param {string=} message The message.
 * @param {Object=} config The config.
 * @param {Object=} request The request.
 *
 * @returns {CanceledError} The created error.
 */
function CanceledError(message, config, request) {
  // eslint-disable-next-line no-eq-null,eqeqeq
  core_AxiosError.call(this, message == null ? 'canceled' : message, core_AxiosError.ERR_CANCELED, config, request);
  this.name = 'CanceledError';
}

utils.inherits(CanceledError, core_AxiosError, {
  __CANCEL__: true
});

/* harmony default export */ var cancel_CanceledError = (CanceledError);

;// CONCATENATED MODULE: ./node_modules/axios/lib/core/settle.js




/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 *
 * @returns {object} The response.
 */
function settle(resolve, reject, response) {
  const validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(new core_AxiosError(
      'Request failed with status code ' + response.status,
      [core_AxiosError.ERR_BAD_REQUEST, core_AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/cookies.js



/* harmony default export */ var cookies = (platform.hasStandardBrowserEnv ?

  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path, domain, secure) {
      const cookie = [name + '=' + encodeURIComponent(value)];

      utils.isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString());

      utils.isString(path) && cookie.push('path=' + path);

      utils.isString(domain) && cookie.push('domain=' + domain);

      secure === true && cookie.push('secure');

      document.cookie = cookie.join('; ');
    },

    read(name) {
      const match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
      return (match ? decodeURIComponent(match[3]) : null);
    },

    remove(name) {
      this.write(name, '', Date.now() - 86400000);
    }
  }

  :

  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {},
    read() {
      return null;
    },
    remove() {}
  });


;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/isAbsoluteURL.js


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 *
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/combineURLs.js


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 *
 * @returns {string} The combined URL
 */
function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/?\/$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/core/buildFullPath.js





/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 *
 * @returns {string} The combined full path
 */
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/isURLSameOrigin.js





/* harmony default export */ var isURLSameOrigin = (platform.hasStandardBrowserEnv ?

// Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
  (function standardBrowserEnv() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement('a');
    let originURL;

    /**
    * Parse a URL to discover its components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
    function resolveURL(url) {
      let href = url;

      if (msie) {
        // IE needs attribute set twice to normalize properties
        urlParsingNode.setAttribute('href', href);
        href = urlParsingNode.href;
      }

      urlParsingNode.setAttribute('href', href);

      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
          urlParsingNode.pathname :
          '/' + urlParsingNode.pathname
      };
    }

    originURL = resolveURL(window.location.href);

    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
    return function isURLSameOrigin(requestURL) {
      const parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
      return (parsed.protocol === originURL.protocol &&
          parsed.host === originURL.host);
    };
  })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  })());

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/parseProtocol.js


function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || '';
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/speedometer.js


/**
 * Calculate data maxRate
 * @param {Number} [samplesCount= 10]
 * @param {Number} [min= 1000]
 * @returns {Function}
 */
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;

  min = min !== undefined ? min : 1000;

  return function push(chunkLength) {
    const now = Date.now();

    const startedAt = timestamps[tail];

    if (!firstSampleTS) {
      firstSampleTS = now;
    }

    bytes[head] = chunkLength;
    timestamps[head] = now;

    let i = tail;
    let bytesCount = 0;

    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }

    head = (head + 1) % samplesCount;

    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }

    if (now - firstSampleTS < min) {
      return;
    }

    const passed = startedAt && now - startedAt;

    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
  };
}

/* harmony default export */ var helpers_speedometer = (speedometer);

;// CONCATENATED MODULE: ./node_modules/axios/lib/adapters/xhr.js
















function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = helpers_speedometer(50, 250);

  return e => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : undefined;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;

    bytesNotified = loaded;

    const data = {
      loaded,
      total,
      progress: total ? (loaded / total) : undefined,
      bytes: progressBytes,
      rate: rate ? rate : undefined,
      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
      event: e
    };

    data[isDownloadStream ? 'download' : 'upload'] = true;

    listener(data);
  };
}

const isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';

/* harmony default export */ var xhr = (isXHRAdapterSupported && function (config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    let requestData = config.data;
    const requestHeaders = core_AxiosHeaders.from(config.headers).normalize();
    let {responseType, withXSRFToken} = config;
    let onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }

      if (config.signal) {
        config.signal.removeEventListener('abort', onCanceled);
      }
    }

    let contentType;

    if (utils.isFormData(requestData)) {
      if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
        requestHeaders.setContentType(false); // Let the browser set it
      } else if ((contentType = requestHeaders.getContentType()) !== false) {
        // fix semicolon duplication issue for ReactNative FormData implementation
        const [type, ...tokens] = contentType ? contentType.split(';').map(token => token.trim()).filter(Boolean) : [];
        requestHeaders.setContentType([type || 'multipart/form-data', ...tokens].join('; '));
      }
    }

    let request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      const username = config.auth.username || '';
      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.set('Authorization', 'Basic ' + btoa(username + ':' + password));
    }

    const fullPath = buildFullPath(config.baseURL, config.url);

    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      const responseHeaders = core_AxiosHeaders.from(
        'getAllResponseHeaders' in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === 'text' || responseType === 'json' ?
        request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };

      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(new core_AxiosError('Request aborted', core_AxiosError.ECONNABORTED, config, request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(new core_AxiosError('Network Error', core_AxiosError.ERR_NETWORK, config, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
      const transitional = config.transitional || defaults_transitional;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new core_AxiosError(
        timeoutErrorMessage,
        transitional.clarifyTimeoutError ? core_AxiosError.ETIMEDOUT : core_AxiosError.ECONNABORTED,
        config,
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if(platform.hasStandardBrowserEnv) {
      withXSRFToken && utils.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));

      if (withXSRFToken || (withXSRFToken !== false && isURLSameOrigin(fullPath))) {
        // Add xsrf header
        const xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && cookies.read(config.xsrfCookieName);

        if (xsrfValue) {
          requestHeaders.set(config.xsrfHeaderName, xsrfValue);
        }
      }
    }

    // Remove Content-Type if data is undefined
    requestData === undefined && requestHeaders.setContentType(null);

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', progressEventReducer(config.onDownloadProgress, true));
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', progressEventReducer(config.onUploadProgress));
    }

    if (config.cancelToken || config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = cancel => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new cancel_CanceledError(null, config, request) : cancel);
        request.abort();
        request = null;
      };

      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
      }
    }

    const protocol = parseProtocol(fullPath);

    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new core_AxiosError('Unsupported protocol ' + protocol + ':', core_AxiosError.ERR_BAD_REQUEST, config));
      return;
    }


    // Send the request
    request.send(requestData || null);
  });
});

;// CONCATENATED MODULE: ./node_modules/axios/lib/adapters/adapters.js





const knownAdapters = {
  http: helpers_null,
  xhr: xhr
}

utils.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, 'name', {value});
    } catch (e) {
      // eslint-disable-next-line no-empty
    }
    Object.defineProperty(fn, 'adapterName', {value});
  }
});

const renderReason = (reason) => `- ${reason}`;

const isResolvedHandle = (adapter) => utils.isFunction(adapter) || adapter === null || adapter === false;

/* harmony default export */ var adapters = ({
  getAdapter: (adapters) => {
    adapters = utils.isArray(adapters) ? adapters : [adapters];

    const {length} = adapters;
    let nameOrAdapter;
    let adapter;

    const rejectedReasons = {};

    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      let id;

      adapter = nameOrAdapter;

      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];

        if (adapter === undefined) {
          throw new core_AxiosError(`Unknown adapter '${id}'`);
        }
      }

      if (adapter) {
        break;
      }

      rejectedReasons[id || '#' + i] = adapter;
    }

    if (!adapter) {

      const reasons = Object.entries(rejectedReasons)
        .map(([id, state]) => `adapter ${id} ` +
          (state === false ? 'is not supported by the environment' : 'is not available in the build')
        );

      let s = length ?
        (reasons.length > 1 ? 'since :\n' + reasons.map(renderReason).join('\n') : ' ' + renderReason(reasons[0])) :
        'as no adapter specified';

      throw new core_AxiosError(
        `There is no suitable adapter to dispatch the request ` + s,
        'ERR_NOT_SUPPORT'
      );
    }

    return adapter;
  },
  adapters: knownAdapters
});

;// CONCATENATED MODULE: ./node_modules/axios/lib/core/dispatchRequest.js









/**
 * Throws a `CanceledError` if cancellation has been requested.
 *
 * @param {Object} config The config that is to be used for the request
 *
 * @returns {void}
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new cancel_CanceledError(null, config);
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 *
 * @returns {Promise} The Promise to be fulfilled
 */
function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  config.headers = core_AxiosHeaders.from(config.headers);

  // Transform request data
  config.data = transformData.call(
    config,
    config.transformRequest
  );

  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
    config.headers.setContentType('application/x-www-form-urlencoded', false);
  }

  const adapter = adapters.getAdapter(config.adapter || lib_defaults.adapter);

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );

    response.headers = core_AxiosHeaders.from(response.headers);

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = core_AxiosHeaders.from(reason.response.headers);
      }
    }

    return Promise.reject(reason);
  });
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/core/mergeConfig.js





const headersToObject = (thing) => thing instanceof core_AxiosHeaders ? { ...thing } : thing;

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 *
 * @returns {Object} New object resulting from merging config2 to config1
 */
function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  const config = {};

  function getMergedValue(target, source, caseless) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge.call({caseless}, target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(a, b, caseless) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!utils.isUndefined(a)) {
      return getMergedValue(undefined, a, caseless);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(a, b) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(undefined, b);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(a, b) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(undefined, b);
    } else if (!utils.isUndefined(a)) {
      return getMergedValue(undefined, a);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(undefined, a);
    }
  }

  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
  };

  utils.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge(config1[prop], config2[prop], prop);
    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
  });

  return config;
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/env/data.js
const VERSION = "1.6.8";
;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/validator.js





const validators = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

const deprecatedWarnings = {};

/**
 * Transitional option validator
 *
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 *
 * @returns {function}
 */
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return (value, opt, opts) => {
    if (validator === false) {
      throw new core_AxiosError(
        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
        core_AxiosError.ERR_DEPRECATED
      );
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 *
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 *
 * @returns {object}
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new core_AxiosError('options must be an object', core_AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new core_AxiosError('option ' + opt + ' must be ' + result, core_AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new core_AxiosError('Unknown option ' + opt, core_AxiosError.ERR_BAD_OPTION);
    }
  }
}

/* harmony default export */ var validator = ({
  assertOptions,
  validators
});

;// CONCATENATED MODULE: ./node_modules/axios/lib/core/Axios.js











const Axios_validators = validator.validators;

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 *
 * @return {Axios} A new instance of Axios
 */
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new core_InterceptorManager(),
      response: new core_InterceptorManager()
    };
  }

  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy;

        Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : (dummy = new Error());

        // slice off the Error: ... line
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, '') : '';

        if (!err.stack) {
          err.stack = stack;
          // match without the 2 top stack lines
        } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ''))) {
          err.stack += '\n' + stack
        }
      }

      throw err;
    }
  }

  _request(configOrUrl, config) {
    /*eslint no-param-reassign:0*/
    // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof configOrUrl === 'string') {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }

    config = mergeConfig(this.defaults, config);

    const {transitional, paramsSerializer, headers} = config;

    if (transitional !== undefined) {
      validator.assertOptions(transitional, {
        silentJSONParsing: Axios_validators.transitional(Axios_validators.boolean),
        forcedJSONParsing: Axios_validators.transitional(Axios_validators.boolean),
        clarifyTimeoutError: Axios_validators.transitional(Axios_validators.boolean)
      }, false);
    }

    if (paramsSerializer != null) {
      if (utils.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        }
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: Axios_validators.function,
          serialize: Axios_validators.function
        }, true);
      }
    }

    // Set config.method
    config.method = (config.method || this.defaults.method || 'get').toLowerCase();

    // Flatten headers
    let contextHeaders = headers && utils.merge(
      headers.common,
      headers[config.method]
    );

    headers && utils.forEach(
      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
      (method) => {
        delete headers[method];
      }
    );

    config.headers = core_AxiosHeaders.concat(contextHeaders, headers);

    // filter out skipped interceptors
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
        return;
      }

      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });

    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });

    let promise;
    let i = 0;
    let len;

    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), undefined];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;

      promise = Promise.resolve(config);

      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }

      return promise;
    }

    len = requestInterceptorChain.length;

    let newConfig = config;

    i = 0;

    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }

    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }

    i = 0;
    len = responseInterceptorChain.length;

    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }

    return promise;
  }

  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/

  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          'Content-Type': 'multipart/form-data'
        } : {},
        url,
        data
      }));
    };
  }

  Axios.prototype[method] = generateHTTPMethod();

  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
});

/* harmony default export */ var core_Axios = (Axios);

;// CONCATENATED MODULE: ./node_modules/axios/lib/cancel/CancelToken.js




/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @param {Function} executor The executor function.
 *
 * @returns {CancelToken}
 */
class CancelToken {
  constructor(executor) {
    if (typeof executor !== 'function') {
      throw new TypeError('executor must be a function.');
    }

    let resolvePromise;

    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });

    const token = this;

    // eslint-disable-next-line func-names
    this.promise.then(cancel => {
      if (!token._listeners) return;

      let i = token._listeners.length;

      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });

    // eslint-disable-next-line func-names
    this.promise.then = onfulfilled => {
      let _resolve;
      // eslint-disable-next-line func-names
      const promise = new Promise(resolve => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);

      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };

      return promise;
    };

    executor(function cancel(message, config, request) {
      if (token.reason) {
        // Cancellation has already been requested
        return;
      }

      token.reason = new cancel_CanceledError(message, config, request);
      resolvePromise(token.reason);
    });
  }

  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }

  /**
   * Subscribe to the cancel signal
   */

  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }

    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }

  /**
   * Unsubscribe from the cancel signal
   */

  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }

  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
}

/* harmony default export */ var cancel_CancelToken = (CancelToken);

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/spread.js


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 *
 * @returns {Function}
 */
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/isAxiosError.js




/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 *
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
function isAxiosError(payload) {
  return utils.isObject(payload) && (payload.isAxiosError === true);
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/HttpStatusCode.js
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
};

Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});

/* harmony default export */ var helpers_HttpStatusCode = (HttpStatusCode);

;// CONCATENATED MODULE: ./node_modules/axios/lib/axios.js




















/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 *
 * @returns {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  const context = new core_Axios(defaultConfig);
  const instance = bind(core_Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, core_Axios.prototype, context, {allOwnKeys: true});

  // Copy context to instance
  utils.extend(instance, context, null, {allOwnKeys: true});

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };

  return instance;
}

// Create the default instance to be exported
const axios = createInstance(lib_defaults);

// Expose Axios class to allow class inheritance
axios.Axios = core_Axios;

// Expose Cancel & CancelToken
axios.CanceledError = cancel_CanceledError;
axios.CancelToken = cancel_CancelToken;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = helpers_toFormData;

// Expose AxiosError class
axios.AxiosError = core_AxiosError;

// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};

axios.spread = spread;

// Expose isAxiosError
axios.isAxiosError = isAxiosError;

// Expose mergeConfig
axios.mergeConfig = mergeConfig;

axios.AxiosHeaders = core_AxiosHeaders;

axios.formToJSON = thing => helpers_formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);

axios.getAdapter = adapters.getAdapter;

axios.HttpStatusCode = helpers_HttpStatusCode;

axios.default = axios;

// this module should only have a default export
/* harmony default export */ var lib_axios = (axios);

;// CONCATENATED MODULE: ./resources/scripts/FormDataApi.js

var FormDataApi = lib_axios.create({
  headers: {
    'Content-Type': 'multipart/form-data'
  }
});
/* harmony default export */ var scripts_FormDataApi = (FormDataApi);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js??clonedRuleSet-3.use!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./node_modules/import-glob/index.js!./resources/scripts/frontend/App.vue?vue&type=script&lang=js
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }









/* harmony default export */ var Appvue_type_script_lang_js = ({
  data: function data() {
    return {
      loading: false,
      searchClient: null,
      meilisearchUrl: null,
      meilisearchKey: null,
      resultText: null,
      isResult: false,
      meilisearchIndexKey: null,
      searchString: null,
      fees: null,
      displayFields: [],
      filterFields: [],
      filterValues: {},
      limit: 12,
      offset: 0,
      nbHits: 0,
      hits: [],
      meilisearchFail: false
    };
  },
  components: {
    Hits: Hits,
    VueSlider: (vue_slider_component_umd_min_default()),
    DatePicker: DatePicker,
    Pagination: Pagination
  },
  watch: {
    searchString: function searchString() {
      this.querySearch();
    },
    limit: function limit() {
      this.search();
    }
  },
  created: function created() {
    this.loadData();
  },
  methods: {
    querySearch: debounce_default()(function () {
      this.search();
    }, 500),
    loadData: function loadData() {
      var _this = this;
      var formData = new FormData();
      formData.append("action", "get_meilisearch_key");
      formData.append("index_key", indexKey);
      var setSearchClient = scripts_FormDataApi.post(ajaxurl, formData).then(function (response) {
        _this.meilisearchUrl = response.data.url;
        _this.meilisearchKey = response.data.key;
        _this.meilisearchIndexKey = indexKey;
        _this.resultText = response.data.result_text;
        _this.searchClient = new meilisearch_umd.MeiliSearch({
          host: _this.meilisearchUrl,
          apiKey: _this.meilisearchKey
        });
      });
      formData = new FormData();
      formData.append("action", "get_display_fields");
      scripts_FormDataApi.post(ajaxurl, formData).then(function (response) {
        _this.displayFields = response.data;
      });
      formData = new FormData();
      formData.append("action", "get_xml_fields");
      var xmlFieldsPromise = scripts_FormDataApi.post(ajaxurl, formData).then(function (response) {
        var _iterator = _createForOfIteratorHelper(response.data),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var field = _step.value;
            if (!field.filter) {
              continue;
            }
            if (field.filter === 'disabled') {
              continue;
            }
            var filter = {
              type: field.filter,
              field: field.slug,
              title: field.title,
              search_key: field.search_key
            };
            if (field.filter === 'slider') {
              filter.max = field.max;
              filter.min = field.min;
              if (filter.max === filter.min) {
                continue;
              }
              _this.$set(_this.filterValues, field.slug, [field.min, field.max]);
            }
            if (['checkbox', 'dropdown', 'multiselect'].includes(field.filter)) {
              filter.values = field.values;
              _this.$set(_this.filterValues, field.slug, []);
            }
            _this.filterFields.push(filter);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      });
      Promise.all([xmlFieldsPromise, setSearchClient]).then(function () {
        _this.search();
      });
    },
    search: function search() {
      var _this2 = this;
      if (!this.searchClient) {
        return;
      }
      this.loading = true;
      var filters = this.getFilters();
      var searchParams = {};
      if (filters.length) {
        searchParams.filter = filters.join(' AND ');
      }
      searchParams.limit = Number(this.limit);
      searchParams.offset = this.offset;
      try {
        var apiUrl = "".concat(this.meilisearchUrl, "/indexes/").concat(this.meilisearchIndexKey, "/search");
        var apiKey = this.meilisearchKey;
        var requestOptions = {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': "Bearer ".concat(apiKey)
          },
          body: JSON.stringify(_objectSpread({
            q: this.searchString
          }, searchParams))
        };
        fetch(apiUrl, requestOptions).then(function (response) {
          return response.json();
        }).then(function (data) {
          _this2.hits = data.hits;
          _this2.nbHits = data.estimatedTotalHits;
        }).finally(function () {
          _this2.loading = false;
        });
      } catch (e) {
        this.meilisearchFail = true;
      }
    },
    setDimensionsFilter: function setDimensionsFilter(filters) {
      var params = new Proxy(new URLSearchParams(window.location.search), {
        get: function get(searchParams, prop) {
          return searchParams.get(prop);
        }
      });
      this.isResult = false;
      if (params.dimensions) {
        this.isResult = true;
        var facet = " (";
        var index = 1;
        var _iterator2 = _createForOfIteratorHelper(params.dimensions.split(',')),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var dimension = _step2.value;
            if (index !== 1) {
              facet += " OR ";
            }
            facet += "loc_subset_items = " + dimension;
            index++;
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        facet += ") ";
        filters.push(facet);
      }
      return filters;
    },
    getFilters: function getFilters() {
      var filters = [];
      filters = this.setDimensionsFilter(filters);
      var _iterator3 = _createForOfIteratorHelper(this.filterFields),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var filterField = _step3.value;
          if (!this.filterValues[filterField.field]) {
            continue;
          }
          var value = this.filterValues[filterField.field];
          var slug = filterField.field;
          if (filterField.type === 'slider') {
            if (value[0] == filterField.min && value[1] == filterField.max) {
              continue;
            }
            filters.push(" ((" + slug + " >= " + value[0] + " AND " + slug + " <= " + value[1] + ") OR " + slug + " = '') ");
          }
          if (filterField.type === 'date') {
            if (!value[0] && value[1] == filterField.max) {
              continue;
            }
            filters.push(" ((" + slug + " >= " + value[0] + " AND " + slug + " <= " + value[1] + ") OR " + slug + " = '') ");
          }
          if (['checkbox'].includes(filterField.type)) {
            if (!value.length) {
              continue;
            }
            var facet = " (";
            var index = 1;
            var _iterator4 = _createForOfIteratorHelper(value),
              _step4;
            try {
              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                var valueItem = _step4.value;
                if (index !== 1) {
                  facet += " OR ";
                }
                facet += slug + " = " + "'" + valueItem + "'";
                index++;
              }
            } catch (err) {
              _iterator4.e(err);
            } finally {
              _iterator4.f();
            }
            facet += ") ";
            filters.push(facet);
          }
          if (['multiselect'].includes(filterField.type)) {
            if (!value.length) {
              continue;
            }
            var _facet = " (";
            var _index = 1;
            var _iterator5 = _createForOfIteratorHelper(value),
              _step5;
            try {
              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                var _valueItem = _step5.value;
                if (_index !== 1) {
                  _facet += " OR ";
                }
                _facet += filterField.search_key + " = " + "'" + _valueItem.id + "'";
                _index++;
              }
            } catch (err) {
              _iterator5.e(err);
            } finally {
              _iterator5.f();
            }
            _facet += ") ";
            filters.push(_facet);
          }
          if (['dropdown'].includes(filterField.type)) {
            console.log('noot');
            console.log(this.filterValues);
            if (!value.length) {
              continue;
            }
            var _facet2 = " (";
            _facet2 += slug + " = " + "'" + value + "'";
            _facet2 += ") ";
            filters.push(_facet2);
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      return filters;
    },
    getFacets: function getFacets() {
      var facets = [];
      var _iterator6 = _createForOfIteratorHelper(this.filterFields),
        _step6;
      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var filterField = _step6.value;
          if (!this.filterValues[filterField.field]) {
            continue;
          }
          var values = this.filterValues[filterField.field];
          var slug = filterField.field;
          if (filterField.type === 'checkbox') {
            var facetItems = [];
            var _iterator7 = _createForOfIteratorHelper(values),
              _step7;
            try {
              for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                var value = _step7.value;
                if (value) {
                  facetItems.push(slug + ":" + value);
                }
              }
            } catch (err) {
              _iterator7.e(err);
            } finally {
              _iterator7.f();
            }
            if (facetItems.length) {
              facets.push(facetItems);
            }
          }
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
      return facets;
    },
    filterDate: function filterDate(dates, slug) {
      if (!dates) {
        this.filterValues[slug] = null;
        this.search();
        return;
      }
      this.filterValues[slug] = [dates.start.getTime() / 1000, dates.end.getTime() / 1000];
      this.search();
    },
    updateOffset: function updateOffset(offset) {
      this.offset = offset;
      this.search();
    }
  }
});
;// CONCATENATED MODULE: ./resources/scripts/frontend/App.vue?vue&type=script&lang=js
 
;// CONCATENATED MODULE: ./resources/scripts/frontend/App.vue




;


const App_exports_ = /*#__PURE__*/(0,exportHelper/* default */.A)(Appvue_type_script_lang_js, [['render',render]])

/* harmony default export */ var App = (App_exports_);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js??clonedRuleSet-3.use!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./node_modules/import-glob/index.js!./resources/scripts/frontend/AppSingleCatalogue.vue?vue&type=template&id=0eaa509c

var AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_1 = {
  class: "structure-item"
};
var AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_2 = ["href"];
var AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_3 = {
  class: "container"
};
var AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_4 = {
  class: "post-section"
};
var AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_5 = {
  class: "structure"
};
var AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_6 = {
  class: "structure-item"
};
var AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_7 = (0,vue_esm_bundler.createElementVNode)("h4", null, "Language", -1);
var AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_8 = {
  class: "structure-item"
};
var AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_9 = (0,vue_esm_bundler.createElementVNode)("h4", null, "Provided by", -1);
var AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_10 = {
  class: "structure-item"
};
var AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_11 = (0,vue_esm_bundler.createElementVNode)("h4", null, "Start date", -1);
var AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_12 = {
  class: "structure-item"
};
var AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_13 = (0,vue_esm_bundler.createElementVNode)("h4", null, "End date", -1);
var AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_14 = {
  class: "structure"
};
var AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_15 = {
  class: "structure-item"
};
var AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_16 = (0,vue_esm_bundler.createElementVNode)("h4", null, "Provided at", -1);
var AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_17 = {
  class: "structure-item"
};
var AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_18 = (0,vue_esm_bundler.createElementVNode)("h4", null, "ECTS", -1);
var AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_19 = {
  class: "structure-item"
};
var AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_20 = (0,vue_esm_bundler.createElementVNode)("h4", null, "Workload in hours", -1);
var AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_21 = {
  class: "structure-item"
};
var AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_22 = (0,vue_esm_bundler.createElementVNode)("h4", null, "Price", -1);
var AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_23 = {
  class: "structure-item"
};
var AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_24 = (0,vue_esm_bundler.createElementVNode)("h4", null, "Application status", -1);
var _hoisted_25 = ["innerHTML"];
var _hoisted_26 = {
  class: "data-section"
};
var _hoisted_27 = {
  class: "filter-section"
};
var _hoisted_28 = ["onClick"];
var _hoisted_29 = {
  class: "filter-section-mobile"
};
var AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_30 = (0,vue_esm_bundler.createElementVNode)("div", {
  class: "burger-line"
}, null, -1);
var _hoisted_31 = (0,vue_esm_bundler.createElementVNode)("div", {
  class: "burger-line"
}, null, -1);
var _hoisted_32 = (0,vue_esm_bundler.createElementVNode)("div", {
  class: "burger-line"
}, null, -1);
var _hoisted_33 = [AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_30, _hoisted_31, _hoisted_32];
var _hoisted_34 = {
  id: "title-selected",
  class: "mobile-selected"
};
var _hoisted_35 = ["onClick"];
var _hoisted_36 = {
  class: "selected-field"
};
var _hoisted_37 = {
  key: 1
};
var _hoisted_38 = ["href"];
var _hoisted_39 = ["innerHTML"];
var _hoisted_40 = ["innerHTML"];
function AppSingleCataloguevue_type_template_id_0eaa509c_render(_ctx, _cache, $props, $setup, $data, $options) {
  var _this = this;
  return (0,vue_esm_bundler.openBlock)(), (0,vue_esm_bundler.createElementBlock)(vue_esm_bundler.Fragment, null, [(0,vue_esm_bundler.createElementVNode)("div", AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_1, [(0,vue_esm_bundler.createElementVNode)("a", {
    href: $data.applyURL,
    class: "apply-button"
  }, "Apply Here", 8, AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_2)]), (0,vue_esm_bundler.createElementVNode)("div", AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_3, [(0,vue_esm_bundler.createElementVNode)("div", AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_4, [(0,vue_esm_bundler.createElementVNode)("div", AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_5, [(0,vue_esm_bundler.createElementVNode)("div", AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_6, [AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_7, (0,vue_esm_bundler.createElementVNode)("p", null, (0,vue_esm_bundler.toDisplayString)($data.language), 1)]), (0,vue_esm_bundler.createElementVNode)("div", AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_8, [AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_9, (0,vue_esm_bundler.createElementVNode)("p", null, (0,vue_esm_bundler.toDisplayString)(_ctx.providedBy), 1)]), (0,vue_esm_bundler.createElementVNode)("div", AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_10, [AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_11, (0,vue_esm_bundler.createElementVNode)("p", null, (0,vue_esm_bundler.toDisplayString)($data.startDate), 1)]), (0,vue_esm_bundler.createElementVNode)("div", AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_12, [AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_13, (0,vue_esm_bundler.createElementVNode)("p", null, (0,vue_esm_bundler.toDisplayString)($data.endDate), 1)])]), (0,vue_esm_bundler.createElementVNode)("div", AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_14, [(0,vue_esm_bundler.createElementVNode)("div", AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_15, [AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_16, (0,vue_esm_bundler.createElementVNode)("p", null, (0,vue_esm_bundler.toDisplayString)($data.providedAt), 1)]), (0,vue_esm_bundler.createElementVNode)("div", AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_17, [AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_18, (0,vue_esm_bundler.createElementVNode)("p", null, (0,vue_esm_bundler.toDisplayString)($data.ects), 1)]), (0,vue_esm_bundler.createElementVNode)("div", AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_19, [AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_20, (0,vue_esm_bundler.createElementVNode)("p", null, (0,vue_esm_bundler.toDisplayString)($data.workload), 1)]), (0,vue_esm_bundler.createElementVNode)("div", AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_21, [AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_22, (0,vue_esm_bundler.createElementVNode)("p", null, (0,vue_esm_bundler.toDisplayString)($data.price), 1)]), (0,vue_esm_bundler.createElementVNode)("div", AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_23, [AppSingleCataloguevue_type_template_id_0eaa509c_hoisted_24, (0,vue_esm_bundler.createElementVNode)("p", null, (0,vue_esm_bundler.toDisplayString)($data.status), 1)])]), (0,vue_esm_bundler.createElementVNode)("div", {
    ref: "postContent",
    class: "post-content",
    innerHTML: $data.post.post_content
  }, null, 8, _hoisted_25)]), (0,vue_esm_bundler.createElementVNode)("div", _hoisted_26, [(0,vue_esm_bundler.createElementVNode)("div", _hoisted_27, [(0,vue_esm_bundler.createElementVNode)("div", {
    class: (0,vue_esm_bundler.normalizeClass)(["fields-btns", {
      'clicked': $data.burgerMenuOpen
    }])
  }, [((0,vue_esm_bundler.openBlock)(true), (0,vue_esm_bundler.createElementBlock)(vue_esm_bundler.Fragment, null, (0,vue_esm_bundler.renderList)($data.data, function (value, key, index) {
    return (0,vue_esm_bundler.openBlock)(), (0,vue_esm_bundler.createElementBlock)("button", {
      key: key,
      class: (0,vue_esm_bundler.normalizeClass)([{
        'data-btn-active': $data.activeIndex === index
      }, "data-button"]),
      onClick: function onClick($event) {
        return $options.displayData(key, index);
      }
    }, (0,vue_esm_bundler.toDisplayString)($options.transformKey(key)), 11, _hoisted_28);
  }), 128))], 2)]), (0,vue_esm_bundler.createElementVNode)("div", _hoisted_29, [(0,vue_esm_bundler.createElementVNode)("div", {
    class: "burger-menu",
    onClick: _cache[0] || (_cache[0] = function () {
      return $options.toggleBurgerMenu && $options.toggleBurgerMenu.apply($options, arguments);
    })
  }, _hoisted_33), (0,vue_esm_bundler.createElementVNode)("h3", _hoisted_34, (0,vue_esm_bundler.toDisplayString)($options.transformKey($data.selectedFilter)), 1), (0,vue_esm_bundler.createElementVNode)("div", {
    class: (0,vue_esm_bundler.normalizeClass)(["fields-buttons fields-buttons-hide", {
      'clicked': $data.burgerMenuOpen
    }])
  }, [((0,vue_esm_bundler.openBlock)(true), (0,vue_esm_bundler.createElementBlock)(vue_esm_bundler.Fragment, null, (0,vue_esm_bundler.renderList)($data.data, function (value, key, index) {
    return (0,vue_esm_bundler.openBlock)(), (0,vue_esm_bundler.createElementBlock)("button", {
      key: key,
      class: (0,vue_esm_bundler.normalizeClass)([{
        'data-btn-active': $data.activeIndex === index
      }, "data-button"]),
      onClick: function onClick($event) {
        return $options.displayData(key, index);
      }
    }, (0,vue_esm_bundler.toDisplayString)($options.transformKey(key)), 11, _hoisted_35);
  }), 128))], 2)]), (0,vue_esm_bundler.createElementVNode)("div", _hoisted_36, [(0,vue_esm_bundler.createElementVNode)("ul", null, [((0,vue_esm_bundler.openBlock)(true), (0,vue_esm_bundler.createElementBlock)(vue_esm_bundler.Fragment, null, (0,vue_esm_bundler.renderList)($data.selectedField, function (value, key) {
    return (0,vue_esm_bundler.openBlock)(), (0,vue_esm_bundler.createElementBlock)("li", {
      key: key
    }, [$data.selectedFilter === 'additional' ? ((0,vue_esm_bundler.openBlock)(), (0,vue_esm_bundler.createElementBlock)(vue_esm_bundler.Fragment, {
      key: 0
    }, [(0,vue_esm_bundler.createElementVNode)("strong", null, (0,vue_esm_bundler.toDisplayString)($options.getTitleForAdditional(key)) + ":", 1), (0,vue_esm_bundler.createTextVNode)(" " + (0,vue_esm_bundler.toDisplayString)(value), 1)], 64)) : _this.fieldSettings[$data.selectedFilter][key].is_url === true ? ((0,vue_esm_bundler.openBlock)(), (0,vue_esm_bundler.createElementBlock)("strong", _hoisted_37, [(0,vue_esm_bundler.createElementVNode)("a", {
      class: "link-value",
      href: value,
      target: "_blank"
    }, (0,vue_esm_bundler.toDisplayString)(_this.fieldSettings[$data.selectedFilter][key].label), 9, _hoisted_38)])) : _this.fieldSettings[$data.selectedFilter][key].label === 'Learning outcomes' ? ((0,vue_esm_bundler.openBlock)(), (0,vue_esm_bundler.createElementBlock)(vue_esm_bundler.Fragment, {
      key: 2
    }, [(0,vue_esm_bundler.createElementVNode)("strong", null, (0,vue_esm_bundler.toDisplayString)(_this.fieldSettings[$data.selectedFilter][key].label) + ": ", 1), (0,vue_esm_bundler.createElementVNode)("span", {
      innerHTML: value[0].content
    }, null, 8, _hoisted_39)], 64)) : ((0,vue_esm_bundler.openBlock)(), (0,vue_esm_bundler.createElementBlock)(vue_esm_bundler.Fragment, {
      key: 3
    }, [(0,vue_esm_bundler.createElementVNode)("strong", null, (0,vue_esm_bundler.toDisplayString)(_this.fieldSettings[$data.selectedFilter][key].label) + ": ", 1), (0,vue_esm_bundler.createElementVNode)("span", {
      innerHTML: value
    }, null, 8, _hoisted_40)], 64))]);
  }), 128))])])])])], 64);
}
;// CONCATENATED MODULE: ./resources/scripts/frontend/AppSingleCatalogue.vue?vue&type=template&id=0eaa509c

;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js??clonedRuleSet-3.use!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./node_modules/import-glob/index.js!./resources/scripts/frontend/AppSingleCatalogue.vue?vue&type=script&lang=js
function AppSingleCataloguevue_type_script_lang_js_typeof(o) { "@babel/helpers - typeof"; return AppSingleCataloguevue_type_script_lang_js_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, AppSingleCataloguevue_type_script_lang_js_typeof(o); }
function AppSingleCataloguevue_type_script_lang_js_defineProperty(obj, key, value) { key = AppSingleCataloguevue_type_script_lang_js_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function AppSingleCataloguevue_type_script_lang_js_toPropertyKey(t) { var i = AppSingleCataloguevue_type_script_lang_js_toPrimitive(t, "string"); return "symbol" == AppSingleCataloguevue_type_script_lang_js_typeof(i) ? i : i + ""; }
function AppSingleCataloguevue_type_script_lang_js_toPrimitive(t, r) { if ("object" != AppSingleCataloguevue_type_script_lang_js_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != AppSingleCataloguevue_type_script_lang_js_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }

/* harmony default export */ var AppSingleCataloguevue_type_script_lang_js = ({
  props: {
    post_id: {
      type: [Number, String],
      required: true
    }
  },
  data: function data() {
    return AppSingleCataloguevue_type_script_lang_js_defineProperty(AppSingleCataloguevue_type_script_lang_js_defineProperty({
      data: [],
      post: {},
      fieldSettings: [],
      selectedField: {},
      selectedFilter: "general",
      ects: "",
      price: "",
      status: "",
      providedAt: "",
      workload: "",
      applyURL: "",
      language: "",
      startDate: "",
      endDate: "",
      learningSchedule: "",
      buttonsClicked: false,
      activeIndex: 0
    }, "buttonsClicked", false), "burgerMenuOpen", false);
  },
  mounted: function mounted() {
    this.getData();
    this.applyStylingToPostContent();
    var firstButton = document.querySelector('.fields-buttons .data-button');
    if (firstButton) {
      firstButton.classList.add('data-btn-active');
    }
  },
  updated: function updated() {
    this.applyStylingToPostContent();
  },
  methods: {
    getData: function getData() {
      var _this = this;
      var formData = new FormData();
      formData.append("action", "get_catalogue_values");
      formData.append("post_id", this.post_id);
      scripts_FormDataApi.post(ajaxurl, formData).then(function (response) {
        _this.ects = response.data.information_about_the_lopp.ects_credit_points || "N/A";
        _this.price = response.data.information_about_the_lopp.price_details || "N/A";
        _this.status = response.data.additional.app_ddl || "N/A";
        _this.applyURL = response.data.general.homepage || "N/A";
        _this.providedAt = response.data.general.provided_at || "N/A";
        _this.workload = response.data.information_about_the_lopp.workload_in_hours || "N/A";
        _this.language = response.data.general.language || "N/A";
        _this.providedBy = response.data.general.provided_by || "N/A";
        _this.startDate = response.data.information_about_the_lopp.start_at_date || "N/A";
        _this.endDate = response.data.information_about_the_lopp.ended_at_date || "N/A";
        _this.learningSchedule = response.data.information_about_the_lopp.learning_schedule || "N/A";
        _this.data = response.data;
      });
      formData = new FormData();
      formData.append("action", "get_field_settings");
      scripts_FormDataApi.post(ajaxurl, formData).then(function (response) {
        _this.fieldSettings = response.data;
        _this.selectedField = JSON.parse(JSON.stringify(_this.data["general"]));
      });
      formData = new FormData();
      formData.append("action", "get_catalogue_post");
      formData.append("post_id", this.post_id);
      scripts_FormDataApi.post(ajaxurl, formData).then(function (response) {
        _this.post = response.data;
      });
    },
    displayData: function displayData(dataKey, index) {
      this.selectedField = JSON.parse(JSON.stringify(this.data[dataKey]));
      this.selectedFilter = dataKey;
      this.activeIndex = index;
      var buttonsContainer = document.querySelector('.fields-buttons');
      buttonsContainer.classList.add('menu-hidden');
      var field = document.getElementById('title-selected');
      field.style.display = 'flex';
      var burger = document.querySelector('.burger-menu');
      burger.classList.remove('burger-menu-hidden');
      var menu = document.querySelector(".filter-section-mobile");
      menu.classList.remove('filter-section-mobile-center');
    },
    applyStylingToPostContent: function applyStylingToPostContent() {
      var postContent = this.$refs.postContent;
      if (postContent) {
        var listItems = postContent.querySelectorAll('li');
        listItems.forEach(function (item) {
          item.classList.add("post-content-item");
        });
        var ulElements = postContent.querySelectorAll('ul');
        ulElements.forEach(function (ul) {
          ul.classList.add("info-list");
          var lastLi = ul.querySelector('li:last-child');
          if (lastLi) {
            lastLi.style.paddingBottom = '20px';
          }
        });
      }
    },
    transformKey: function transformKey(key) {
      if (key === 'general') {
        return 'General information';
      }
      if (key === 'information_about_the_lopp') {
        return 'About the learning opportunity';
      }
      if (key === 'learning_specification') {
        return 'What will I learn';
      }
      if (key === 'contact') {
        return "Contact";
      }
      return 'Additional';
    },
    getTitleForAdditional: function getTitleForAdditional(key) {
      return this.fieldSettings.additional.find(function (additionalItem) {
        return additionalItem.slug === key;
      }).title;
    },
    toggleBurgerMenu: function toggleBurgerMenu() {
      this.burgerMenuOpen = !this.burgerMenuOpen;
      var buttonsContainer = document.querySelector('.fields-buttons');
      buttonsContainer.style.display = 'flex';
      var field = document.getElementById('title-selected');
      field.style.display = 'none';
      var burger = document.querySelector('.burger-menu');
      burger.classList.add('burger-menu-hidden');
      var menu = document.querySelector(".filter-section-mobile");
      menu.classList.add('filter-section-mobile-center');
    }
  }
});
;// CONCATENATED MODULE: ./resources/scripts/frontend/AppSingleCatalogue.vue?vue&type=script&lang=js
 
;// CONCATENATED MODULE: ./resources/scripts/frontend/AppSingleCatalogue.vue




;


const AppSingleCatalogue_exports_ = /*#__PURE__*/(0,exportHelper/* default */.A)(AppSingleCataloguevue_type_script_lang_js, [['render',AppSingleCataloguevue_type_template_id_0eaa509c_render]])

/* harmony default export */ var AppSingleCatalogue = (AppSingleCatalogue_exports_);
;// CONCATENATED MODULE: ./resources/scripts/frontend/index.js
/* provided dependency */ var jQuery = __webpack_require__(669);
;




(function (frontend, $) {
  $(document).ready(function () {
    $('#tabs').tabs({
      active: 0,
      activate: function activate(event, ui) {
        var scrollTop = $(window).scrollTop();
        window.location.hash = ui.newPanel.attr('id');
        $(window).scrollTop(scrollTop);
      }
    });
  });
})(window.frontend = window.frontend || {}, jQuery);
var loaded = false;
vue_esm_bundler["default"].config.productionTip = false;
vue_esm_bundler["default"].prototype.$t = function (t) {
  return t;
};
(function (doc, found) {
  var observer = new MutationObserver(function (mutations) {
    mutations.forEach(function (mutation) {
      var yourdiv = doc.querySelector('#search-catalog-items');
      if (found && !yourdiv) {
        found = false;
      }
      if (yourdiv) {
        found = true;
        loadSearchCatalogItems();
      }
    });
  });
  observer.observe(doc, {
    childList: true,
    subtree: true
  });
})(document, false);
loadSearchCatalogItems();
function loadSearchCatalogItems() {
  if (document.getElementById('search-catalog-items')) {
    if (!loaded) {
      loaded = true;
      new vue_esm_bundler["default"]({
        el: '#search-catalog-items',
        render: function render(h) {
          return h(App);
        }
      });
    }
  }
}
if (document.getElementById('catalogue-single-page')) {
  var post_id = document.getElementById("catalogue-single-page").getAttribute('data-post-id');
  new vue_esm_bundler["default"]({
    el: '#catalogue-single-page',
    render: function render(h) {
      return h(AppSingleCatalogue, {
        props: {
          post_id: post_id
        }
      });
    }
  });
}
}();
/******/ })()
;